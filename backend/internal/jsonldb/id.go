package jsonldb

import (
	"encoding/binary"
	"encoding/json"
	"fmt"
	"sync"
	"time"
)

const (
	// epoch is 2026-01-01 00:00:00 UTC in 10µs intervals.
	epoch int64 = 176722560000000

	// idEncodedLen is the fixed length of encoded IDs.
	// 64 bits / 5 bits per char = 12.8, rounded up to 13.
	idEncodedLen = 13

	// sliceMask is the bitmask for extracting the 15-bit slice value.
	sliceMask = 0x7FFF
)

// ID is a time-sortable 64-bit identifier resistant to collisions.
//
// IDs encode a 10µs timestamp and a monotonically increasing slice for collision
// avoidance. They are lexicographically sortable when encoded as strings, making
// them suitable for use as table keys and filenames.
//
// The zero value (0) represents an invalid/unset ID.
//
// ID structure (64 bits):
//   - Bit 63: sign (always 0, keeps int64 positive)
//   - Bits 62-15: 10µs intervals since epoch (48 bits)
//   - Bits 14-0: slice (15 bits = 32768 values per 10µs)
//
// The slice field can be partitioned across multiple processes using InitIDSlice.
// The lowest-order bits of the slice are reserved for the instance ID, ensuring
// IDs generated by different processes never collide.
//
// Time span: ~89 years from epoch (until ~2115), doublable by leveraging the 63rd bit.
//
// Max throughput: ~3.27B IDs/sec total (32768 per 10µs × 100,000 intervals/sec).
type ID uint64

var (
	idMu        sync.Mutex
	idLastT10us int64
	idSlice     int

	// idInstance is the instance ID (0 to totalInstances-1).
	idInstance int
	// idTotalInstances is the total number of parallel instances.
	// Defaults to 1 (single instance mode).
	idTotalInstances int = 1
)

// InitIDSlice configures ID generation for multi-instance deployments.
//
// When running multiple parallel processes that generate IDs, each process must
// call InitIDSlice with a unique instance number to prevent ID collisions.
// The slice field's low-order bits are partitioned among instances.
//
// Parameters:
//   - instance: this process's instance number (0 to totalInstances-1)
//   - totalInstances: total number of parallel processes
//
// Example: with 3 servers, call InitIDSlice(0, 3), InitIDSlice(1, 3), and
// InitIDSlice(2, 3) on each respective server. Each server will have a fraction
// of the maximum throughput.
//
// Must be called before any NewID calls. Returns an error if parameters are
// invalid or if totalInstances exceeds the available slice bits.
func InitIDSlice(instance, totalInstances int) error {
	if totalInstances < 1 {
		return fmt.Errorf("totalInstances must be >= 1, got %d", totalInstances)
	}
	if instance < 0 || instance >= totalInstances {
		return fmt.Errorf("instance must be in [0, %d), got %d", totalInstances, instance)
	}
	if totalInstances > sliceMask+1 {
		return fmt.Errorf("totalInstances %d exceeds max %d (slice bits)", totalInstances, sliceMask+1)
	}
	idMu.Lock()
	defer idMu.Unlock()
	idInstance = instance
	idTotalInstances = totalInstances
	return nil
}

// NewID generates a new time-based ID.
//
// IDs are guaranteed to be unique and monotonically increasing within a process.
// Multiple calls in the same 10µs interval use an incrementing slice counter.
// When multiple instances are configured via InitIDSlice, the slice counter is
// partitioned so each instance uses non-overlapping values.
// If the slice overflows, it spins until the next interval to maintain uniqueness.
func NewID() ID {
	idMu.Lock()
	for {
		t10us := max(0, time.Now().UnixMicro()/10-epoch)

		if t10us != idLastT10us {
			// New interval: reset slice to instance ID
			idLastT10us = t10us
			idSlice = idInstance
			id := newIDFromParts(uint64(t10us), uint64(idSlice)) //nolint:gosec // t10us is guaranteed non-negative by max(0, ...)
			idMu.Unlock()
			return id
		}

		// Same 10µs interval: increment slice by totalInstances
		nextSlice := idSlice + idTotalInstances
		if nextSlice <= sliceMask {
			idSlice = nextSlice
			id := newIDFromParts(uint64(t10us), uint64(idSlice)) //nolint:gosec // t10us is guaranteed non-negative by max(0, ...)
			idMu.Unlock()
			return id
		}

		// Overflow: release lock, wait, and retry
		idMu.Unlock()
		time.Sleep(time.Microsecond)
		idMu.Lock()
	}
}

func newIDFromParts(t10us, slice uint64) ID {
	// t10us: 48 bits, shifted to bits 62-15
	// slice: 15 bits, in bits 14-0
	return ID((t10us << 15) | (slice & sliceMask))
}

// String encodes the ID as a compact, sortable string.
//
// Uses base32 "Extended Hex" alphabet (0-9A-V) which is ASCII-sorted,
// ensuring lexicographic string comparison matches numeric comparison.
// Leading zero-characters are stripped for compactness. Zero IDs return "0".
func (id ID) String() string {
	if id == 0 {
		return "0"
	}
	// Encode 64 bits as big-endian bytes, then base32 encode
	var buf [8]byte
	binary.BigEndian.PutUint64(buf[:], uint64(id))
	encoded := base32Enc.EncodeToString(buf[:])
	// Strip leading '0' (zeros)
	for i := range len(encoded) {
		if encoded[i] != '0' {
			return encoded[i:]
		}
	}
	return "0"
}

// MarshalJSON implements json.Marshaler.
func (id ID) MarshalJSON() ([]byte, error) {
	return json.Marshal(id.String())
}

// UnmarshalJSON implements json.Unmarshaler.
func (id *ID) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	parsed, err := DecodeID(s)
	if err != nil {
		return err
	}
	*id = parsed
	return nil
}

// IsZero returns true if the ID is the zero value.
func (id ID) IsZero() bool {
	return id == 0
}

// DecodeID parses an encoded string back to an ID.
//
// Empty string or "0" decode to zero ID. Returns an error for invalid input.
// Only uppercase letters (0-9, A-V) are accepted.
func DecodeID(s string) (ID, error) {
	if s == "0" || s == "" {
		return 0, nil
	}
	if len(s) > idEncodedLen {
		return 0, fmt.Errorf("invalid ID length: got %d, max %d", len(s), idEncodedLen)
	}
	// Reject lowercase letters
	for i := range len(s) {
		c := s[i]
		if c >= 'a' && c <= 'z' {
			return 0, fmt.Errorf("invalid ID character at position %d: %c (lowercase not allowed)", i, c)
		}
	}
	// Left-pad with '0' to full length for base32 decoding
	for len(s) < idEncodedLen {
		s = "0" + s
	}
	decoded, err := base32Enc.DecodeString(s)
	if err != nil {
		return 0, fmt.Errorf("invalid ID encoding: %w", err)
	}
	return ID(binary.BigEndian.Uint64(decoded)), nil
}

// Time extracts the timestamp from an ID.
//
// This is the moment this ID was generated, in UTC, at 10µs resolution.
func (id ID) Time() time.Time {
	t10us := int64(id>>15) + epoch //nolint:gosec // bit 63 is always 0, so id>>15 fits in int64
	return time.UnixMicro(t10us * 10)
}

// Slice extracts the slice counter from an ID.
//
// This is a 15-bit value.
func (id ID) Slice() int {
	return int(id & sliceMask) //nolint:gosec // sliceMask is 0x7FFF (15 bits), always fits in int
}

// Compare returns -1 if id < other, 0 if equal, 1 if id > other.
func (id ID) Compare(other ID) int {
	if id < other {
		return -1
	}
	if id > other {
		return 1
	}
	return 0
}
