package jsonldb

import (
	"encoding/json"
	"fmt"
	"sync"
	"time"
)

// ID structure (64 bits):
//   - Bit 63: sign (always 0, keeps int64 positive)
//   - Bits 62-15: 10µs intervals since epoch (48 bits)
//   - Bits 14-0: slice (15 bits = 32768 values per 10µs)
//
// The slice field can be partitioned across multiple processes using InitIDSlice.
// The low-order bits of the slice are reserved for the instance ID, ensuring
// IDs generated by different processes never collide.
//
// Time span: ~89 years from epoch (until ~2115).
// Max throughput: ~3.27B IDs/sec total (32768 per 10µs × 100,000 intervals/sec).
const (
	// epoch is 2026-01-01 00:00:00 UTC in 10µs intervals.
	epoch int64 = 176722560000000

	// idEncodedLen is the fixed length of encoded IDs.
	// 64 bits / 6 bits per char = 10.67, rounded up to 11.
	idEncodedLen = 11

	// sliceMask is the bitmask for extracting the 15-bit slice value.
	sliceMask = 0x7FFF
)

// sortableAlphabet is a 64-character alphabet in ASCII order for lexicographic sorting.
// Characters: 0-9 (0x30-39), A-Z (0x41-5A), _ (0x5F), a-z (0x61-7A), ~ (0x7E).
// This is NOT standard base64; it uses ASCII-ordered characters so that
// lexicographic string comparison matches numeric comparison.
const sortableAlphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~"

// decodeMap maps ASCII characters back to their 6-bit values.
var decodeMap [128]byte

func init() {
	for i := range decodeMap {
		decodeMap[i] = 0xFF // invalid
	}
	for i, c := range sortableAlphabet {
		decodeMap[c] = byte(i)
	}
}

// ID is a time-sortable 64-bit identifier inspired by LUCI IDs.
//
// IDs encode a 10µs timestamp and a monotonically increasing slice for collision
// avoidance. They are lexicographically sortable when encoded as strings, making
// them suitable for use as table keys and filenames.
// The zero value (0) represents an invalid/unset ID.
type ID uint64

var (
	idMu        sync.Mutex
	idLastT10us int64
	idSlice     int

	// idInstance is the instance ID (0 to totalInstances-1).
	idInstance int
	// idTotalInstances is the total number of parallel instances.
	// Defaults to 1 (single instance mode).
	idTotalInstances int = 1
)

// InitIDSlice configures ID generation for multi-instance deployments.
//
// When running multiple parallel processes that generate IDs, each process must
// call InitIDSlice with a unique instance number to prevent ID collisions.
// The slice field's low-order bits are partitioned among instances.
//
// Parameters:
//   - instance: this process's instance number (0 to totalInstances-1)
//   - totalInstances: total number of parallel processes
//
// Example: with 3 servers, call InitIDSlice(0, 3), InitIDSlice(1, 3), and
// InitIDSlice(2, 3) on each respective server.
//
// Must be called before any NewID calls. Returns an error if parameters are
// invalid or if totalInstances exceeds the available slice bits.
func InitIDSlice(instance, totalInstances int) error {
	if totalInstances < 1 {
		return fmt.Errorf("totalInstances must be >= 1, got %d", totalInstances)
	}
	if instance < 0 || instance >= totalInstances {
		return fmt.Errorf("instance must be in [0, %d), got %d", totalInstances, instance)
	}
	if totalInstances > sliceMask+1 {
		return fmt.Errorf("totalInstances %d exceeds max %d (slice bits)", totalInstances, sliceMask+1)
	}
	idMu.Lock()
	defer idMu.Unlock()
	idInstance = instance
	idTotalInstances = totalInstances
	return nil
}

// NewID generates a new time-based ID.
//
// IDs are guaranteed to be unique and monotonically increasing within a process.
// Multiple calls in the same 10µs interval use an incrementing slice counter.
// When multiple instances are configured via InitIDSlice, the slice counter is
// partitioned so each instance uses non-overlapping values.
// If the slice overflows, it spins until the next interval to maintain uniqueness.
func NewID() ID {
	idMu.Lock()
	for {
		t10us := max(0, time.Now().UnixMicro()/10-epoch)

		if t10us != idLastT10us {
			// New interval: reset slice to instance ID
			idLastT10us = t10us
			idSlice = idInstance
			id := newIDFromParts(uint64(t10us), uint64(idSlice)) //nolint:gosec // t10us is guaranteed non-negative by max(0, ...)
			idMu.Unlock()
			return id
		}

		// Same 10µs interval: increment slice by totalInstances
		nextSlice := idSlice + idTotalInstances
		if nextSlice <= sliceMask {
			idSlice = nextSlice
			id := newIDFromParts(uint64(t10us), uint64(idSlice)) //nolint:gosec // t10us is guaranteed non-negative by max(0, ...)
			idMu.Unlock()
			return id
		}

		// Overflow: release lock, wait, and retry
		idMu.Unlock()
		time.Sleep(time.Microsecond)
		idMu.Lock()
	}
}

func newIDFromParts(t10us, slice uint64) ID {
	// t10us: 48 bits, shifted to bits 62-15
	// slice: 15 bits, in bits 14-0
	return ID((t10us << 15) | (slice & sliceMask))
}

// String encodes the ID as a compact, sortable string.
//
// Uses a custom 64-character alphabet ordered by ASCII value (not base64),
// encoding 6 bits per character in big-endian order. This ensures lexicographic
// string comparison matches numeric comparison, making IDs sortable as strings.
// Leading zero-characters are stripped for compactness. Zero IDs return "0".
func (id ID) String() string {
	if id == 0 {
		return "0"
	}
	// Encode 64 bits into up to 11 characters (6 bits each)
	var buf [idEncodedLen]byte
	v := uint64(id)
	// Process from right to left, 6 bits at a time
	for i := idEncodedLen - 1; i >= 0; i-- {
		buf[i] = sortableAlphabet[v&0x3F]
		v >>= 6
	}
	// Strip leading '0' (zeros)
	for i := range idEncodedLen {
		if buf[i] != '0' { //nolint:gosec // i is bounded by idEncodedLen (11), buf has length idEncodedLen
			return string(buf[i:])
		}
	}
	// Unreachable: any non-zero ID has at least one non-'0' character.
	// Kept as safety fallback.
	return "0"
}

// MarshalJSON implements json.Marshaler.
func (id ID) MarshalJSON() ([]byte, error) {
	return json.Marshal(id.String())
}

// UnmarshalJSON implements json.Unmarshaler.
func (id *ID) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	parsed, err := DecodeID(s)
	if err != nil {
		return err
	}
	*id = parsed
	return nil
}

// IsZero returns true if the ID is the zero value.
func (id ID) IsZero() bool {
	return id == 0
}

// DecodeID parses an encoded string back to an ID.
//
// Empty string or "0" decode to zero ID. Returns an error for invalid input.
func DecodeID(s string) (ID, error) {
	if s == "0" || s == "" {
		return 0, nil
	}
	if len(s) > idEncodedLen {
		return 0, fmt.Errorf("invalid ID length: got %d, max %d", len(s), idEncodedLen)
	}
	// Left-pad with '0' (zero char) to full length
	for len(s) < idEncodedLen {
		s = "0" + s
	}
	var v uint64
	for i := range idEncodedLen {
		c := s[i]
		if c >= 128 {
			return 0, fmt.Errorf("invalid ID character at position %d: %c", i, c)
		}
		val := decodeMap[c]
		if val == 0xFF {
			return 0, fmt.Errorf("invalid ID character at position %d: %c", i, c)
		}
		v = (v << 6) | uint64(val)
	}
	return ID(v), nil
}

// Time extracts the timestamp from an ID.
func (id ID) Time() time.Time {
	t10us := int64(id>>15) + epoch //nolint:gosec // bit 63 is always 0, so id>>15 fits in int64
	return time.UnixMicro(t10us * 10)
}

// Slice extracts the slice counter from an ID.
func (id ID) Slice() int {
	return int(id & sliceMask) //nolint:gosec // sliceMask is 0x7FFF (15 bits), always fits in int
}

// Compare returns -1 if id < other, 0 if equal, 1 if id > other.
func (id ID) Compare(other ID) int {
	if id < other {
		return -1
	}
	if id > other {
		return 1
	}
	return 0
}
