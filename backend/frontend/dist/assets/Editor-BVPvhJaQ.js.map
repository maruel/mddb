{"version":3,"file":"Editor-BVPvhJaQ.js","sources":["../../../../frontend/src/components/editor/markdown-utils.ts","../../../../frontend/src/components/editor/schema.ts","../../../../frontend/src/components/editor/blockInputRules.ts","../../../../frontend/src/components/editor/blockKeymap.ts","../../../../frontend/src/components/editor/blockDragPlugin.ts","../../../../frontend/src/components/editor/blockSelectionPlugin.ts","../../../../frontend/src/components/editor/numberCounterPlugin.ts","../../../../frontend/src/components/editor/prosemirror-config.ts","../../../../frontend/src/components/editor/nested-schema.ts","../../../../frontend/src/components/editor/markdown-parser.ts","../../../../frontend/src/components/editor/markdown-serializer.ts","../../../../frontend/src/components/editor/BlockNodeView.ts","../../../../frontend/src/components/editor/blockCommands.ts","../../../../frontend/src/components/editor/slashCommandPlugin.ts","../../../../frontend/src/components/editor/dropUploadPlugin.ts","../../../../frontend/src/components/editor/invalidLinkPlugin.ts","../../../../frontend/src/components/editor/useAssetUpload.ts","../../../../frontend/src/components/editor/BlockContextMenu.tsx","../../../../frontend/src/components/editor/EditorDropIndicator.tsx","../../../../frontend/src/components/editor/slashCommands.ts","../../../../frontend/src/components/editor/SlashCommandMenu.tsx","../../../../frontend/src/components/editor/EditorToolbar.tsx","../../../../frontend/src/components/editor/Editor.tsx"],"sourcesContent":["// Utility functions for asset URL handling in markdown content.\n\nimport type { AssetUrlMap } from '../../contexts/EditorContext';\nimport type { NodeTitleMap } from '../../utils/markdown-utils';\n\n// Re-export NodeTitleMap and extractLinkedNodeIds from utils for backward compatibility\nexport type { NodeTitleMap } from '../../utils/markdown-utils';\nexport { extractLinkedNodeIds } from '../../utils/markdown-utils';\n\n/**\n * Check if a source looks like a local filename (not a URL or absolute path).\n */\nfunction isLocalFilename(src: string): boolean {\n  // Skip if it looks like a URL (contains ://)\n  if (src.includes('://')) return false;\n  // Skip if it starts with / (absolute path)\n  if (src.startsWith('/')) return false;\n  return true;\n}\n\n/**\n * Rewrite asset URLs from local filenames to signed URLs.\n * Transforms: ![alt](filename.png) -> ![alt](/assets/.../filename.png?sig=...)\n * Also transforms: [text](filename.pdf) -> [text](/assets/.../filename.pdf?sig=...)\n * Uses the asset URL map from the backend which contains signed URLs.\n */\nexport function rewriteAssetUrls(markdown: string, assetUrls: AssetUrlMap): string {\n  if (!assetUrls || Object.keys(assetUrls).length === 0) return markdown;\n\n  // Match markdown images with local filenames (not URLs or absolute paths)\n  // Matches: ![...](filename.ext) but not ![...](http...) or ![...](/...)\n  let result = markdown.replace(/!\\[([^\\]]*)\\]\\(([^/)][^)]*)\\)/g, (match, alt, src) => {\n    if (!isLocalFilename(src)) return match;\n    // Look up signed URL from asset map\n    const signedUrl = assetUrls[src];\n    if (signedUrl) {\n      return `![${alt}](${signedUrl})`;\n    }\n    // Keep original if no signed URL found\n    return match;\n  });\n\n  // Match markdown links with local filenames that are in the asset map\n  // This handles linked files like PDFs\n  result = result.replace(/\\[([^\\]]+)\\]\\(([^/)][^)]*)\\)/g, (match, text, href) => {\n    if (!isLocalFilename(href)) return match;\n    // Only convert if this filename is in the asset map\n    const signedUrl = assetUrls[href];\n    if (signedUrl) {\n      return `[${text}](${signedUrl})`;\n    }\n    return match;\n  });\n\n  return result;\n}\n\n// Regex to extract filename from signed asset URLs: /assets/{wsID}/{nodeID}/{filename}?...\nconst ASSET_URL_PATTERN = /^\\/assets\\/[^/]+\\/[^/]+\\/([^?]+)/;\n\n/**\n * Extract filename from a signed asset URL.\n * Returns the filename or null if the URL doesn't match the pattern.\n */\nfunction extractFilenameFromAssetUrl(url: string): string | null {\n  const match = url.match(ASSET_URL_PATTERN);\n  if (match && match[1]) {\n    // Decode URL-encoded characters (e.g., %20 -> space)\n    return decodeURIComponent(match[1]);\n  }\n  return null;\n}\n\n/**\n * Reverse asset URL rewriting from signed URLs to local filenames.\n * Transforms: ![alt](/assets/wsId/nodeId/filename.png?sig=...) -> ![alt](filename.png)\n * Used when saving content back to the backend.\n *\n * Handles both:\n * 1. URLs in the assetUrls map (exact match)\n * 2. Signed asset URLs matching /assets/{wsID}/{nodeID}/{filename}?... pattern\n */\nexport function reverseRewriteAssetUrls(markdown: string, assetUrls: AssetUrlMap): string {\n  // Build reverse map: signed URL -> filename\n  const reverseMap: Record<string, string> = {};\n  for (const [filename, url] of Object.entries(assetUrls || {})) {\n    reverseMap[url] = filename;\n  }\n\n  // Helper to convert a URL to filename\n  const urlToFilename = (url: string): string | null => {\n    // First try exact match in reverse map\n    if (reverseMap[url]) {\n      return reverseMap[url];\n    }\n    // Then try extracting from signed asset URL pattern\n    return extractFilenameFromAssetUrl(url);\n  };\n\n  // Match markdown images: ![alt](url)\n  let result = markdown.replace(/!\\[([^\\]]*)\\]\\(([^)]+)\\)/g, (match, alt, src) => {\n    const filename = urlToFilename(src);\n    if (filename) {\n      return `![${alt}](${filename})`;\n    }\n    return match;\n  });\n\n  // Match markdown links: [text](url)\n  // Only convert links that point to signed asset URLs\n  result = result.replace(/\\[([^\\]]+)\\]\\(([^)]+)\\)/g, (match, text, href) => {\n    // Only process asset URLs (not regular links)\n    const filename = extractFilenameFromAssetUrl(href);\n    if (filename) {\n      return `[${text}](${filename})`;\n    }\n    return match;\n  });\n\n  return result;\n}\n\n// --- Internal Page Link Utilities ---\n\n/**\n * Rewrite internal page link display text to show current titles.\n * Transforms: [OldTitle](/w/@{wsId}+{slug}/@{nodeId}+{slug}) -> [CurrentTitle](/w/@{wsId}+{slug}/@{nodeId}+{slug})\n *\n * The URL is preserved exactly as-is; only the display text is updated.\n * Links to nodes not in the title map are left unchanged.\n *\n * @param markdown The markdown content to transform\n * @param nodeTitles Map of node ID to current title\n * @param currentWsId The current workspace ID to filter links by\n * @returns Markdown with link display text updated to current titles\n */\nexport function rewriteInternalLinkTitles(markdown: string, nodeTitles: NodeTitleMap, currentWsId: string): string {\n  if (!markdown || !currentWsId || !nodeTitles || Object.keys(nodeTitles).length === 0) {\n    return markdown;\n  }\n\n  // Pattern captures: full match, text, wsId, nodeId (and anything after)\n  return markdown.replace(\n    /\\[([^\\]]*)\\]\\((\\/w\\/@([^/+]+)(?:\\+[^/]*)?\\/@([A-Za-z0-9]+)(?:\\+[^)]*)?)\\)/g,\n    (match, _text, url, wsId, nodeId) => {\n      // Only rewrite links to the current workspace\n      if (wsId !== currentWsId) {\n        return match;\n      }\n      // Look up the current title\n      const currentTitle = nodeTitles[nodeId];\n      if (currentTitle !== undefined) {\n        return `[${currentTitle}](${url})`;\n      }\n      // Keep original if no title found (page might be deleted)\n      return match;\n    }\n  );\n}\n\n/**\n * Reverse of rewriteInternalLinkTitles - used when saving content.\n * Since we don't modify the markdown when saving (titles stay in storage),\n * this function is provided for consistency but currently just returns the input.\n *\n * The design approach is:\n * - Storage: markdown keeps whatever title was there when the link was created\n * - Display: titles are resolved at render time from the title map\n * - Save: original markdown is preserved (no rewriting in storage)\n */\nexport function reverseInternalLinkTitles(markdown: string): string {\n  // Currently a no-op: we preserve original markdown on save\n  return markdown;\n}\n","// Flat block schema for Notion-style editor with uniform drag-drop.\n// Every visible line is a top-level block node with attributes for type, indentation, and styling.\n\nimport { Schema, type NodeSpec, type DOMOutputSpec } from 'prosemirror-model';\nimport { schema as baseSchema } from 'prosemirror-markdown';\n\n// Block types: correspond to different content kinds\nexport type BlockType = 'paragraph' | 'heading' | 'bullet' | 'number' | 'task' | 'quote' | 'code' | 'divider';\n\n// Block attributes: describe a single block's type, nesting level, and metadata\nexport interface BlockAttrs {\n  type: BlockType;\n  level?: number; // heading level (1-6)\n  indent: number; // nesting depth (0+), enables drag-and-drop without changing type\n  checked?: boolean; // task completion state (for type=task)\n  number?: number; // sequential number (for type=number)\n  language?: string; // code block language (for type=code)\n}\n\n// Block node specification: all content lines are unified under this node\nconst blockSpec: NodeSpec = {\n  attrs: {\n    type: { default: 'paragraph' },\n    level: { default: null },\n    indent: { default: 0 },\n    checked: { default: null },\n    number: { default: null },\n    language: { default: null },\n  },\n  content: 'inline*',\n  group: 'block',\n  parseDOM: [\n    // Headings: h1-h6\n    { tag: 'h1', attrs: { type: 'heading', level: 1 } },\n    { tag: 'h2', attrs: { type: 'heading', level: 2 } },\n    { tag: 'h3', attrs: { type: 'heading', level: 3 } },\n    { tag: 'h4', attrs: { type: 'heading', level: 4 } },\n    { tag: 'h5', attrs: { type: 'heading', level: 5 } },\n    { tag: 'h6', attrs: { type: 'heading', level: 6 } },\n\n    // Task list items: li.task-list-item with optional data-checked\n    {\n      tag: 'li.task-list-item',\n      getAttrs(dom: HTMLElement) {\n        return {\n          type: 'task',\n          checked: dom.dataset.checked === 'true',\n          indent: parseInt(dom.dataset.indent || '0', 10),\n        };\n      },\n    },\n\n    // Bullet and numbered list items: plain li, context determines bullet vs number\n    // For now, default to bullet; number type is handled via attributes from HTML5 data\n    {\n      tag: 'li',\n      getAttrs(dom: HTMLElement) {\n        return {\n          type: dom.dataset.type === 'number' ? 'number' : 'bullet',\n          indent: parseInt(dom.dataset.indent || '0', 10),\n        };\n      },\n    },\n\n    // Blockquote: blockquote > p or just blockquote\n    {\n      tag: 'blockquote',\n      attrs: { type: 'quote' },\n    },\n\n    // Code block: pre with optional data-language\n    {\n      tag: 'pre',\n      getAttrs(dom: HTMLElement) {\n        // Try to extract language from class names or data attribute\n        // Import extractCodeLanguage from dom-parser\n        let language: string | null = dom.dataset.language || null;\n\n        if (!language) {\n          const classes = Array.from(dom.classList);\n          for (const cls of classes) {\n            if (cls.startsWith('language-')) {\n              language = cls.slice(9);\n              break;\n            }\n            if (cls.startsWith('lang-')) {\n              language = cls.slice(5);\n              break;\n            }\n            if (cls.startsWith('hljs-')) {\n              language = cls.slice(5);\n              break;\n            }\n          }\n        }\n\n        return {\n          type: 'code',\n          language,\n        };\n      },\n    },\n\n    // Horizontal rule: hr\n    {\n      tag: 'hr',\n      attrs: { type: 'divider' },\n    },\n\n    // Paragraph: default, catch-all\n    { tag: 'p', attrs: { type: 'paragraph' } },\n  ],\n  toDOM(node): DOMOutputSpec {\n    const { type, level, indent, checked, language } = node.attrs;\n    const baseAttrs: Record<string, string> = {\n      'data-type': type,\n      'data-indent': String(indent),\n    };\n\n    switch (type) {\n      case 'heading': {\n        const tag = `h${level || 1}`;\n        return [tag, baseAttrs, 0];\n      }\n\n      case 'bullet':\n      case 'number': {\n        const attrs = { ...baseAttrs, class: `block-${type}` };\n        return ['div', attrs, 0];\n      }\n\n      case 'task': {\n        const attrs = {\n          ...baseAttrs,\n          class: 'block-task',\n          'data-checked': String(checked || false),\n        };\n        return ['div', attrs, 0];\n      }\n\n      case 'quote': {\n        return ['blockquote', baseAttrs, 0];\n      }\n\n      case 'code': {\n        const attrs = {\n          ...baseAttrs,\n          'data-language': language || '',\n        };\n        return ['pre', attrs, ['code', 0]];\n      }\n\n      case 'divider': {\n        return ['hr', baseAttrs];\n      }\n\n      default:\n        return ['p', baseAttrs, 0];\n    }\n  },\n};\n\n// Divider node: empty block for horizontal rules\nconst dividerSpec: NodeSpec = {\n  attrs: {\n    type: { default: 'divider' },\n    indent: { default: 0 },\n  },\n  content: 'inline*',\n  group: 'block',\n  parseDOM: [{ tag: 'hr', attrs: { type: 'divider' } }],\n  toDOM(node): DOMOutputSpec {\n    return ['hr', { 'data-type': 'divider', 'data-indent': String(node.attrs.indent) }];\n  },\n};\n\n// Create flat block schema: replace nested list/heading/paragraph nodes with single block node\nexport const schema = new Schema({\n  nodes: baseSchema.spec.nodes\n    .remove('bullet_list')\n    .remove('ordered_list')\n    .remove('list_item')\n    .remove('paragraph')\n    .remove('heading')\n    .remove('blockquote')\n    .remove('code_block')\n    .remove('horizontal_rule')\n    .addToEnd('block', blockSpec)\n    .addToEnd('divider', dividerSpec),\n  marks: baseSchema.spec.marks\n    .addToEnd('underline', {\n      parseDOM: [{ tag: 'u' }, { style: 'text-decoration=underline' }],\n      toDOM(): DOMOutputSpec {\n        return ['u', 0];\n      },\n    })\n    .addToEnd('strikethrough', {\n      parseDOM: [{ tag: 's' }, { tag: 'del' }, { style: 'text-decoration=line-through' }],\n      toDOM(): DOMOutputSpec {\n        return ['s', 0];\n      },\n    }),\n});\n\n// Helper to get node type with runtime check\nfunction getNodeType(name: string) {\n  const nodeType = schema.nodes[name];\n  if (!nodeType) throw new Error(`Node type '${name}' not found in schema`);\n  return nodeType;\n}\n\n// Helper to get mark type with runtime check\nfunction getMarkType(name: string) {\n  const markType = schema.marks[name];\n  if (!markType) throw new Error(`Mark type '${name}' not found in schema`);\n  return markType;\n}\n\n// Exported node types for use in plugins and commands\nexport const nodes = {\n  doc: getNodeType('doc'),\n  block: getNodeType('block'),\n  divider: getNodeType('divider'),\n};\n\n// Exported mark types for use in plugins and commands\nexport const marks = {\n  strong: getMarkType('strong'),\n  em: getMarkType('em'),\n  code: getMarkType('code'),\n  link: getMarkType('link'),\n  underline: getMarkType('underline'),\n  strikethrough: getMarkType('strikethrough'),\n};\n","// Input rules for flat block editor.\n// Convert markdown-style syntax to block attributes.\n\nimport { inputRules, InputRule } from 'prosemirror-inputrules';\nimport { smartQuotes, ellipsis, emDash } from 'prosemirror-inputrules';\nimport type { EditorState } from 'prosemirror-state';\n\n/**\n * Helper to create a block type conversion input rule.\n * Deletes the trigger text and updates the current block's attributes.\n */\nfunction blockTypeRule(pattern: RegExp, getAttrs: (match: RegExpMatchArray) => Record<string, unknown>): InputRule {\n  return new InputRule(pattern, (state: EditorState, match, start, end) => {\n    const $start = state.doc.resolve(start);\n\n    // Only apply at the start of a block\n    if ($start.parentOffset !== 0) return null;\n\n    const blockPos = $start.before(1);\n    const attrs = getAttrs(match);\n\n    return state.tr.delete(start, end).setNodeMarkup(blockPos, undefined, attrs);\n  });\n}\n\n/**\n * Build input rules for flat block editor.\n */\nexport function buildBlockInputRules() {\n  return inputRules({\n    rules: [\n      // Bullet list: - or * at start followed by space\n      blockTypeRule(/^[-*]\\s$/, () => ({\n        type: 'bullet',\n        indent: 0,\n        level: null,\n        checked: null,\n        language: null,\n      })),\n\n      // Numbered list: 1. at start (any number)\n      blockTypeRule(/^(\\d+)\\.\\s$/, () => ({\n        type: 'number',\n        indent: 0,\n        level: null,\n        checked: null,\n        language: null,\n      })),\n\n      // Task list (unchecked): - [ ] at start\n      blockTypeRule(/^[-*]\\s*\\[\\s\\]\\s$/, () => ({\n        type: 'task',\n        indent: 0,\n        checked: false,\n        level: null,\n        language: null,\n      })),\n\n      // Task list (unchecked): [ ] at start (fallback if bullet rule consumed dash)\n      blockTypeRule(/^\\[\\s\\]\\s$/, () => ({\n        type: 'task',\n        indent: 0,\n        checked: false,\n        level: null,\n        language: null,\n      })),\n\n      // Task list (checked): - [x] or - [X] at start\n      blockTypeRule(/^[-*]\\s*\\[[xX]\\]\\s$/, () => ({\n        type: 'task',\n        indent: 0,\n        checked: true,\n        level: null,\n        language: null,\n      })),\n\n      // Task list (checked): [x] or [X] at start (fallback)\n      blockTypeRule(/^\\[[xX]\\]\\s$/, () => ({\n        type: 'task',\n        indent: 0,\n        checked: true,\n        level: null,\n        language: null,\n      })),\n\n      // Heading 1: # at start\n      blockTypeRule(/^#\\s$/, () => ({\n        type: 'heading',\n        level: 1,\n        indent: 0,\n        checked: null,\n        language: null,\n      })),\n\n      // Heading 2: ## at start\n      blockTypeRule(/^##\\s$/, () => ({\n        type: 'heading',\n        level: 2,\n        indent: 0,\n        checked: null,\n        language: null,\n      })),\n\n      // Heading 3: ### at start\n      blockTypeRule(/^###\\s$/, () => ({\n        type: 'heading',\n        level: 3,\n        indent: 0,\n        checked: null,\n        language: null,\n      })),\n\n      // Heading 4: #### at start\n      blockTypeRule(/^####\\s$/, () => ({\n        type: 'heading',\n        level: 4,\n        indent: 0,\n        checked: null,\n        language: null,\n      })),\n\n      // Heading 5: ##### at start\n      blockTypeRule(/^#####\\s$/, () => ({\n        type: 'heading',\n        level: 5,\n        indent: 0,\n        checked: null,\n        language: null,\n      })),\n\n      // Heading 6: ###### at start\n      blockTypeRule(/^######\\s$/, () => ({\n        type: 'heading',\n        level: 6,\n        indent: 0,\n        checked: null,\n        language: null,\n      })),\n\n      // Blockquote: > at start\n      blockTypeRule(/^>\\s$/, () => ({\n        type: 'quote',\n        indent: 0,\n        level: null,\n        checked: null,\n        language: null,\n      })),\n\n      // Code block: ``` with optional language at start followed by space\n      new InputRule(/^```(\\w*)\\s$/, (state: EditorState, match, start, end) => {\n        const $start = state.doc.resolve(start);\n\n        // Only apply in an empty block at the start\n        if ($start.parentOffset !== 0) return null;\n\n        const blockPos = $start.before(1);\n\n        // Let's just trust the regex for now.\n        // If we require space, the user types space.\n\n        return state.tr.delete(start, end).setNodeMarkup(blockPos, undefined, {\n          type: 'code',\n          language: match[1] || null,\n          indent: 0,\n          level: null,\n          checked: null,\n        });\n      }),\n\n      // Divider: --- at start of empty block (exactly three dashes)\n      // Note: emDash rule might convert -- to — (em dash) before this rule triggers on the 3rd dash.\n      // So we match either --- or —-\n      new InputRule(/^(---|—-|—)$/, (state: EditorState, match, start, end) => {\n        const $start = state.doc.resolve(start);\n        const blockPos = $start.before(1);\n        const block = state.doc.nodeAt(blockPos);\n\n        // Only convert if the block only contains \"---\" (minus the last char which is being typed)\n        // match[0] is \"---\" (len 3) or \"—-\" (len 2).\n        // content in doc is \"--\" (len 2) or \"—\" (len 1).\n        // So doc content length should be match[0].length - 1.\n        if (block && block.textContent.length === match[0].length - 1) {\n          return state.tr.delete(start, end).setNodeMarkup(blockPos, undefined, {\n            type: 'divider',\n            indent: 0,\n            level: null,\n            checked: null,\n            language: null,\n          });\n        }\n\n        return null;\n      }),\n\n      // Smart typography\n      ...smartQuotes,\n      ellipsis,\n      emDash,\n    ],\n  });\n}\n","// Keyboard bindings for flat block editor.\n// Handles Tab/Shift-Tab for indentation, Enter for block splitting, Backspace for merging.\n\nimport { keymap } from 'prosemirror-keymap';\nimport { type Command, type EditorState } from 'prosemirror-state';\nimport { type BlockType } from './schema';\n\n/**\n * Check if a block type is list-like (supports indentation).\n */\nfunction isListType(type: BlockType): boolean {\n  return ['bullet', 'number', 'task'].includes(type);\n}\n\n/**\n * Get the current block node and position from cursor position.\n */\nfunction getCurrentBlock(state: EditorState) {\n  const { $from } = state.selection;\n  const blockPos = $from.before(1);\n  const node = state.doc.nodeAt(blockPos);\n  return { node, pos: blockPos, $from };\n}\n\n/**\n * Tab: Increase indentation for list-like blocks.\n */\nconst indentCommand: Command = (state, dispatch) => {\n  const { node, pos } = getCurrentBlock(state);\n  if (!node) return false;\n\n  const { type, indent } = node.attrs;\n  if (!isListType(type as BlockType)) return false;\n  if ((indent as number) >= 8) return false;\n\n  if (dispatch) {\n    dispatch(\n      state.tr.setNodeMarkup(pos, undefined, {\n        ...node.attrs,\n        indent: (indent as number) + 1,\n      })\n    );\n  }\n  return true;\n};\n\n/**\n * Shift-Tab: Decrease indentation.\n */\nconst outdentCommand: Command = (state, dispatch) => {\n  const { node, pos } = getCurrentBlock(state);\n  if (!node) return false;\n\n  const { indent } = node.attrs;\n  if ((indent as number) <= 0) return false;\n\n  if (dispatch) {\n    dispatch(\n      state.tr.setNodeMarkup(pos, undefined, {\n        ...node.attrs,\n        indent: (indent as number) - 1,\n      })\n    );\n  }\n  return true;\n};\n\n/**\n * Enter: Split block or convert empty list item to paragraph.\n */\nconst enterCommand: Command = (state, dispatch) => {\n  const { $from, empty } = state.selection;\n  if (!empty) return false;\n\n  const { node, pos } = getCurrentBlock(state);\n  if (!node) return false;\n\n  const { type, indent } = node.attrs;\n\n  // Only handle list-type blocks specially\n  if (!isListType(type as BlockType)) return false;\n\n  // If block is empty, convert to paragraph or decrease indent\n  if (node.content.size === 0) {\n    if (dispatch) {\n      const newAttrs =\n        (indent as number) > 0\n          ? { type, indent: (indent as number) - 1, checked: type === 'task' ? false : null }\n          : { type: 'paragraph', indent: 0, checked: null };\n      dispatch(state.tr.setNodeMarkup(pos, undefined, newAttrs));\n    }\n    return true;\n  }\n\n  // Split at cursor position\n  if (dispatch) {\n    const splitPos = $from.pos;\n    const newAttrs = { ...node.attrs };\n\n    // Reset checked state for new task items\n    if (type === 'task') {\n      newAttrs.checked = false;\n    }\n\n    // We split block (depth 1)\n    // Pass typesAfter to ensure the new block has correct attributes\n    dispatch(state.tr.split(splitPos, 1, [{ type: node.type, attrs: newAttrs }]));\n\n    // Scroll to view selection\n    // dispatch(state.tr.scrollIntoView()); // usually handled by view\n  }\n  return true;\n};\n\n/**\n * Backspace at start of block: Merge with previous or convert to paragraph.\n */\nconst backspaceCommand: Command = (state, dispatch) => {\n  const { $from, empty } = state.selection;\n  if (!empty || $from.parentOffset !== 0) return false;\n\n  const { node, pos } = getCurrentBlock(state);\n  if (!node) return false;\n\n  const { type, indent } = node.attrs;\n\n  // If indented, outdent first\n  if ((indent as number) > 0) {\n    if (dispatch) {\n      dispatch(\n        state.tr.setNodeMarkup(pos, undefined, {\n          ...node.attrs,\n          indent: (indent as number) - 1,\n        })\n      );\n    }\n    return true;\n  }\n\n  // If list/quote type, convert to paragraph\n  if (['bullet', 'number', 'task', 'quote'].includes(type as string)) {\n    if (dispatch) {\n      dispatch(\n        state.tr.setNodeMarkup(pos, undefined, {\n          type: 'paragraph',\n          indent: 0,\n          checked: null,\n          level: null,\n          language: null,\n        })\n      );\n    }\n    return true;\n  }\n\n  // Let default backspace handle merging paragraphs\n  return false;\n};\n\n/**\n * Build keymap for flat block editor.\n * Should be added to plugins list.\n */\nexport function buildBlockKeymap() {\n  return keymap({\n    Tab: indentCommand,\n    'Shift-Tab': outdentCommand,\n    Enter: enterCommand,\n    Backspace: backspaceCommand,\n  });\n}\n\n/**\n * Export individual commands for testing and programmatic use.\n */\nexport const blockKeymapCommands = {\n  indent: indentCommand,\n  outdent: outdentCommand,\n  enter: enterCommand,\n  backspace: backspaceCommand,\n};\n","// ProseMirror plugin for block-level drag-and-drop functionality.\n// Manages drag state and provides drop indicator decorations.\n\nimport { Plugin, PluginKey, type EditorState, type Transaction } from 'prosemirror-state';\nimport { DecorationSet, type EditorView } from 'prosemirror-view';\n\n// Drag state interface (only tracks drop target for visual indicator)\nexport interface DragState {\n  /** Position to drop (between blocks) */\n  dropTarget: number | null;\n  /** Y coordinate for visual indicator */\n  dropIndicatorY: number | null;\n}\n\n// Plugin key for accessing drag state\nexport const blockDragPluginKey = new PluginKey<DragState>('blockDrag');\n\n// Initial state\nconst initialState: DragState = {\n  dropTarget: null,\n  dropIndicatorY: null,\n};\n\n/**\n * Get positions of all blocks in the current selection.\n * Used for multi-block drag operations.\n */\nexport function getSelectedBlockPositions(state: EditorState): number[] {\n  const positions: number[] = [];\n  // Use blockRange to identify the range of blocks\n  const $from = state.doc.resolve(state.selection.from);\n  const $to = state.doc.resolve(state.selection.to);\n  const range = $from.blockRange($to);\n\n  if (range && range.parent.type.name === 'doc') {\n    // Iterate manually through the range indices to ensure we capture all top-level blocks\n    // `range.start` is the position of the start of the range (before first block)\n    let currentPos = range.start;\n    for (let i = range.startIndex; i < range.endIndex; i++) {\n      const child = range.parent.child(i);\n      if (child.type.name === 'block') {\n        positions.push(currentPos);\n      }\n      currentPos += child.nodeSize;\n    }\n    return positions;\n  }\n\n  // Handle single block selection specifically\n  // If the selection is inside a block, blockRange might return null (inline content range)\n  // or the parent might be the block itself (not doc)\n  // We want to return the position of the block itself.\n  if ($from.sameParent($to) && $from.parent.type.name === 'block') {\n    // The position of the block is before its content starts?\n    // nodeAt(pos) expects the pos BEFORE the node.\n    // $from.before(depth) returns the pos before the start of the node at depth.\n    // Since blocks are top-level in flat schema, depth is likely 1.\n    // But we use $from.depth to be safe if checking sameParent.\n    positions.push($from.before($from.depth));\n    return positions;\n  }\n\n  // Fallback to nodesBetween if blockRange doesn't give us doc-level blocks\n  state.doc.nodesBetween(state.selection.from, state.selection.to, (node, pos) => {\n    // Only include flat blocks, not the doc or inline content\n    if (node.type.name === 'block' && pos >= 0) {\n      positions.push(pos);\n    }\n    return true; // Continue traversal\n  });\n\n  return positions;\n}\n\n/**\n * Create a transaction to update drag state.\n */\nexport function setDragState(tr: Transaction, updates: Partial<DragState>): Transaction {\n  return tr.setMeta(blockDragPluginKey, updates);\n}\n\n/**\n * Get current drag state from editor state.\n */\nexport function getDragState(state: EditorState): DragState {\n  return blockDragPluginKey.getState(state) ?? initialState;\n}\n\n/**\n * Clear all drag state (call on drop or dragend).\n */\nexport function clearDragState(tr: Transaction): Transaction {\n  return tr.setMeta(blockDragPluginKey, initialState);\n}\n\n/**\n * Find the nearest block boundary position from coordinates.\n * Returns the position and whether to drop above or below.\n */\nexport function findDropTarget(\n  view: EditorView,\n  clientX: number,\n  clientY: number\n): { pos: number; y: number; above: boolean } | null {\n  const coords = { left: clientX, top: clientY };\n  const posInfo = view.posAtCoords(coords);\n  if (!posInfo) return null;\n\n  const $pos = view.state.doc.resolve(posInfo.pos);\n\n  // Find the block-level parent\n  let depth = $pos.depth;\n  while (depth > 0 && !$pos.node(depth).isBlock) {\n    depth--;\n  }\n\n  // If depth is 0, the coordinates are outside block content.\n  // This can happen when dropping at the very edge/bottom of the editor.\n  // In this case, find the nearest block by iterating through all blocks.\n  if (depth === 0) {\n    const doc = view.state.doc;\n    let nearestBlock: { pos: number; top: number; bottom: number } | null = null;\n    let smallestDistance = Infinity;\n\n    doc.forEach((node, pos) => {\n      if (node.type.name === 'block') {\n        const nodeStartCoords = view.coordsAtPos(pos);\n        const nodeEndCoords = view.coordsAtPos(pos + node.nodeSize);\n        const nodeMidY = (nodeStartCoords.top + nodeEndCoords.bottom) / 2;\n        const distance = Math.abs(clientY - nodeMidY);\n\n        if (distance < smallestDistance) {\n          smallestDistance = distance;\n          nearestBlock = { pos, top: nodeStartCoords.top, bottom: nodeEndCoords.bottom };\n        }\n      }\n    });\n\n    if (!nearestBlock) return null;\n\n    // Type assertion needed: TS doesn't track assignments inside callbacks\n    const foundBlock = nearestBlock as { pos: number; top: number; bottom: number };\n\n    // Determine if we should drop above or below this block\n    const nearestMidY = (foundBlock.top + foundBlock.bottom) / 2;\n    const dropAboveNearest = clientY < nearestMidY;\n\n    // For the nearest block, calculate start and end positions\n    const blockNode = doc.nodeAt(foundBlock.pos);\n    if (!blockNode) return null;\n\n    return {\n      pos: dropAboveNearest ? foundBlock.pos : foundBlock.pos + blockNode.nodeSize,\n      y: dropAboveNearest ? foundBlock.top : foundBlock.bottom,\n      above: dropAboveNearest,\n    };\n  }\n\n  const blockStart = $pos.before(depth);\n  const blockEnd = $pos.after(depth);\n  const startCoords = view.coordsAtPos(blockStart);\n  const endCoords = view.coordsAtPos(blockEnd);\n\n  // Determine if we should drop above or below this block\n  const blockMidY = (startCoords.top + endCoords.bottom) / 2;\n  const dropAbove = clientY < blockMidY;\n\n  return {\n    pos: dropAbove ? blockStart : blockEnd,\n    y: dropAbove ? startCoords.top : endCoords.bottom,\n    above: dropAbove,\n  };\n}\n\n/**\n * Execute a block move transaction.\n * Handles moving single or multiple blocks.\n */\nexport function moveBlocks(view: EditorView, sourcePositions: number[], targetPos: number): boolean {\n  if (sourcePositions.length === 0) return false;\n\n  const { state } = view;\n  let tr = state.tr;\n\n  // Sort positions in descending order to handle deletions correctly\n  const sortedPositions = [...sourcePositions].sort((a, b) => b - a);\n\n  // Collect nodes to move\n  const nodesToMove: { node: typeof state.doc.nodeAt extends (p: number) => infer R ? R : never; pos: number }[] = [];\n  for (const pos of sortedPositions) {\n    const node = state.doc.nodeAt(pos);\n    if (node) {\n      nodesToMove.push({ node, pos });\n    }\n  }\n\n  if (nodesToMove.length === 0) return false;\n\n  // Calculate adjusted target position after deletions\n  let adjustedTarget = targetPos;\n  for (const { node, pos } of nodesToMove) {\n    if (node && pos < targetPos) {\n      adjustedTarget -= node.nodeSize;\n    }\n  }\n\n  // Delete nodes from highest position first (so positions remain valid)\n  for (const { node, pos } of nodesToMove) {\n    if (node) {\n      tr = tr.delete(pos, pos + node.nodeSize);\n    }\n  }\n\n  // Insert nodes at target (in original order)\n  const reversedNodes = [...nodesToMove].reverse();\n  let insertPos = adjustedTarget;\n  for (const { node } of reversedNodes) {\n    if (node) {\n      tr = tr.insert(insertPos, node);\n      insertPos += node.nodeSize;\n    }\n  }\n\n  // Clear drag state\n  tr = clearDragState(tr);\n\n  view.dispatch(tr);\n  return true;\n}\n\n// Note: Drop indicator is rendered externally based on dropIndicatorY from state\n\n/**\n * Block drag-and-drop plugin.\n * Tracks drag state and provides decorations for drop indicator.\n */\nexport const blockDragPlugin = new Plugin<DragState>({\n  key: blockDragPluginKey,\n\n  state: {\n    init: () => initialState,\n    apply(tr, state) {\n      const meta = tr.getMeta(blockDragPluginKey);\n      if (meta) {\n        return { ...state, ...meta };\n      }\n      return state;\n    },\n  },\n\n  props: {\n    // Handle drag events at the view level\n    handleDOMEvents: {\n      dragstart(_view, event) {\n        // Check if this drag started from a block handle (has our MIME type)\n        const hasBlockData =\n          event.dataTransfer?.types.includes(BLOCK_DRAG_MIME) || event.dataTransfer?.types.includes(BLOCKS_DRAG_MIME);\n\n        // Return true to prevent ProseMirror's built-in dragstart handler\n        // which calls clearData() and would erase our MIME types\n        return hasBlockData;\n      },\n\n      dragover(view, event) {\n        // Check if we're dragging a block (via dataTransfer MIME types)\n        const hasBlockData =\n          event.dataTransfer?.types.includes(BLOCK_DRAG_MIME) || event.dataTransfer?.types.includes(BLOCKS_DRAG_MIME);\n\n        if (!hasBlockData) {\n          return false;\n        }\n\n        event.preventDefault();\n        if (event.dataTransfer) {\n          event.dataTransfer.dropEffect = 'move';\n        }\n\n        const target = findDropTarget(view, event.clientX, event.clientY);\n        if (target) {\n          view.dispatch(\n            setDragState(view.state.tr, {\n              dropTarget: target.pos,\n              dropIndicatorY: target.y,\n            })\n          );\n        }\n\n        return true;\n      },\n\n      drop(view, event) {\n        const state = getDragState(view.state);\n        const { dropTarget } = state;\n\n        // Clean up dragging class from all blocks\n        view.dom.querySelectorAll('.block-row.dragging').forEach((el) => {\n          el.classList.remove('dragging');\n        });\n\n        // Get source positions from dataTransfer (not plugin state)\n        const multiData = event.dataTransfer?.getData(BLOCKS_DRAG_MIME);\n        const singleData = event.dataTransfer?.getData(BLOCK_DRAG_MIME);\n\n        if (dropTarget === null) {\n          view.dispatch(clearDragState(view.state.tr));\n          return false;\n        }\n\n        // Handle multi-block drop\n        if (multiData) {\n          const selectedPositions = JSON.parse(multiData) as number[];\n          if (selectedPositions.length > 0) {\n            event.preventDefault();\n            return moveBlocks(view, selectedPositions, dropTarget);\n          }\n        }\n\n        // Handle single block drop\n        if (singleData) {\n          const sourcePos = parseInt(singleData, 10);\n          if (!isNaN(sourcePos)) {\n            event.preventDefault();\n            return moveBlocks(view, [sourcePos], dropTarget);\n          }\n        }\n\n        // Clear state if we didn't handle the drop\n        view.dispatch(clearDragState(view.state.tr));\n        return false;\n      },\n\n      dragend(view) {\n        // Clean up dragging class from all blocks\n        view.dom.querySelectorAll('.block-row.dragging').forEach((el) => {\n          el.classList.remove('dragging');\n        });\n        view.dispatch(clearDragState(view.state.tr));\n        return false;\n      },\n\n      dragleave(view, event) {\n        // Only clear if leaving the editor entirely\n        const relatedTarget = event.relatedTarget as Node | null;\n        if (!view.dom.contains(relatedTarget)) {\n          view.dispatch(\n            setDragState(view.state.tr, {\n              dropTarget: null,\n              dropIndicatorY: null,\n            })\n          );\n        }\n        return false;\n      },\n    },\n\n    // Provide decorations for drop indicator\n    decorations(state) {\n      const dragState = this.getState(state);\n      if (!dragState || dragState.dropIndicatorY === null) {\n        return DecorationSet.empty;\n      }\n\n      // Return empty for now - actual indicator rendered via CSS/view\n      // The indicator Y position is available for external rendering\n      return DecorationSet.empty;\n    },\n  },\n});\n\n/**\n * MIME type for block drag data.\n */\nexport const BLOCK_DRAG_MIME = 'application/x-prosemirror-block';\nexport const BLOCKS_DRAG_MIME = 'application/x-prosemirror-blocks';\n","import { Plugin, PluginKey } from 'prosemirror-state';\nimport { Decoration, DecorationSet } from 'prosemirror-view';\nimport { getSelectedBlockPositions } from './blockDragPlugin';\n\n/**\n * Plugin to handle visual states for multi-block selections.\n * Adds 'in-selection' class to selected blocks when more than one block is selected.\n */\nexport const blockSelectionPluginKey = new PluginKey('blockSelection');\n\nexport const blockSelectionPlugin = new Plugin({\n  key: blockSelectionPluginKey,\n  props: {\n    decorations(state) {\n      const positions = getSelectedBlockPositions(state);\n\n      // We only apply special styling when multiple blocks are selected.\n      // Standard ProseMirror selection handles single-block text selection.\n      if (positions.length <= 1) {\n        return DecorationSet.empty;\n      }\n\n      const decorations: Decoration[] = [];\n      const { doc } = state;\n\n      for (const pos of positions) {\n        const node = doc.nodeAt(pos);\n        if (node) {\n          // Add 'in-selection' class to the block node\n          decorations.push(Decoration.node(pos, pos + node.nodeSize, { class: 'in-selection' }));\n        }\n      }\n\n      return DecorationSet.create(doc, decorations);\n    },\n  },\n});\n","import { Plugin } from 'prosemirror-state';\n\n/**\n * Plugin to automatically manage numbering for numbered lists.\n * It computes the sequential number for each 'number' block based on its indentation level\n * and updates the 'number' attribute via a transaction.\n */\nexport const numberCounterPlugin = new Plugin({\n  appendTransaction(transactions, _oldState, newState) {\n    // Only recompute if document changed\n    if (!transactions.some((transaction) => transaction.docChanged)) return null;\n\n    const tr = newState.tr;\n    let needsUpdate = false;\n    const counters = new Map<number, number>(); // indent -> current count\n\n    newState.doc.forEach((node, pos) => {\n      // In flat architecture, blocks are always direct children of doc\n      if (node.type.name !== 'block') return;\n\n      const indent = node.attrs.indent || 0;\n\n      if (node.attrs.type === 'number') {\n        const currentCount = (counters.get(indent) || 0) + 1;\n        counters.set(indent, currentCount);\n\n        // Reset deeper counters\n        for (const [level] of counters) {\n          if (level > indent) counters.delete(level);\n        }\n\n        const oldNumber = node.attrs.number;\n        if (oldNumber !== currentCount) {\n          tr.setNodeMarkup(pos, undefined, { ...node.attrs, number: currentCount });\n          needsUpdate = true;\n        }\n      } else {\n        // Non-numbered block.\n        // Resets counters at and below this indent\n        // This logic ensures that a paragraph at the same level breaks the list\n        for (const [level] of counters) {\n          if (indent <= level) {\n            counters.delete(level);\n          }\n        }\n      }\n    });\n\n    return needsUpdate ? tr : null;\n  },\n});\n","// ProseMirror configuration for the flat block editor.\n// Integrates schema, plugins, and keymaps for the new block-based architecture.\n\nimport { EditorState, type Plugin } from 'prosemirror-state';\nimport { history } from 'prosemirror-history';\nimport { keymap } from 'prosemirror-keymap';\nimport { baseKeymap } from 'prosemirror-commands';\nimport { dropCursor } from 'prosemirror-dropcursor';\nimport { gapCursor } from 'prosemirror-gapcursor';\nimport type { Node as ProseMirrorNode } from 'prosemirror-model';\n\n// Import flat block schema\nimport { schema } from './schema';\n\n// Import new block-specific plugins and rules\nimport { buildBlockInputRules } from './blockInputRules';\nimport { buildBlockKeymap } from './blockKeymap';\nimport { blockDragPlugin } from './blockDragPlugin';\nimport { blockSelectionPlugin } from './blockSelectionPlugin';\nimport { numberCounterPlugin } from './numberCounterPlugin';\n\n// Re-export schema components for use in other files\nexport { schema };\nexport { nodes, marks } from './schema';\n\n/**\n * Create a new EditorState with all necessary plugins for the block editor.\n */\nexport function createEditorState(doc: ProseMirrorNode, extraPlugins?: Plugin[]) {\n  return EditorState.create({\n    doc,\n    schema,\n    plugins: [\n      // Input rules for converting markdown syntax to blocks (e.g. \"- \" -> bullet block)\n      buildBlockInputRules(),\n\n      // Keymap for block operations (Enter, Backspace, Tab, etc.)\n      buildBlockKeymap(),\n\n      // Standard ProseMirror keymap (Ctrl+Z, basic editing)\n      keymap(baseKeymap),\n\n      // Undo/Redo history\n      history(),\n\n      // Drag and drop system\n      blockDragPlugin,\n      blockSelectionPlugin,\n      numberCounterPlugin,\n\n      // UI polish\n      dropCursor({ color: 'var(--c-primary)', width: 2 }),\n      gapCursor(),\n\n      // Extra plugins passed from Editor (e.g. slash menu, upload)\n      ...(extraPlugins || []),\n    ],\n  });\n}\n","import { Schema } from 'prosemirror-model';\nimport { schema as baseSchema } from 'prosemirror-markdown';\nimport { addListNodes } from 'prosemirror-schema-list';\n\n// Extend base schema nodes with list nodes and custom list_item attributes\nlet nodes = addListNodes(baseSchema.spec.nodes, 'paragraph block*', 'block');\n\n// Update list_item to support 'checked' attribute for task lists\nconst listItemNode = nodes.get('list_item');\nif (listItemNode) {\n  nodes = nodes.update('list_item', {\n    ...listItemNode,\n    attrs: {\n      ...listItemNode.attrs,\n      checked: { default: null }, // null = bullet/number, boolean = task\n    },\n  });\n}\n\n// Add underline and strikethrough marks if missing\nlet marks = baseSchema.spec.marks;\n\nif (!marks.get('underline')) {\n  marks = marks.addToEnd('underline', {\n    parseDOM: [{ tag: 'u' }, { style: 'text-decoration=underline' }],\n    toDOM() {\n      return ['u', 0];\n    },\n  });\n}\n\nif (!marks.get('strikethrough')) {\n  marks = marks.addToEnd('strikethrough', {\n    parseDOM: [{ tag: 's' }, { tag: 'del' }, { style: 'text-decoration=line-through' }],\n    toDOM() {\n      return ['s', 0];\n    },\n  });\n}\n\n// Rename 'strike' to 'strikethrough' if it exists differently or ensure naming consistency\n// prosemirror-markdown usually has 'em', 'strong', 'link', 'code'.\n// We ensure 'underline' and 'strikethrough' are present.\n\nexport const nestedSchema = new Schema({\n  nodes,\n  marks,\n});\n","// Markdown-to-flat-blocks parser: converts markdown to ProseMirror document with flat block structure.\n// Strategy: Parse markdown using MarkdownParser (which handles nesting correctly), then flatten the result.\n\nimport MarkdownIt from 'markdown-it';\nimport type Token from 'markdown-it/lib/token.mjs';\nimport { MarkdownParser } from 'prosemirror-markdown';\nimport { nestedSchema } from './nested-schema';\nimport { schema, nodes, type BlockAttrs } from './schema';\nimport type { Node as ProseMirrorNode } from 'prosemirror-model';\n\n// Create markdown-it instance with task list and underline support\nfunction createMarkdownIt(): MarkdownIt {\n  const md = new MarkdownIt();\n\n  // Parse task list checkboxes: [ ] and [x] at start of content\n  md.core.ruler.after('inline', 'task_list', (state) => {\n    const tokens = state.tokens;\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n      if (!token) continue;\n      if (token.type === 'list_item_open') {\n        // Look for inline content in this list item\n        const inlineToken = tokens[i + 2];\n        if (inlineToken && inlineToken.type === 'inline' && inlineToken.children) {\n          const firstChild = inlineToken.children[0];\n          if (firstChild && firstChild.type === 'text' && firstChild.content) {\n            const match = firstChild.content.match(/^\\[([ xX])\\]\\s*/);\n            if (match && match[1]) {\n              // Mark this as a task list item\n              token.attrSet('checked', match[1].toLowerCase() === 'x' ? 'true' : 'false');\n              // Remove checkbox syntax from text\n              firstChild.content = firstChild.content.slice(match[0].length);\n            }\n          }\n        }\n      }\n    }\n    return true;\n  });\n\n  // Parse inline underline: <u>text</u>\n  md.inline.ruler.before('html_inline', 'underline', (state, silent) => {\n    const start = state.pos;\n    const max = state.posMax;\n    const src = state.src;\n\n    if (src.slice(start, start + 3).toLowerCase() !== '<u>') return false;\n\n    const closeTag = '</u>';\n    const closePos = src.toLowerCase().indexOf(closeTag, start + 3);\n    if (closePos === -1 || closePos >= max) return false;\n\n    if (!silent) {\n      const openToken = state.push('underline_open', 'u', 1);\n      openToken.markup = '<u>';\n\n      const content = src.slice(start + 3, closePos);\n      const textToken = state.push('text', '', 0);\n      textToken.content = content;\n\n      const closeToken = state.push('underline_close', 'u', -1);\n      closeToken.markup = '</u>';\n    }\n\n    state.pos = closePos + closeTag.length;\n    return true;\n  });\n\n  // Disable table parsing — the flat block editor has no table node type.\n  // With this disabled, markdown-it leaves pipe-delimited text as paragraphs\n  // instead of emitting table_open/etc. tokens that crash prosemirror-markdown.\n  md.disable('table');\n\n  return md;\n}\n\n/**\n * Convert inline content from nested schema to flat schema.\n * This is necessary because the nested schema creates text nodes with a different schema instance.\n */\nfunction convertInlineContent(content: ProseMirrorNode | null): ProseMirrorNode[] {\n  if (!content) return [];\n\n  const result: ProseMirrorNode[] = [];\n  content.content.forEach((child) => {\n    if (child.isText) {\n      // Convert text node: create new text with same content and converted marks\n      const marks = child.marks\n        .map((m) => {\n          const markType = schema.marks[m.type.name];\n          return markType ? markType.create(m.attrs) : null;\n        })\n        .filter((m): m is NonNullable<typeof m> => m !== null);\n\n      result.push(schema.text(child.text || '', marks));\n    } else if (child.type.name === 'hard_break') {\n      // Convert hard_break\n      const hardBreakType = schema.nodes.hard_break;\n      if (hardBreakType) result.push(hardBreakType.create());\n    } else if (child.type.name === 'image') {\n      // Convert image\n      const imageType = schema.nodes.image;\n      if (imageType) result.push(imageType.create(child.attrs));\n    }\n    // Other inline types can be added here if needed\n  });\n\n  return result;\n}\n\n/**\n * Converts markdown text to a ProseMirror document with flat block structure.\n * Parses using nested schema first, then flattens the structure.\n */\nexport function parseMarkdown(markdown: string): ProseMirrorNode {\n  const md = createMarkdownIt();\n  const parser = new MarkdownParser(nestedSchema, md, {\n    blockquote: { block: 'blockquote' },\n    paragraph: { block: 'paragraph' },\n    list_item: {\n      block: 'list_item',\n      getAttrs: (tok: Token) => {\n        const checked = tok.attrGet('checked');\n        if (checked === 'true') return { checked: true };\n        if (checked === 'false') return { checked: false };\n        return { checked: null };\n      },\n    },\n    bullet_list: { block: 'bullet_list' },\n    ordered_list: { block: 'ordered_list', getAttrs: (tok: Token) => ({ order: +(tok.attrGet('start') || 1) }) },\n    heading: { block: 'heading', getAttrs: (tok: Token) => ({ level: +tok.tag.slice(1) }) },\n    code_block: { block: 'code_block', noCloseToken: true },\n    fence: { block: 'code_block', getAttrs: (tok: Token) => ({ params: tok.info || '' }), noCloseToken: true },\n    hr: { node: 'horizontal_rule' },\n    em: { mark: 'em' },\n    strong: { mark: 'strong' },\n    underline: { mark: 'underline' },\n    s: { mark: 'strikethrough' },\n    link: {\n      mark: 'link',\n      getAttrs: (tok: Token) => ({\n        href: tok.attrGet('href'),\n        title: tok.attrGet('title') || null,\n      }),\n    },\n    code_inline: { mark: 'code' },\n    image: {\n      node: 'image',\n      getAttrs: (tok: Token) => ({\n        src: tok.attrGet('src'),\n        title: tok.attrGet('title') || null,\n        alt: tok.content || null,\n      }),\n    },\n    hardbreak: { node: 'hard_break' },\n  });\n\n  // Parse markdown using nested schema\n  const nestedDoc = parser.parse(markdown);\n\n  // Flatten the nested structure to flat blocks\n  const flatBlocks: ProseMirrorNode[] = [];\n  flattenDocument(nestedDoc, flatBlocks, 0);\n\n  return nodes.doc.create(null, flatBlocks);\n}\n\n/**\n * Recursively flattens nested ProseMirror document into flat blocks.\n * Converts nested lists to flat blocks with indent attributes.\n */\nfunction flattenDocument(node: ProseMirrorNode, blocks: ProseMirrorNode[], baseIndent: number): void {\n  node.forEach((child) => {\n    if (child.type.name === 'bullet_list' || child.type.name === 'ordered_list') {\n      flattenList(child, blocks, baseIndent, child.type.name as 'bullet_list' | 'ordered_list');\n    } else if (child.type.name === 'list_item') {\n      // Should not happen at top level, but handle it\n      flattenListItem(child, blocks, baseIndent, 'bullet');\n    } else if (child.type.name === 'heading') {\n      const content = convertInlineContent(child);\n      const blockNode = nodes.block.create({ type: 'heading', level: child.attrs.level, indent: 0 }, content);\n      blocks.push(blockNode);\n    } else if (child.type.name === 'paragraph') {\n      const content = convertInlineContent(child);\n      const blockNode = nodes.block.create({ type: 'paragraph', indent: 0 }, content);\n      blocks.push(blockNode);\n    } else if (child.type.name === 'blockquote') {\n      // Handle blockquote content (which might be paragraphs or other blocks in standard MD)\n      // For flat blocks, we assume blockquote is a single block type 'quote'\n      // If blockquote contains multiple paragraphs, we might need multiple quote blocks?\n      // For now, let's flatten formatting but keep it as one block if possible, or multiple.\n      // But 'quote' block acts like a paragraph with quote styling.\n\n      // If the blockquote contains paragraphs, we should extract their content.\n      // Simple approach: Iterate children of blockquote.\n      if (child.childCount > 0) {\n        child.forEach((inner) => {\n          if (inner.type.name === 'paragraph') {\n            const content = convertInlineContent(inner);\n            const blockNode = nodes.block.create({ type: 'quote', indent: 0 }, content);\n            blocks.push(blockNode);\n          }\n        });\n      } else {\n        // Fallback for empty or text-only (if schema allowed)\n        const content = convertInlineContent(child);\n        const blockNode = nodes.block.create({ type: 'quote', indent: 0 }, content);\n        blocks.push(blockNode);\n      }\n    } else if (child.type.name === 'code_block') {\n      const content = child.textContent;\n      const language = child.attrs.params || '';\n      const blockNode = nodes.block.create(\n        { type: 'code', language: language || undefined, indent: 0 },\n        schema.text(content)\n      );\n      blocks.push(blockNode);\n    } else if (child.type.name === 'horizontal_rule') {\n      const blockNode = nodes.divider.create({ type: 'divider', indent: 0 });\n      blocks.push(blockNode);\n    }\n  });\n}\n\n/**\n * Flattens a list (bullet or ordered) into flat blocks with proper indentation.\n */\nfunction flattenList(\n  listNode: ProseMirrorNode,\n  blocks: ProseMirrorNode[],\n  baseIndent: number,\n  listType: 'bullet_list' | 'ordered_list'\n): void {\n  let counter = 1;\n  listNode.forEach((item) => {\n    if (item.type.name === 'list_item') {\n      const number = listType === 'ordered_list' ? counter++ : undefined;\n      flattenListItem(item, blocks, baseIndent, listType === 'ordered_list' ? 'number' : 'bullet', number);\n    }\n  });\n}\n\n/**\n * Flattens a single list item and any nested lists within it.\n */\nfunction flattenListItem(\n  itemNode: ProseMirrorNode,\n  blocks: ProseMirrorNode[],\n  baseIndent: number,\n  itemType: 'bullet' | 'number' | 'task',\n  number?: number\n): void {\n  let itemContent: ProseMirrorNode | null = null;\n\n  // Separate item content from nested lists\n  itemNode.forEach((child) => {\n    if (child.type.name === 'paragraph') {\n      itemContent = child;\n    }\n  });\n\n  // Create block for this item\n  const isTask = itemNode.attrs.checked !== null;\n  const blockType = isTask ? 'task' : itemType;\n  const blockAttrs: BlockAttrs = {\n    type: blockType,\n    indent: baseIndent,\n    ...(isTask && { checked: itemNode.attrs.checked }),\n    ...(blockType === 'number' && typeof number === 'number' && { number }),\n  };\n\n  const blockContent = itemContent ? convertInlineContent(itemContent as ProseMirrorNode) : [];\n  const blockNode = nodes.block.create(blockAttrs, blockContent);\n  blocks.push(blockNode);\n\n  // Flatten nested lists\n  itemNode.forEach((child) => {\n    if (child.type.name === 'bullet_list' || child.type.name === 'ordered_list') {\n      flattenList(child, blocks, baseIndent + 1, child.type.name as 'bullet_list' | 'ordered_list');\n    }\n  });\n}\n","// Flat-blocks-to-markdown serializer: reconstructs nested markdown from flat block structure.\n// Groups consecutive list items by indent and type, emits proper list markers and indentation.\n\nimport type { Node as ProseMirrorNode } from 'prosemirror-model';\nimport type { BlockAttrs } from './schema';\n\ninterface ListContext {\n  type: 'bullet' | 'number' | 'task';\n  indent: number;\n}\n\n/**\n * Serializes a flat block document back to markdown.\n * Reconstructs list structure by tracking consecutive blocks of same type/indent.\n */\nexport function serializeToMarkdown(doc: ProseMirrorNode): string {\n  const lines: string[] = [];\n  const listContext: ListContext[] = [];\n  const numberCounters = new Map<number, number>(); // indent → counter\n  let prevType: string | null = null;\n\n  doc.forEach((block) => {\n    const { type, indent, checked, level, language } = block.attrs as BlockAttrs;\n    const content = serializeInline(block);\n\n    // Close list contexts that no longer apply\n    while (listContext.length > 0) {\n      const ctx = listContext[listContext.length - 1];\n      if (ctx === undefined) break;\n      // Close if: indent has decreased, or type has changed at same indent\n      if (ctx.indent > indent || (ctx.indent === indent && ctx.type !== type && isListType(type))) {\n        listContext.pop();\n      } else {\n        break;\n      }\n    }\n\n    // Add blank line before paragraphs that follow non-paragraphs (e.g., after list items)\n    // This ensures proper separation in markdown so they parse correctly\n    const prevWasList = prevType === 'bullet' || prevType === 'number' || prevType === 'task';\n    const currentIsParagraph = type === 'paragraph';\n    if (lines.length > 0 && prevWasList && currentIsParagraph) {\n      lines.push('');\n    }\n    // Also add blank line between paragraphs\n    if (lines.length > 0 && prevType === 'paragraph' && currentIsParagraph) {\n      lines.push('');\n    }\n    // Add blank line before list items that follow paragraphs\n    if (lines.length > 0 && prevType === 'paragraph' && isListType(type)) {\n      lines.push('');\n    }\n\n    // Build line with appropriate prefix\n    const indentStr = '  '.repeat(indent);\n    let prefix = '';\n\n    switch (type) {\n      case 'bullet': {\n        prefix = '- ';\n        if (!listContext.some((ctx) => ctx.indent === indent && ctx.type === 'bullet')) {\n          listContext.push({ type: 'bullet', indent });\n        }\n        break;\n      }\n\n      case 'number': {\n        const counter = (numberCounters.get(indent) || 0) + 1;\n        numberCounters.set(indent, counter);\n        prefix = `${counter}. `;\n        if (!listContext.some((ctx) => ctx.indent === indent && ctx.type === 'number')) {\n          listContext.push({ type: 'number', indent });\n        }\n        break;\n      }\n\n      case 'task': {\n        prefix = checked ? '- [x] ' : '- [ ] ';\n        if (!listContext.some((ctx) => ctx.indent === indent && ctx.type === 'task')) {\n          listContext.push({ type: 'task', indent });\n        }\n        break;\n      }\n\n      case 'heading': {\n        prefix = '#'.repeat(level || 1) + ' ';\n        // Reset number counters at this indent level when leaving list\n        numberCounters.delete(indent);\n        break;\n      }\n\n      case 'quote': {\n        prefix = '> ';\n        numberCounters.delete(indent);\n        break;\n      }\n\n      case 'code': {\n        lines.push('```' + (language || ''));\n        lines.push(content);\n        lines.push('```');\n        prevType = type;\n        return;\n      }\n\n      case 'divider': {\n        lines.push('---');\n        prevType = type;\n        return;\n      }\n\n      default:\n        prefix = '';\n        numberCounters.delete(indent);\n    }\n\n    lines.push(indentStr + prefix + content);\n    prevType = type;\n  });\n\n  return lines.join('\\n');\n}\n\n/**\n * Serializes the inline content of a block (handles marks and nested formatting).\n */\nfunction serializeInline(block: ProseMirrorNode): string {\n  let result = '';\n\n  block.forEach((node) => {\n    if (node.isText) {\n      let text = node.text || '';\n\n      // Apply marks\n      node.marks.forEach((mark) => {\n        if (mark.type.name === 'strong') {\n          text = `**${text}**`;\n        } else if (mark.type.name === 'em') {\n          text = `*${text}*`;\n        } else if (mark.type.name === 'code') {\n          text = `\\`${text}\\``;\n        } else if (mark.type.name === 'strikethrough') {\n          text = `~~${text}~~`;\n        } else if (mark.type.name === 'underline') {\n          text = `<u>${text}</u>`;\n        } else if (mark.type.name === 'link') {\n          const href = mark.attrs.href || '#';\n          const title = mark.attrs.title;\n          text = `[${text}](${href}${title ? ` \"${title}\"` : ''})`;\n        }\n      });\n\n      result += text;\n    } else if (node.type.name === 'image') {\n      const { src, alt, title } = node.attrs;\n      result += `![${alt || ''}](${src || ''}${title ? ` \"${title}\"` : ''})`;\n    } else if (node.type.name === 'hard_break') {\n      result += '\\\\\\n';\n    }\n  });\n\n  return result;\n}\n\n/**\n * Checks if a block type is a list type.\n */\nfunction isListType(type: string): boolean {\n  return type === 'bullet' || type === 'number' || type === 'task';\n}\n","// ProseMirror NodeView implementation for flat blocks with integrated drag handles.\n\nimport { render } from 'solid-js/web';\nimport type { Node as ProseMirrorNode } from 'prosemirror-model';\nimport type { EditorView, NodeView, ViewMutationRecord } from 'prosemirror-view';\nimport { RowHandle } from '../shared/RowHandle';\nimport { getSelectedBlockPositions, BLOCK_DRAG_MIME, BLOCKS_DRAG_MIME } from './blockDragPlugin';\n\n/**\n * Custom event detail for block context menu requests.\n */\nexport interface BlockContextMenuDetail {\n  pos: number;\n  x: number;\n  y: number;\n  selectedCount: number;\n}\n\n/**\n * Custom event dispatched when a block's context menu is requested.\n */\nexport const BLOCK_CONTEXT_MENU_EVENT = 'block-context-menu';\n\n/**\n * NodeView implementation for flat block nodes.\n */\nexport class BlockNodeView implements NodeView {\n  dom: HTMLElement;\n  contentDOM: HTMLElement;\n  private handleDispose: (() => void) | null = null;\n  private handleContainer: HTMLElement;\n\n  constructor(\n    private node: ProseMirrorNode,\n    private view: EditorView,\n    private getPos: () => number | undefined\n  ) {\n    this.dom = document.createElement('div');\n    this.dom.className = 'block-row row-with-handle';\n    this.updateDOMAttributes();\n\n    this.handleContainer = document.createElement('div');\n    this.handleContainer.className = 'block-handle-container';\n    this.handleContainer.contentEditable = 'false';\n    this.dom.appendChild(this.handleContainer);\n\n    this.mountHandle();\n\n    const { contentDOM, wrapperDOM } = this.createContentElement();\n    this.contentDOM = contentDOM;\n    this.dom.appendChild(wrapperDOM || contentDOM);\n  }\n\n  private createContentElement(): { contentDOM: HTMLElement; wrapperDOM?: HTMLElement } {\n    const { type, level, checked, language } = this.node.attrs;\n    let element: HTMLElement;\n\n    switch (type) {\n      case 'heading': {\n        const tag = `h${level || 1}`;\n        element = document.createElement(tag);\n        break;\n      }\n      case 'code': {\n        const pre = document.createElement('pre');\n        const code = document.createElement('code');\n        pre.appendChild(code);\n        if (language) {\n          pre.dataset.language = language;\n        }\n        pre.className = 'block-content';\n        return { contentDOM: code, wrapperDOM: pre };\n      }\n      case 'quote': {\n        element = document.createElement('blockquote');\n        break;\n      }\n      case 'divider': {\n        element = document.createElement('hr');\n        break;\n      }\n      case 'task': {\n        const wrapper = document.createElement('div');\n        wrapper.className = 'block-task block-content';\n        wrapper.dataset.checked = String(checked || false);\n        const cb = document.createElement('span');\n        cb.className = 'block-task-checkbox';\n        cb.contentEditable = 'false';\n        wrapper.appendChild(cb);\n        const content = document.createElement('span');\n        content.className = 'block-task-text';\n        wrapper.appendChild(content);\n        return { contentDOM: content, wrapperDOM: wrapper };\n      }\n      case 'bullet':\n      case 'number': {\n        element = document.createElement('div');\n        element.className = `block-${type}`;\n        if (this.node.attrs.number !== undefined && this.node.attrs.number !== null) {\n          element.dataset.number = String(this.node.attrs.number);\n        }\n        break;\n      }\n      default: {\n        element = document.createElement('p');\n        break;\n      }\n    }\n\n    element.className = `${element.className || ''} block-content`.trim();\n    return { contentDOM: element };\n  }\n\n  private updateDOMAttributes(): void {\n    const { type, indent, level, checked, language } = this.node.attrs;\n\n    this.dom.dataset.type = type;\n    this.dom.dataset.indent = String(indent || 0);\n\n    if (level !== null && level !== undefined) {\n      this.dom.dataset.level = String(level);\n    }\n    if (checked !== null && checked !== undefined) {\n      this.dom.dataset.checked = String(checked);\n    }\n    if (language) {\n      this.dom.dataset.language = language;\n    }\n  }\n\n  private mountHandle(): void {\n    const pos = this.getPos();\n    const rowId = pos !== undefined ? String(pos) : '0';\n\n    this.handleDispose = render(\n      () =>\n        RowHandle({\n          rowId,\n          onDragStart: this.handleDragStart.bind(this),\n          onContextMenu: this.handleContextMenu.bind(this),\n          onClick: this.handleClick.bind(this),\n        }),\n      this.handleContainer\n    );\n  }\n\n  private handleDragStart(e: DragEvent, _rowId: string): void {\n    const pos = this.getPos();\n    if (pos === undefined) return;\n\n    const selectedPositions = getSelectedBlockPositions(this.view.state);\n    const isMultiSelection = selectedPositions.length > 1 && selectedPositions.includes(pos);\n\n    // Set dataTransfer synchronously (required for drag)\n    if (e.dataTransfer) {\n      if (isMultiSelection) {\n        e.dataTransfer.setData(BLOCKS_DRAG_MIME, JSON.stringify(selectedPositions));\n      } else {\n        e.dataTransfer.setData(BLOCK_DRAG_MIME, String(pos));\n      }\n      e.dataTransfer.effectAllowed = 'move';\n\n      // Set drag image\n      const blockRect = this.dom.getBoundingClientRect();\n      const offsetX = e.clientX - blockRect.left;\n      const offsetY = e.clientY - blockRect.top;\n      e.dataTransfer.setDragImage(this.dom, offsetX, offsetY);\n    }\n\n    // NOTE: Don't modify DOM here (e.g., classList.add). Any DOM mutation during\n    // dragstart can trigger ProseMirror's MutationObserver flush, which re-renders\n    // NodeViews and detaches the handle before the event finishes bubbling.\n    // See docs/DRAG_DROP_DEBUG.md for details.\n  }\n\n  private handleContextMenu(e: MouseEvent, _rowId: string): void {\n    const pos = this.getPos();\n    if (pos === undefined) return;\n\n    const selectedPositions = getSelectedBlockPositions(this.view.state);\n    const selectedCount =\n      selectedPositions.length > 1 && selectedPositions.includes(pos) ? selectedPositions.length : 1;\n\n    const detail: BlockContextMenuDetail = {\n      pos,\n      x: e.clientX,\n      y: e.clientY,\n      selectedCount,\n    };\n\n    this.view.dom.dispatchEvent(\n      new CustomEvent(BLOCK_CONTEXT_MENU_EVENT, {\n        detail,\n        bubbles: true,\n      })\n    );\n  }\n\n  private handleClick(e: MouseEvent, rowId: string): void {\n    this.handleContextMenu(e, rowId);\n  }\n\n  update(node: ProseMirrorNode): boolean {\n    if (node.type !== this.node.type) {\n      return false;\n    }\n\n    if (node.attrs.type !== this.node.attrs.type) {\n      return false;\n    }\n\n    // Heading level changes require a new content element (e.g., <h1> → <h2>)\n    if (node.attrs.type === 'heading' && node.attrs.level !== this.node.attrs.level) {\n      return false;\n    }\n\n    this.node = node;\n    this.updateDOMAttributes();\n\n    if (node.attrs.type === 'task') {\n      const taskWrapper = this.dom.querySelector('.block-task');\n      if (taskWrapper) {\n        (taskWrapper as HTMLElement).dataset.checked = String(node.attrs.checked || false);\n      }\n    }\n\n    if (node.attrs.type === 'number') {\n      if (node.attrs.number !== undefined && node.attrs.number !== null) {\n        this.contentDOM.dataset.number = String(node.attrs.number);\n      }\n    }\n\n    return true;\n  }\n\n  selectNode(): void {\n    this.dom.classList.add('selected');\n  }\n\n  deselectNode(): void {\n    this.dom.classList.remove('selected');\n  }\n\n  destroy(): void {\n    this.dom.classList.remove('dragging');\n\n    if (this.handleDispose) {\n      this.handleDispose();\n      this.handleDispose = null;\n    }\n  }\n\n  stopEvent(event: Event): boolean {\n    // Prevent ProseMirror from processing mousedown/pointerdown on the drag handle.\n    // ProseMirror's mousedown handler calls forceDOMFlush → endComposition which can\n    // trigger view.updateState() and re-render NodeViews, detaching the handle DOM\n    // between mousedown and dragstart. This kills the native drag sequence because\n    // the browser aborts drag when the source element is detached.\n    // Drag events must pass through so our blockDragPlugin can handle them.\n    if (this.handleContainer.contains(event.target as Node)) {\n      const t = event.type;\n      return t === 'mousedown' || t === 'mouseup' || t === 'pointerdown' || t === 'pointerup';\n    }\n    return false;\n  }\n\n  ignoreMutation(mutation: ViewMutationRecord): boolean {\n    if (mutation.type !== 'selection' && this.handleContainer.contains(mutation.target as Node)) {\n      return true;\n    }\n    // Ignore class attribute changes on block-row (e.g., 'dragging', 'selected')\n    if (mutation.type === 'attributes' && mutation.target === this.dom) {\n      return true;\n    }\n    // Ignore mutations on the checkbox element and its parent wrapper (data-checked changes)\n    const target = mutation.target as HTMLElement;\n    if (target.classList?.contains('block-task-checkbox') || target.classList?.contains('block-task')) {\n      return true;\n    }\n    return false;\n  }\n}\n\nexport function createBlockNodeView(\n  node: ProseMirrorNode,\n  view: EditorView,\n  getPos: () => number | undefined\n): BlockNodeView {\n  return new BlockNodeView(node, view, getPos);\n}\n","import { type Command } from 'prosemirror-state';\nimport { type BlockType } from './schema';\n\n/**\n * Delete a block at the given position.\n */\nexport function deleteBlock(pos: number): Command {\n  return (state, dispatch) => {\n    const node = state.doc.nodeAt(pos);\n    if (!node) return false;\n\n    if (dispatch) {\n      dispatch(state.tr.delete(pos, pos + node.nodeSize));\n    }\n    return true;\n  };\n}\n\n/**\n * Delete multiple blocks at the given positions.\n * Positions should be in document order.\n */\nexport function deleteBlocks(positions: number[]): Command {\n  return (state, dispatch) => {\n    if (positions.length === 0) return false;\n\n    // Sort in descending order to delete from end first\n    const sortedPositions = [...positions].sort((a, b) => b - a);\n\n    let tr = state.tr;\n    for (const pos of sortedPositions) {\n      const node = tr.doc.nodeAt(pos);\n      if (node) {\n        // Remap position through previous deletions\n        const mappedPos = tr.mapping.map(pos);\n        tr = tr.delete(mappedPos, mappedPos + node.nodeSize);\n      }\n    }\n\n    if (dispatch) {\n      dispatch(tr);\n    }\n    return true;\n  };\n}\n\n/**\n * Duplicate a block at the given position.\n * New block is inserted immediately after.\n */\nexport function duplicateBlock(pos: number): Command {\n  return (state, dispatch) => {\n    const node = state.doc.nodeAt(pos);\n    if (!node) return false;\n\n    if (dispatch) {\n      const insertPos = pos + node.nodeSize;\n      dispatch(state.tr.insert(insertPos, node.copy(node.content)));\n    }\n    return true;\n  };\n}\n\n/**\n * Duplicate multiple blocks at the given positions.\n * New blocks are inserted after the last selected block.\n */\nexport function duplicateBlocks(positions: number[]): Command {\n  return (state, dispatch) => {\n    if (positions.length === 0) return false;\n\n    // Sort positions in ascending order\n    const sortedPositions = [...positions].sort((a, b) => a - b);\n\n    // Find last position and collect nodes\n    const nodes: (typeof state.doc.nodeAt extends (p: number) => infer R ? Exclude<R, null> : never)[] = [];\n    let lastPos = 0;\n    let lastNodeSize = 0;\n\n    for (const pos of sortedPositions) {\n      const node = state.doc.nodeAt(pos);\n      if (node) {\n        nodes.push(node);\n        if (pos > lastPos) {\n          lastPos = pos;\n          lastNodeSize = node.nodeSize;\n        }\n      }\n    }\n\n    if (nodes.length === 0) return false;\n\n    if (dispatch) {\n      let tr = state.tr;\n      let insertPos = lastPos + lastNodeSize;\n\n      for (const node of nodes) {\n        tr = tr.insert(insertPos, node.copy(node.content));\n        insertPos += node.nodeSize;\n      }\n\n      dispatch(tr);\n    }\n    return true;\n  };\n}\n\n/**\n * Convert a block to a different type.\n */\nexport function convertBlock(\n  pos: number,\n  toType: BlockType,\n  attrs?: { level?: number; checked?: boolean; language?: string }\n): Command {\n  return (state, dispatch) => {\n    const node = state.doc.nodeAt(pos);\n    if (!node) return false;\n\n    if (dispatch) {\n      const newAttrs = {\n        ...node.attrs,\n        type: toType,\n        ...attrs,\n      };\n\n      // Clear type-specific attrs when converting\n      if (toType !== 'heading') {\n        newAttrs.level = undefined;\n      }\n      if (toType !== 'task') {\n        newAttrs.checked = undefined;\n      }\n      if (toType !== 'code') {\n        newAttrs.language = undefined;\n      }\n\n      dispatch(state.tr.setNodeMarkup(pos, undefined, newAttrs));\n    }\n    return true;\n  };\n}\n\n/**\n * Convert multiple blocks to a different type.\n */\nexport function convertBlocks(\n  positions: number[],\n  toType: BlockType,\n  attrs?: { level?: number; checked?: boolean; language?: string }\n): Command {\n  return (state, dispatch) => {\n    if (positions.length === 0) return false;\n\n    let tr = state.tr;\n    let modified = false;\n\n    for (const pos of positions) {\n      const node = tr.doc.nodeAt(pos);\n      if (!node) continue;\n\n      const newAttrs = {\n        ...node.attrs,\n        type: toType,\n        ...attrs,\n      };\n\n      // Clear type-specific attrs when converting\n      if (toType !== 'heading') {\n        newAttrs.level = undefined;\n      }\n      if (toType !== 'task') {\n        newAttrs.checked = undefined;\n      }\n      if (toType !== 'code') {\n        newAttrs.language = undefined;\n      }\n\n      tr = tr.setNodeMarkup(pos, undefined, newAttrs);\n      modified = true;\n    }\n\n    if (!modified) return false;\n\n    if (dispatch) {\n      dispatch(tr);\n    }\n    return true;\n  };\n}\n\n/**\n * Increase indentation of a block.\n * Maximum indent level is 8.\n */\nexport function indentBlock(pos: number): Command {\n  return (state, dispatch) => {\n    const node = state.doc.nodeAt(pos);\n    if (!node) return false;\n\n    const currentIndent = (node.attrs.indent as number) || 0;\n    if (currentIndent >= 8) return false; // Max indent\n\n    if (dispatch) {\n      dispatch(\n        state.tr.setNodeMarkup(pos, undefined, {\n          ...node.attrs,\n          indent: currentIndent + 1,\n        })\n      );\n    }\n    return true;\n  };\n}\n\n/**\n * Decrease indentation of a block.\n * Minimum indent level is 0.\n */\nexport function outdentBlock(pos: number): Command {\n  return (state, dispatch) => {\n    const node = state.doc.nodeAt(pos);\n    if (!node) return false;\n\n    const currentIndent = (node.attrs.indent as number) || 0;\n    if (currentIndent <= 0) return false;\n\n    if (dispatch) {\n      dispatch(\n        state.tr.setNodeMarkup(pos, undefined, {\n          ...node.attrs,\n          indent: currentIndent - 1,\n        })\n      );\n    }\n    return true;\n  };\n}\n\n/**\n * Indent multiple blocks.\n */\nexport function indentBlocks(positions: number[]): Command {\n  return (state, dispatch) => {\n    if (positions.length === 0) return false;\n\n    let tr = state.tr;\n    let modified = false;\n\n    for (const pos of positions) {\n      const node = tr.doc.nodeAt(pos);\n      if (!node) continue;\n\n      const currentIndent = (node.attrs.indent as number) || 0;\n      if (currentIndent >= 8) continue;\n\n      tr = tr.setNodeMarkup(pos, undefined, {\n        ...node.attrs,\n        indent: currentIndent + 1,\n      });\n      modified = true;\n    }\n\n    if (!modified) return false;\n\n    if (dispatch) {\n      dispatch(tr);\n    }\n    return true;\n  };\n}\n\n/**\n * Outdent multiple blocks.\n */\nexport function outdentBlocks(positions: number[]): Command {\n  return (state, dispatch) => {\n    if (positions.length === 0) return false;\n\n    let tr = state.tr;\n    let modified = false;\n\n    for (const pos of positions) {\n      const node = tr.doc.nodeAt(pos);\n      if (!node) continue;\n\n      const currentIndent = (node.attrs.indent as number) || 0;\n      if (currentIndent <= 0) continue;\n\n      tr = tr.setNodeMarkup(pos, undefined, {\n        ...node.attrs,\n        indent: currentIndent - 1,\n      });\n      modified = true;\n    }\n\n    if (!modified) return false;\n\n    if (dispatch) {\n      dispatch(tr);\n    }\n    return true;\n  };\n}\n\n/**\n * Toggle task completion state.\n */\nexport function toggleTaskBlock(pos: number): Command {\n  return (state, dispatch) => {\n    const node = state.doc.nodeAt(pos);\n    if (!node || node.attrs.type !== 'task') return false;\n\n    if (dispatch) {\n      dispatch(\n        state.tr.setNodeMarkup(pos, undefined, {\n          ...node.attrs,\n          checked: !node.attrs.checked,\n        })\n      );\n    }\n    return true;\n  };\n}\n","// ProseMirror plugin for detecting \"/\" slash commands and tracking menu state.\n\nimport { Plugin, PluginKey } from 'prosemirror-state';\nimport type { EditorView } from 'prosemirror-view';\n\nexport interface SlashMenuState {\n  active: boolean;\n  query: string;\n  triggerPos: number;\n  position: { top: number; left: number };\n}\n\nexport const slashMenuKey = new PluginKey<SlashMenuState>('slashMenu');\n\nconst initialState: SlashMenuState = {\n  active: false,\n  query: '',\n  triggerPos: 0,\n  position: { top: 0, left: 0 },\n};\n\n/**\n * Creates a ProseMirror plugin that detects \"/\" at line start or after whitespace\n * and triggers the slash command menu.\n */\nexport function createSlashCommandPlugin(onStateChange: (state: SlashMenuState) => void): Plugin<SlashMenuState> {\n  return new Plugin<SlashMenuState>({\n    key: slashMenuKey,\n\n    state: {\n      init() {\n        return { ...initialState };\n      },\n\n      apply(tr, pluginState, _oldState, newState) {\n        // Check if there's a meta flag to close the menu\n        const meta = tr.getMeta(slashMenuKey);\n        if (meta?.close) {\n          if (pluginState.active) {\n            const newPluginState = { ...initialState };\n            // Schedule state change callback\n            setTimeout(() => onStateChange(newPluginState), 0);\n            return newPluginState;\n          }\n          return pluginState;\n        }\n\n        // Only process on document changes or selection changes\n        if (!tr.docChanged && !tr.selectionSet) {\n          return pluginState;\n        }\n\n        const { selection } = newState;\n        const { $from } = selection;\n\n        // Only trigger in empty selections (cursor position)\n        if (!selection.empty) {\n          if (pluginState.active) {\n            const newPluginState = { ...initialState };\n            setTimeout(() => onStateChange(newPluginState), 0);\n            return newPluginState;\n          }\n          return pluginState;\n        }\n\n        // Get text from start of text block to cursor\n        // In flat block schema, blocks are top-level and content is directly inside\n        const textBlockStart = $from.start($from.depth);\n\n        // Ensure we are inside a textblock (not identifying the doc or non-textblock)\n        if (!$from.parent.isTextblock) return pluginState;\n\n        const textToCursor = newState.doc.textBetween(textBlockStart, $from.pos, '', '');\n\n        // Match \"/\" at line start or after whitespace, followed by optional query\n        const slashMatch = textToCursor.match(/(^|\\s)\\/([^\\s]*)$/);\n\n        if (slashMatch) {\n          const query = slashMatch[2] || '';\n          const slashOffset = textToCursor.length - slashMatch[0].length + (slashMatch[1] ? 1 : 0);\n          const triggerPos = textBlockStart + slashOffset;\n\n          const newPluginState: SlashMenuState = {\n            active: true,\n            query,\n            triggerPos,\n            position: pluginState.position, // Preserve position until view.update calculates it\n          };\n\n          // Only notify on query changes if already active (position update comes from view.update)\n          if (pluginState.active && query !== pluginState.query) {\n            setTimeout(() => onStateChange(newPluginState), 0);\n          }\n          // If becoming active, view.update will call onStateChange with correct position\n          return newPluginState;\n        }\n\n        // No match - close menu if it was open\n        if (pluginState.active) {\n          const newPluginState = { ...initialState };\n          setTimeout(() => onStateChange(newPluginState), 0);\n          return newPluginState;\n        }\n\n        return pluginState;\n      },\n    },\n\n    view(_editorView: EditorView) {\n      return {\n        update(view: EditorView) {\n          const pluginState = slashMenuKey.getState(view.state);\n          if (pluginState?.active) {\n            // Calculate menu position based on trigger position\n            try {\n              const coords = view.coordsAtPos(pluginState.triggerPos);\n              const newTop = coords.bottom + 4;\n              const newLeft = coords.left;\n\n              // Only update position if we get valid coordinates (not 0,0)\n              // This can happen during rapid typing or when position is off-screen\n              const hasValidPosition = newTop > 0 || newLeft > 0;\n              const position = hasValidPosition ? { top: newTop, left: newLeft } : pluginState.position; // Keep existing position if new one is invalid\n\n              const newState: SlashMenuState = {\n                ...pluginState,\n                position,\n              };\n              onStateChange(newState);\n            } catch {\n              // Position calculation may fail during rapid updates\n              // Still notify state change to update query filtering\n              onStateChange(pluginState);\n            }\n          }\n        },\n      };\n    },\n\n    props: {\n      handleKeyDown(view, event) {\n        const pluginState = slashMenuKey.getState(view.state);\n        if (!pluginState?.active) return false;\n\n        // Intercept these keys to prevent ProseMirror from handling them\n        // The menu component's document listener handles the actual navigation\n        if (event.key === 'ArrowDown' || event.key === 'ArrowUp' || event.key === 'Enter' || event.key === 'Tab') {\n          return true; // Tell ProseMirror we handled it\n        }\n\n        if (event.key === 'Escape') {\n          closeSlashMenu(view);\n          return true;\n        }\n\n        return false;\n      },\n    },\n  });\n}\n\n/**\n * Close the slash menu programmatically.\n */\nexport function closeSlashMenu(view: EditorView): void {\n  view.dispatch(view.state.tr.setMeta(slashMenuKey, { close: true }));\n}\n","// ProseMirror plugin for drag-and-drop file upload support.\n\nimport { Plugin, PluginKey } from 'prosemirror-state';\nimport type { EditorView } from 'prosemirror-view';\n\nexport interface DropUploadState {\n  isDragging: boolean;\n}\n\nexport const dropUploadKey = new PluginKey<DropUploadState>('dropUpload');\n\nexport interface DropUploadOptions {\n  /** Callback when files are dropped. Returns position in document. */\n  onFileDrop: (files: File[], pos: number) => void;\n}\n\n/**\n * Creates a ProseMirror plugin that handles drag-and-drop file uploads.\n * Sets isDragging state during drag for CSS styling.\n */\nexport function createDropUploadPlugin(options: DropUploadOptions): Plugin<DropUploadState> {\n  return new Plugin<DropUploadState>({\n    key: dropUploadKey,\n\n    state: {\n      init() {\n        return { isDragging: false };\n      },\n      apply(tr, pluginState) {\n        const meta = tr.getMeta(dropUploadKey);\n        if (meta !== undefined) {\n          return { isDragging: meta.isDragging };\n        }\n        return pluginState;\n      },\n    },\n\n    props: {\n      attributes(state): { [name: string]: string } {\n        const pluginState = dropUploadKey.getState(state);\n        if (pluginState?.isDragging) {\n          return { class: 'drop-target-active' };\n        }\n        return {};\n      },\n\n      handleDOMEvents: {\n        dragenter(view: EditorView, event: DragEvent) {\n          // Only handle if dragging files\n          if (!event.dataTransfer?.types.includes('Files')) {\n            return false;\n          }\n          event.preventDefault();\n          setDragging(view, true);\n          return false;\n        },\n\n        dragover(_view: EditorView, event: DragEvent) {\n          // Only handle if dragging files\n          if (!event.dataTransfer?.types.includes('Files')) {\n            return false;\n          }\n          event.preventDefault();\n          // Set drop effect\n          if (event.dataTransfer) {\n            event.dataTransfer.dropEffect = 'copy';\n          }\n          return false;\n        },\n\n        dragleave(view: EditorView, event: DragEvent) {\n          // Check if we're leaving the editor entirely\n          const target = event.relatedTarget as Node | null;\n          const editorDom = view.dom;\n          if (!target || !editorDom.contains(target)) {\n            setDragging(view, false);\n          }\n          return false;\n        },\n\n        drop(view: EditorView, event: DragEvent) {\n          setDragging(view, false);\n\n          const files = event.dataTransfer?.files;\n          if (!files || files.length === 0) {\n            return false;\n          }\n\n          // Check if any files match our supported types\n          const validFiles: File[] = [];\n          for (const file of files) {\n            if (isValidFileType(file.type)) {\n              validFiles.push(file);\n            }\n          }\n\n          if (validFiles.length === 0) {\n            return false;\n          }\n\n          event.preventDefault();\n\n          // Get drop position in document\n          const pos = view.posAtCoords({ left: event.clientX, top: event.clientY });\n          if (!pos) {\n            // Fallback to end of document\n            options.onFileDrop(validFiles, view.state.doc.content.size);\n            return true;\n          }\n\n          options.onFileDrop(validFiles, pos.pos);\n          return true;\n        },\n      },\n    },\n  });\n}\n\nfunction setDragging(view: EditorView, isDragging: boolean): void {\n  const currentState = dropUploadKey.getState(view.state);\n  if (currentState?.isDragging !== isDragging) {\n    view.dispatch(view.state.tr.setMeta(dropUploadKey, { isDragging }));\n  }\n}\n\nfunction isValidFileType(mimeType: string): boolean {\n  return (\n    mimeType === 'image/png' ||\n    mimeType === 'image/jpeg' ||\n    mimeType === 'image/gif' ||\n    mimeType === 'image/webp' ||\n    mimeType === 'image/svg+xml' ||\n    mimeType === 'image/avif' ||\n    mimeType === 'application/pdf'\n  );\n}\n","// ProseMirror plugin for highlighting invalid (broken) internal page links.\n\nimport { Plugin, PluginKey } from 'prosemirror-state';\nimport { Decoration, DecorationSet } from 'prosemirror-view';\nimport type { EditorView } from 'prosemirror-view';\nimport type { Node as ProseMirrorNode } from 'prosemirror-model';\nimport type { NodeTitleMap } from './markdown-utils';\n\n/**\n * Pattern to extract nodeId from internal page link URLs.\n * Matches: /w/@{wsId}+{slug}/@{nodeId}+{slug}\n * Captures: group 1 = wsId, group 2 = nodeId\n * Note: Pattern aligned with parseNodeUrl in urls.ts\n */\nexport const INTERNAL_LINK_URL_PATTERN = /^\\/w\\/@([^/+]+)(?:\\+[^/]*)?\\/@([a-zA-Z0-9_-]+)(?:\\+.*)?$/;\n\nexport interface InvalidLinkPluginState {\n  decorations: DecorationSet;\n  linkedNodeTitles: NodeTitleMap;\n  wsId: string | undefined;\n}\n\nexport const invalidLinkPluginKey = new PluginKey<InvalidLinkPluginState>('invalidLink');\n\n/**\n * Check if a link URL is an internal page link and if the target page exists.\n * Returns true if the link is invalid (broken).\n */\nfunction isInvalidInternalLink(href: string, linkedNodeTitles: NodeTitleMap, wsId: string | undefined): boolean {\n  if (!wsId || !href) return false;\n\n  const match = href.match(INTERNAL_LINK_URL_PATTERN);\n  if (!match) {\n    // Debug: log if pattern doesn't match internal-looking links\n    if (href.startsWith('/w/')) {\n      console.warn('[invalidLink] Pattern did not match:', href);\n    }\n    return false;\n  }\n\n  const linkWsId = match[1];\n  const nodeId = match[2];\n\n  // Only check links within the current workspace\n  if (linkWsId !== wsId) return false;\n\n  // Link is invalid if the node ID is not in the titles map\n  if (!nodeId) return false;\n\n  return !(nodeId in linkedNodeTitles);\n}\n\n/**\n * Build decoration set by scanning the document for invalid links.\n */\nfunction buildDecorations(\n  doc: ProseMirrorNode,\n  linkedNodeTitles: NodeTitleMap,\n  wsId: string | undefined\n): DecorationSet {\n  const decorations: Decoration[] = [];\n\n  doc.descendants((node, pos) => {\n    // Check each mark on text nodes\n    if (node.isText) {\n      const linkMark = node.marks.find((m) => m.type.name === 'link');\n      if (linkMark && linkMark.attrs.href) {\n        const href = linkMark.attrs.href as string;\n        if (isInvalidInternalLink(href, linkedNodeTitles, wsId)) {\n          // Add inline decoration for the entire text node with the link\n          decorations.push(Decoration.inline(pos, pos + node.nodeSize, { class: 'invalid-link' }));\n        }\n      }\n    }\n    return true; // Continue traversing\n  });\n\n  return DecorationSet.create(doc, decorations);\n}\n\n/**\n * Creates a ProseMirror plugin that highlights invalid internal page links.\n * Invalid links are those pointing to pages that don't exist (not in linkedNodeTitles).\n */\nexport function createInvalidLinkPlugin(): Plugin<InvalidLinkPluginState> {\n  return new Plugin<InvalidLinkPluginState>({\n    key: invalidLinkPluginKey,\n\n    state: {\n      init() {\n        return {\n          decorations: DecorationSet.empty,\n          linkedNodeTitles: {},\n          wsId: undefined,\n        };\n      },\n\n      apply(tr, pluginState, _oldState, newState) {\n        // Check for meta to update linkedNodeTitles or wsId\n        const meta = tr.getMeta(invalidLinkPluginKey);\n        if (meta) {\n          const newLinkedNodeTitles = meta.linkedNodeTitles ?? pluginState.linkedNodeTitles;\n          const newWsId = meta.wsId ?? pluginState.wsId;\n\n          // Rebuild decorations with new titles\n          return {\n            decorations: buildDecorations(newState.doc, newLinkedNodeTitles, newWsId),\n            linkedNodeTitles: newLinkedNodeTitles,\n            wsId: newWsId,\n          };\n        }\n\n        // If document changed, rebuild decorations\n        if (tr.docChanged) {\n          return {\n            ...pluginState,\n            decorations: buildDecorations(newState.doc, pluginState.linkedNodeTitles, pluginState.wsId),\n          };\n        }\n\n        // Map decorations through the transaction\n        return {\n          ...pluginState,\n          decorations: pluginState.decorations.map(tr.mapping, tr.doc),\n        };\n      },\n    },\n\n    props: {\n      decorations(state) {\n        return invalidLinkPluginKey.getState(state)?.decorations ?? DecorationSet.empty;\n      },\n    },\n  });\n}\n\n/**\n * Update the plugin's linkedNodeTitles and wsId.\n * Call this when the titles map or workspace changes.\n */\nexport function updateInvalidLinkState(\n  view: EditorView,\n  linkedNodeTitles: NodeTitleMap,\n  wsId: string | undefined\n): void {\n  const tr = view.state.tr.setMeta(invalidLinkPluginKey, { linkedNodeTitles, wsId });\n  view.dispatch(tr);\n}\n","// Hook for uploading assets to a node via multipart form data.\n\nimport { createSignal } from 'solid-js';\nimport type { UploadNodeAssetResponse } from '@sdk/types.gen';\n\n// Client-side limits for quick feedback. Backend enforces these authoritatively.\nconst MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB\n\nconst ALLOWED_MIME_TYPES = new Set([\n  'image/png',\n  'image/jpeg',\n  'image/gif',\n  'image/webp',\n  'image/svg+xml',\n  'image/avif',\n  'application/pdf',\n]);\n\nexport interface UploadResult {\n  name: string;\n  mimeType: string;\n  url: string;\n}\n\nexport interface UseAssetUploadOptions {\n  wsId: string;\n  nodeId: string;\n  getToken: () => string | null;\n}\n\nexport interface UseAssetUploadReturn {\n  uploadFile: (file: File) => Promise<UploadResult | null>;\n  uploading: () => boolean;\n  error: () => string | null;\n}\n\nexport function useAssetUpload(options: UseAssetUploadOptions): UseAssetUploadReturn {\n  const [uploading, setUploading] = createSignal(false);\n  const [error, setError] = createSignal<string | null>(null);\n\n  const uploadFile = async (file: File): Promise<UploadResult | null> => {\n    setError(null);\n\n    // Validate file size\n    if (file.size > MAX_FILE_SIZE) {\n      const err = `File too large: ${file.name} (max 10MB)`;\n      setError(err);\n      console.error(err);\n      return null;\n    }\n\n    // Validate MIME type\n    if (!ALLOWED_MIME_TYPES.has(file.type)) {\n      const err = `Unsupported file type: ${file.type}`;\n      setError(err);\n      console.error(err);\n      return null;\n    }\n\n    const token = options.getToken();\n    if (!token) {\n      const err = 'Not authenticated';\n      setError(err);\n      console.error(err);\n      return null;\n    }\n\n    setUploading(true);\n    try {\n      const formData = new FormData();\n      formData.append('file', file);\n\n      const response = await fetch(`/api/v1/workspaces/${options.wsId}/nodes/${options.nodeId}/assets`, {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${token}`,\n        },\n        body: formData,\n      });\n\n      if (!response.ok) {\n        const errText = await response.text();\n        throw new Error(`Upload failed: ${response.status} ${errText}`);\n      }\n\n      const result: UploadNodeAssetResponse = await response.json();\n      return {\n        name: result.name,\n        mimeType: result.mime_type,\n        url: result.url,\n      };\n    } catch (err) {\n      const errMsg = err instanceof Error ? err.message : String(err);\n      setError(errMsg);\n      console.error('Asset upload failed:', err);\n      return null;\n    } finally {\n      setUploading(false);\n    }\n  };\n\n  return {\n    uploadFile,\n    uploading,\n    error,\n  };\n}\n\n/** Check if a MIME type represents an image */\nexport function isImageMimeType(mimeType: string): boolean {\n  return mimeType.startsWith('image/');\n}\n","// Editor-specific block context menu component.\n// Wraps the shared ContextMenu with editor-specific actions.\n\nimport { createSignal, onMount, onCleanup, Show, type JSX } from 'solid-js';\nimport type { EditorView } from 'prosemirror-view';\nimport { ContextMenu, type ContextMenuAction } from '../shared/ContextMenu';\nimport { useI18n } from '../../i18n';\nimport { deleteBlock, duplicateBlock, convertBlock, indentBlock, outdentBlock } from './blockCommands';\nimport type { BlockType } from './schema';\nimport { BLOCK_CONTEXT_MENU_EVENT, type BlockContextMenuDetail } from './BlockNodeView';\nimport styles from './BlockContextMenu.module.css';\n\nimport ContentCopyIcon from '@material-symbols/svg-400/outlined/content_copy.svg?solid';\nimport FormatIndentIncreaseIcon from '@material-symbols/svg-400/outlined/format_indent_increase.svg?solid';\nimport FormatIndentDecreaseIcon from '@material-symbols/svg-400/outlined/format_indent_decrease.svg?solid';\nimport DeleteIcon from '@material-symbols/svg-400/outlined/delete.svg?solid';\nimport SubjectIcon from '@material-symbols/svg-400/outlined/subject.svg?solid';\nimport TitleIcon from '@material-symbols/svg-400/outlined/title.svg?solid';\nimport FormatListBulletedIcon from '@material-symbols/svg-400/outlined/format_list_bulleted.svg?solid';\nimport FormatListNumberedIcon from '@material-symbols/svg-400/outlined/format_list_numbered.svg?solid';\nimport ChecklistIcon from '@material-symbols/svg-400/outlined/checklist.svg?solid';\nimport FormatQuoteIcon from '@material-symbols/svg-400/outlined/format_quote.svg?solid';\nimport CodeIcon from '@material-symbols/svg-400/outlined/code.svg?solid';\n\nexport interface BlockContextMenuProps {\n  /** The ProseMirror editor view */\n  view: EditorView | undefined;\n  /** CSS class for the container */\n  class?: string;\n}\n\n/**\n * Block context menu component for the editor.\n * Listens for custom events from BlockNodeView and shows appropriate actions.\n */\nexport function BlockContextMenu(props: BlockContextMenuProps) {\n  const { t } = useI18n();\n  const [menuState, setMenuState] = createSignal<{\n    position: { x: number; y: number };\n    blockPos: number;\n    selectedCount: number;\n  } | null>(null);\n\n  // Listen for context menu events from BlockNodeView\n  const handleBlockContextMenu = (e: Event) => {\n    const event = e as CustomEvent<BlockContextMenuDetail>;\n    const { pos, x, y, selectedCount } = event.detail;\n\n    setMenuState({\n      position: { x, y },\n      blockPos: pos,\n      selectedCount,\n    });\n  };\n\n  onMount(() => {\n    const view = props.view;\n    if (view) {\n      view.dom.addEventListener(BLOCK_CONTEXT_MENU_EVENT, handleBlockContextMenu);\n    }\n  });\n\n  onCleanup(() => {\n    const view = props.view;\n    if (view) {\n      view.dom.removeEventListener(BLOCK_CONTEXT_MENU_EVENT, handleBlockContextMenu);\n    }\n  });\n\n  /**\n   * Get context menu actions based on current state.\n   */\n  const getActions = (): ContextMenuAction[] => {\n    const state = menuState();\n    if (!state) return [];\n\n    const { selectedCount } = state;\n    const isMulti = selectedCount > 1;\n\n    const actions: ContextMenuAction[] = [\n      {\n        id: 'duplicate',\n        label: isMulti\n          ? t('editor.duplicateBlocks') || `Duplicate ${selectedCount} blocks`\n          : t('editor.duplicateBlock') || 'Duplicate block',\n        icon: <ContentCopyIcon />,\n        shortcut: '⌘D',\n      },\n    ];\n\n    // Only show convert options for single blocks\n    if (!isMulti) {\n      actions.push(\n        {\n          id: 'indent',\n          label: t('editor.indent') || 'Indent',\n          icon: <FormatIndentIncreaseIcon />,\n          shortcut: 'Tab',\n          separator: true,\n        },\n        {\n          id: 'outdent',\n          label: t('editor.outdent') || 'Outdent',\n          icon: <FormatIndentDecreaseIcon />,\n          shortcut: '⇧Tab',\n        }\n      );\n\n      // Block type conversion options\n      const blockTypes: { id: string; type: BlockType; label: string; icon: JSX.Element }[] = [\n        {\n          id: 'convert-paragraph',\n          type: 'paragraph',\n          label: t('editor.paragraph') || 'Paragraph',\n          icon: <SubjectIcon />,\n        },\n        {\n          id: 'convert-heading1',\n          type: 'heading',\n          label: (t('editor.heading') || 'Heading') + ' 1',\n          icon: <TitleIcon />,\n        },\n        {\n          id: 'convert-heading2',\n          type: 'heading',\n          label: (t('editor.heading') || 'Heading') + ' 2',\n          icon: <TitleIcon />,\n        },\n        {\n          id: 'convert-bullet',\n          type: 'bullet',\n          label: t('editor.bulletList') || 'Bullet list',\n          icon: <FormatListBulletedIcon />,\n        },\n        {\n          id: 'convert-number',\n          type: 'number',\n          label: t('editor.numberedList') || 'Numbered list',\n          icon: <FormatListNumberedIcon />,\n        },\n        { id: 'convert-task', type: 'task', label: t('editor.taskList') || 'Task list', icon: <ChecklistIcon /> },\n        { id: 'convert-quote', type: 'quote', label: t('editor.blockquote') || 'Quote', icon: <FormatQuoteIcon /> },\n        { id: 'convert-code', type: 'code', label: t('editor.codeBlock') || 'Code block', icon: <CodeIcon /> },\n      ];\n\n      blockTypes.forEach((bt, i) => {\n        actions.push({\n          id: bt.id,\n          label: bt.label,\n          icon: bt.icon,\n          separator: i === 0,\n        });\n      });\n    }\n\n    // Delete action always last with separator\n    actions.push({\n      id: 'delete',\n      label: isMulti\n        ? t('editor.deleteBlocks') || `Delete ${selectedCount} blocks`\n        : t('editor.deleteBlock') || 'Delete block',\n      icon: <DeleteIcon />,\n      shortcut: '⌫',\n      danger: true,\n      separator: true,\n    });\n\n    return actions;\n  };\n\n  /**\n   * Handle action selection.\n   * Uses view.state and view.dispatch directly to avoid stale closures and binding issues.\n   */\n  const handleAction = (actionId: string) => {\n    const view = props.view;\n    const state = menuState();\n    if (!view || !state) {\n      setMenuState(null);\n      return;\n    }\n\n    const { blockPos } = state;\n\n    switch (actionId) {\n      case 'delete':\n        deleteBlock(blockPos)(view.state, view.dispatch);\n        break;\n      case 'duplicate':\n        duplicateBlock(blockPos)(view.state, view.dispatch);\n        break;\n      case 'indent':\n        indentBlock(blockPos)(view.state, view.dispatch);\n        break;\n      case 'outdent':\n        outdentBlock(blockPos)(view.state, view.dispatch);\n        break;\n      case 'convert-paragraph':\n        convertBlock(blockPos, 'paragraph')(view.state, view.dispatch);\n        break;\n      case 'convert-heading1':\n        convertBlock(blockPos, 'heading', { level: 1 })(view.state, view.dispatch);\n        break;\n      case 'convert-heading2':\n        convertBlock(blockPos, 'heading', { level: 2 })(view.state, view.dispatch);\n        break;\n      case 'convert-bullet':\n        convertBlock(blockPos, 'bullet')(view.state, view.dispatch);\n        break;\n      case 'convert-number':\n        convertBlock(blockPos, 'number')(view.state, view.dispatch);\n        break;\n      case 'convert-task':\n        convertBlock(blockPos, 'task', { checked: false })(view.state, view.dispatch);\n        break;\n      case 'convert-quote':\n        convertBlock(blockPos, 'quote')(view.state, view.dispatch);\n        break;\n      case 'convert-code':\n        convertBlock(blockPos, 'code')(view.state, view.dispatch);\n        break;\n      default:\n        // Unknown action\n        break;\n    }\n\n    // Close menu after action\n    setMenuState(null);\n  };\n\n  /**\n   * Handle menu close.\n   */\n  const handleClose = () => {\n    setMenuState(null);\n  };\n\n  return (\n    <div class={`${styles.container} ${props.class || ''}`}>\n      <Show when={menuState()}>\n        {(state) => (\n          <ContextMenu\n            position={state().position}\n            actions={getActions()}\n            onAction={handleAction}\n            onClose={handleClose}\n          />\n        )}\n      </Show>\n    </div>\n  );\n}\n","// Editor drop indicator component that renders during block drag-and-drop.\n// Shows a horizontal line at the insertion point between blocks.\n\nimport { createSignal, createEffect, onCleanup, Show } from 'solid-js';\nimport type { EditorView } from 'prosemirror-view';\nimport { getDragState } from './blockDragPlugin';\nimport styles from './EditorDropIndicator.module.css';\n\nexport interface EditorDropIndicatorProps {\n  view: EditorView | undefined;\n}\n\n/**\n * Drop indicator that shows where a dragged block will be inserted.\n * Wraps the EditorView's dispatch to track drag state changes.\n */\nexport function EditorDropIndicator(props: EditorDropIndicatorProps) {\n  const [indicatorY, setIndicatorY] = createSignal<number | null>(null);\n  let containerRef: HTMLDivElement | undefined;\n\n  // Track when we've wrapped dispatch to avoid wrapping multiple times\n  let wrappedView: EditorView | null = null;\n  let originalDispatch: EditorView['dispatch'] | null = null;\n\n  /**\n   * Update indicator position based on drag state.\n   */\n  const updateIndicator = (view: EditorView) => {\n    const dragState = getDragState(view.state);\n\n    if (dragState.dropIndicatorY !== null && containerRef) {\n      // Convert viewport Y to container-relative Y\n      const containerRect = containerRef.getBoundingClientRect();\n      const relativeY = dragState.dropIndicatorY - containerRect.top;\n      setIndicatorY(relativeY);\n    } else {\n      setIndicatorY(null);\n    }\n  };\n\n  // Watch for view changes and wrap dispatch\n  createEffect(() => {\n    const view = props.view;\n\n    // Unwrap previous view if different\n    if (wrappedView && wrappedView !== view && originalDispatch) {\n      wrappedView.dispatch = originalDispatch;\n      wrappedView = null;\n      originalDispatch = null;\n    }\n\n    if (!view || wrappedView === view) return;\n\n    // Store original dispatch\n    const boundDispatch = view.dispatch.bind(view);\n    originalDispatch = boundDispatch;\n    wrappedView = view;\n\n    // Wrap dispatch to intercept state changes\n    view.dispatch = function (tr) {\n      boundDispatch(tr);\n      updateIndicator(view);\n    };\n  });\n\n  onCleanup(() => {\n    // Restore original dispatch on cleanup\n    if (wrappedView && originalDispatch) {\n      wrappedView.dispatch = originalDispatch;\n    }\n  });\n\n  return (\n    <div ref={containerRef} class={styles.container}>\n      <Show when={indicatorY() !== null}>\n        <div class={styles.indicator} style={{ top: `${indicatorY()}px` }} role=\"presentation\" aria-hidden=\"true\" />\n      </Show>\n    </div>\n  );\n}\n","// Slash command registry defining available block types for the editor menu.\n\nimport type { EditorView } from 'prosemirror-view';\nimport { Selection } from 'prosemirror-state';\nimport { nodes } from './prosemirror-config';\nimport type { BlockAttrs } from './schema';\nimport { convertBlock } from './blockCommands';\n\nimport SubjectIcon from '@material-symbols/svg-400/outlined/subject.svg?solid';\nimport TitleIcon from '@material-symbols/svg-400/outlined/title.svg?solid';\nimport FormatListBulletedIcon from '@material-symbols/svg-400/outlined/format_list_bulleted.svg?solid';\nimport FormatListNumberedIcon from '@material-symbols/svg-400/outlined/format_list_numbered.svg?solid';\nimport ChecklistIcon from '@material-symbols/svg-400/outlined/checklist.svg?solid';\nimport FormatQuoteIcon from '@material-symbols/svg-400/outlined/format_quote.svg?solid';\nimport CodeIcon from '@material-symbols/svg-400/outlined/code.svg?solid';\nimport HorizontalRuleIcon from '@material-symbols/svg-400/outlined/horizontal_rule.svg?solid';\nimport DescriptionIcon from '@material-symbols/svg-400/outlined/description.svg?solid';\n\nexport interface SlashCommand {\n  id: string;\n  labelKey: string; // i18n key under slashMenu.*\n  keywords: string[];\n  icon: SolidSVG;\n  execute: (view: EditorView, from: number, to: number) => void;\n  asyncAction?: 'createSubpage'; // Async actions handled by SlashCommandMenu\n}\n\n// Helper to delete the \"/\" trigger text and execute a command\nfunction deleteSlashAndExecute(view: EditorView, from: number, to: number, action: (view: EditorView) => void) {\n  // Delete the slash command text first\n  const tr = view.state.tr.delete(from, to);\n  view.dispatch(tr);\n\n  // Then execute the action (conversion usually)\n  action(view);\n}\n\n// Helper to convert current block (where cursor is) to another type\nfunction convertCurrentBlock(\n  view: EditorView,\n  type: 'paragraph' | 'heading' | 'bullet' | 'number' | 'task' | 'quote' | 'code' | 'divider',\n  attrs: Partial<BlockAttrs> = {}\n) {\n  const { state, dispatch } = view;\n  const { $from } = state.selection;\n\n  // Find the block ancestor\n  for (let d = $from.depth; d > 0; d--) {\n    const node = $from.node(d);\n    if (node.isBlock) {\n      convertBlock($from.before(d), type, attrs)(state, dispatch);\n      return;\n    }\n  }\n}\n\nexport const slashCommands: SlashCommand[] = [\n  {\n    id: 'paragraph',\n    labelKey: 'paragraph',\n    keywords: ['paragraph', 'text', 'plain'],\n    icon: SubjectIcon,\n    execute: (view, from, to) => {\n      deleteSlashAndExecute(view, from, to, (v) => {\n        convertCurrentBlock(v, 'paragraph');\n      });\n    },\n  },\n  {\n    id: 'heading1',\n    labelKey: 'heading1',\n    keywords: ['heading', 'h1', 'title', 'header'],\n    icon: TitleIcon,\n    execute: (view, from, to) => {\n      deleteSlashAndExecute(view, from, to, (v) => {\n        convertCurrentBlock(v, 'heading', { level: 1 });\n      });\n    },\n  },\n  {\n    id: 'heading2',\n    labelKey: 'heading2',\n    keywords: ['heading', 'h2', 'subtitle', 'header'],\n    icon: TitleIcon,\n    execute: (view, from, to) => {\n      deleteSlashAndExecute(view, from, to, (v) => {\n        convertCurrentBlock(v, 'heading', { level: 2 });\n      });\n    },\n  },\n  {\n    id: 'heading3',\n    labelKey: 'heading3',\n    keywords: ['heading', 'h3', 'header'],\n    icon: TitleIcon,\n    execute: (view, from, to) => {\n      deleteSlashAndExecute(view, from, to, (v) => {\n        convertCurrentBlock(v, 'heading', { level: 3 });\n      });\n    },\n  },\n  {\n    id: 'bulletList',\n    labelKey: 'bulletList',\n    keywords: ['bullet', 'list', 'unordered', 'ul'],\n    icon: FormatListBulletedIcon,\n    execute: (view, from, to) => {\n      deleteSlashAndExecute(view, from, to, (v) => {\n        convertCurrentBlock(v, 'bullet');\n      });\n    },\n  },\n  {\n    id: 'orderedList',\n    labelKey: 'orderedList',\n    keywords: ['ordered', 'list', 'numbered', 'ol'],\n    icon: FormatListNumberedIcon,\n    execute: (view, from, to) => {\n      deleteSlashAndExecute(view, from, to, (v) => {\n        convertCurrentBlock(v, 'number');\n      });\n    },\n  },\n  {\n    id: 'taskList',\n    labelKey: 'taskList',\n    keywords: ['task', 'checkbox', 'todo', 'checklist', 'check'],\n    icon: ChecklistIcon,\n    execute: (view, from, to) => {\n      deleteSlashAndExecute(view, from, to, (v) => {\n        convertCurrentBlock(v, 'task', { checked: false });\n      });\n    },\n  },\n  {\n    id: 'blockquote',\n    labelKey: 'blockquote',\n    keywords: ['quote', 'blockquote', 'citation'],\n    icon: FormatQuoteIcon,\n    execute: (view, from, to) => {\n      deleteSlashAndExecute(view, from, to, (v) => {\n        convertCurrentBlock(v, 'quote');\n      });\n    },\n  },\n  {\n    id: 'codeBlock',\n    labelKey: 'codeBlock',\n    keywords: ['code', 'codeblock', 'pre', 'programming'],\n    icon: CodeIcon,\n    execute: (view, from, to) => {\n      deleteSlashAndExecute(view, from, to, (v) => {\n        convertCurrentBlock(v, 'code');\n      });\n    },\n  },\n  {\n    id: 'divider',\n    labelKey: 'divider',\n    keywords: ['divider', 'hr', 'horizontal', 'rule', 'line'],\n    icon: HorizontalRuleIcon,\n    execute: (view) => {\n      convertCurrentBlock(view, 'divider');\n\n      // Insert paragraph after\n      const { state } = view;\n      const { $from } = state.selection;\n      const blockPos = $from.before(1);\n      const blockNode = state.doc.nodeAt(blockPos);\n\n      if (blockNode) {\n        const newPos = blockPos + blockNode.nodeSize;\n        const tr2 = state.tr.insert(newPos, nodes.block.create({ type: 'paragraph', indent: blockNode.attrs.indent }));\n        tr2.setSelection(Selection.near(tr2.doc.resolve(newPos + 1)));\n        view.dispatch(tr2);\n      }\n    },\n  },\n  {\n    id: 'subpage',\n    labelKey: 'subpage',\n    keywords: ['subpage', 'page', 'child', 'nested', 'link'],\n    icon: DescriptionIcon,\n    asyncAction: 'createSubpage',\n    execute: () => {\n      // Handled by SlashCommandMenu via asyncAction\n    },\n  },\n];\n\n/**\n * Check if query matches text with fuzzy character sequence matching.\n * Returns true if all characters of query appear in order in text.\n * E.g., \"bl\" matches \"bullet\", \"blt\" matches \"bullet list\".\n */\nfunction fuzzyMatch(query: string, text: string): boolean {\n  let qi = 0;\n  for (let ti = 0; ti < text.length && qi < query.length; ti++) {\n    if (text[ti] === query[qi]) qi++;\n  }\n  return qi === query.length;\n}\n\n/**\n * Score how well a query matches text.\n * Higher score = better match. Returns 0 if no match.\n * - 100: Exact match\n * - 90: Prefix match\n * - 70: Contains match\n * - 50: Fuzzy match\n */\nfunction matchScore(query: string, text: string): number {\n  const lowerText = text.toLowerCase();\n  if (lowerText === query) return 100;\n  if (lowerText.startsWith(query)) return 90;\n  if (lowerText.includes(query)) return 70;\n  if (fuzzyMatch(query, lowerText)) return 50;\n  return 0;\n}\n\ntype TranslateFn = (key: string) => string | undefined;\n\n/**\n * Filter commands by query string with fuzzy matching.\n * Matches against labelKey, keywords, and display text (via translate function).\n * Results are sorted by match quality.\n */\nexport function filterCommands(query: string, translate?: TranslateFn): SlashCommand[] {\n  if (!query) return slashCommands;\n\n  const lowerQuery = query.toLowerCase();\n\n  // Score each command\n  const scored = slashCommands\n    .map((cmd) => {\n      let bestScore = 0;\n\n      // Match on label key\n      bestScore = Math.max(bestScore, matchScore(lowerQuery, cmd.labelKey));\n\n      // Match on keywords\n      for (const kw of cmd.keywords) {\n        bestScore = Math.max(bestScore, matchScore(lowerQuery, kw));\n      }\n\n      // Match on display text if translate function provided\n      if (translate) {\n        const displayText = translate(`slashMenu.${cmd.labelKey}`);\n        if (displayText) {\n          bestScore = Math.max(bestScore, matchScore(lowerQuery, displayText));\n        }\n      }\n\n      return { cmd, score: bestScore };\n    })\n    .filter((item) => item.score > 0);\n\n  // Sort by score descending\n  scored.sort((a, b) => b.score - a.score);\n\n  return scored.map((item) => item.cmd);\n}\n","// Slash command menu overlay component for selecting block types.\n\nimport { createSignal, createEffect, For, Show, onMount, onCleanup } from 'solid-js';\nimport { useNavigate } from '@solidjs/router';\nimport type { EditorView } from 'prosemirror-view';\nimport { schema, marks } from './prosemirror-config';\nimport { useI18n } from '../../i18n';\nimport { useAuth } from '../../contexts/AuthContext';\nimport { useWorkspace } from '../../contexts/WorkspaceContext';\nimport { useEditor } from '../../contexts/EditorContext';\nimport { useClickOutside } from '../../composables/useClickOutside';\nimport { nodeUrl } from '../../utils/urls';\nimport { filterCommands, type SlashCommand } from './slashCommands';\nimport { closeSlashMenu, slashMenuKey, type SlashMenuState } from './slashCommandPlugin';\nimport styles from './Editor.module.css';\n\ninterface SlashCommandMenuProps {\n  view: EditorView;\n  state: SlashMenuState;\n  nodeId?: string;\n}\n\nexport default function SlashCommandMenu(props: SlashCommandMenuProps) {\n  const { t } = useI18n();\n  const navigate = useNavigate();\n  const { user, wsApi } = useAuth();\n  const { loadNode, fetchNodeChildren } = useWorkspace();\n  const { flushAutoSave } = useEditor();\n  const [selectedIndex, setSelectedIndex] = createSignal(0);\n  const [adjustedPosition, setAdjustedPosition] = createSignal<{ top: number; left: number } | null>(null);\n  let menuRef: HTMLDivElement | undefined;\n\n  // Filter commands based on query (pass translate function for display text matching)\n  const filteredCommands = () => filterCommands(props.state.query, t);\n\n  // Reset selection and position when query changes or menu activates\n  createEffect(() => {\n    // Track query to trigger effect when it changes\n    void props.state.query;\n    void props.state.active;\n    setSelectedIndex(0);\n    setAdjustedPosition(null); // Reset adjusted position when menu state changes\n  });\n\n  // Adjust position after menu is rendered to prevent viewport overflow\n  createEffect(() => {\n    if (!props.state.active || !menuRef) return;\n\n    // Wait for next frame to ensure the menu has been rendered\n    requestAnimationFrame(() => {\n      if (!menuRef) return;\n\n      const menuRect = menuRef.getBoundingClientRect();\n      const viewportHeight = window.innerHeight;\n      const viewportWidth = window.innerWidth;\n\n      let newTop = props.state.position.top;\n      let newLeft = props.state.position.left;\n\n      // If position is (0, 0), it's likely invalid - recalculate from trigger position\n      if (newTop === 0 && newLeft === 0) {\n        try {\n          const coords = props.view.coordsAtPos(props.state.triggerPos);\n          newTop = coords.bottom + 4;\n          newLeft = coords.left;\n        } catch {\n          // If we can't get coords, keep (0, 0) - will be hidden by Show condition below\n        }\n      }\n\n      // If menu extends beyond viewport bottom, position it above the cursor\n      if (newTop + menuRect.height > viewportHeight) {\n        // Get the cursor coordinates to position above\n        const coords = props.view.coordsAtPos(props.state.triggerPos);\n        // Position menu above cursor (subtract menu height and a small gap)\n        newTop = coords.top - menuRect.height - 4;\n\n        // If still overflowing at top, just position at top of viewport with margin\n        if (newTop < 0) {\n          newTop = 8;\n        }\n      }\n\n      // Prevent menu from extending beyond right edge\n      if (newLeft + menuRect.width > viewportWidth) {\n        newLeft = viewportWidth - menuRect.width - 8;\n      }\n\n      // Prevent menu from extending beyond left edge\n      if (newLeft < 0) {\n        newLeft = 8;\n      }\n\n      // Only update if position changed\n      if (newTop !== props.state.position.top || newLeft !== props.state.position.left) {\n        setAdjustedPosition({ top: newTop, left: newLeft });\n      }\n    });\n  });\n\n  // Scroll selected item into view when selection changes\n  createEffect(() => {\n    const index = selectedIndex();\n    if (menuRef) {\n      const selectedItem = menuRef.querySelector(`[data-index=\"${index}\"]`);\n      if (selectedItem) {\n        selectedItem.scrollIntoView({ block: 'nearest' });\n      }\n    }\n  });\n\n  // Handle click outside to close menu\n  useClickOutside(\n    () => menuRef,\n    () => {\n      if (props.state.active) {\n        closeSlashMenu(props.view);\n      }\n    }\n  );\n\n  // Handle keyboard navigation\n  // Note: We check plugin state directly from ProseMirror rather than props\n  // because props.state may be stale in event handlers (SolidJS closure issue)\n  onMount(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      // Check plugin state directly from ProseMirror (authoritative source)\n      const pluginState = slashMenuKey.getState(props.view.state);\n      if (!pluginState?.active) return;\n\n      const commands = filterCommands(pluginState.query, t);\n      if (commands.length === 0) return;\n\n      switch (e.key) {\n        case 'ArrowDown':\n          e.preventDefault();\n          e.stopPropagation();\n          setSelectedIndex((i) => (i + 1) % commands.length);\n          break;\n        case 'ArrowUp':\n          e.preventDefault();\n          e.stopPropagation();\n          setSelectedIndex((i) => (i - 1 + commands.length) % commands.length);\n          break;\n        case 'Enter':\n        case 'Tab':\n          e.preventDefault();\n          e.stopPropagation();\n          executeCommand(commands[selectedIndex()]);\n          break;\n        case 'Escape':\n          e.preventDefault();\n          e.stopPropagation();\n          closeSlashMenu(props.view);\n          break;\n      }\n    };\n\n    document.addEventListener('keydown', handleKeyDown, true);\n    onCleanup(() => {\n      document.removeEventListener('keydown', handleKeyDown, true);\n    });\n  });\n\n  const executeCommand = async (command: SlashCommand | undefined) => {\n    if (!command) return;\n\n    // Get current plugin state from ProseMirror (authoritative source)\n    const pluginState = slashMenuKey.getState(props.view.state);\n    if (!pluginState) return;\n\n    const { triggerPos } = pluginState;\n    const cursorPos = props.view.state.selection.from;\n\n    // Handle async actions\n    if (command.asyncAction === 'createSubpage') {\n      const ws = wsApi();\n      const u = user();\n      const parentId = props.nodeId;\n      if (!ws || !u || !parentId) return;\n\n      // Delete the slash text first\n      const tr = props.view.state.tr.delete(triggerPos, cursorPos);\n      props.view.dispatch(tr);\n\n      try {\n        // Create the subpage\n        const untitledTitle = t('slashMenu.untitledSubpage') || 'Untitled';\n        const newPage = await ws.nodes.page.createPage(parentId, { title: untitledTitle });\n        if (!newPage?.id) return;\n\n        // Build the URL for the new page\n        const wsId = u.workspace_id;\n        const wsName = u.workspace_name;\n        const url = nodeUrl(wsId || '', wsName, newPage.id, untitledTitle);\n\n        // Insert a proper link node with link mark (not raw markdown text)\n        const linkMark = marks.link.create({ href: url, title: null });\n        const linkNode = schema.text(untitledTitle, [linkMark]);\n        const insertTr = props.view.state.tr.insert(props.view.state.selection.from, linkNode);\n        props.view.dispatch(insertTr);\n\n        // Flush auto-save to persist the link immediately\n        flushAutoSave();\n\n        // Refresh parent's children in sidebar to show new subpage\n        // (loadNodes only refreshes root nodes, fetchNodeChildren refreshes the parent's children)\n        await fetchNodeChildren(parentId);\n\n        // Load the new page data and navigate to it\n        await loadNode(newPage.id);\n        navigate(url);\n      } catch (err) {\n        console.error('Failed to create subpage:', err);\n      }\n\n      props.view.focus();\n      return;\n    }\n\n    // Execute the command (it will delete the \"/\" and query text)\n    command.execute(props.view, triggerPos, cursorPos);\n\n    // Focus back on editor\n    props.view.focus();\n  };\n\n  const handleItemClick = (command: SlashCommand) => {\n    executeCommand(command);\n  };\n\n  const handleItemMouseEnter = (index: number) => {\n    setSelectedIndex(index);\n  };\n\n  // Use adjusted position if available, otherwise use original position\n  const menuPosition = () => adjustedPosition() ?? props.state.position;\n\n  // Hide menu visually while position is being calculated (0, 0)\n  const hasValidPosition = () => {\n    const pos = menuPosition();\n    return pos.top !== 0 || pos.left !== 0;\n  };\n\n  return (\n    <Show when={props.state.active}>\n      <div\n        ref={menuRef}\n        class={styles.slashMenu}\n        data-testid=\"slash-command-menu\"\n        style={{\n          top: `${menuPosition().top}px`,\n          left: `${menuPosition().left}px`,\n          visibility: hasValidPosition() ? 'visible' : 'hidden',\n        }}\n      >\n        <Show\n          when={filteredCommands().length > 0}\n          fallback={<div class={styles.slashMenuEmpty}>{t('slashMenu.noResults')}</div>}\n        >\n          <For each={filteredCommands()}>\n            {(command, index) => (\n              <div\n                class={`${styles.slashMenuItem} ${index() === selectedIndex() ? styles.selected : ''}`}\n                data-index={index()}\n                onClick={() => handleItemClick(command)}\n                onMouseEnter={() => handleItemMouseEnter(index())}\n              >\n                <span class={styles.slashMenuIcon}>\n                  <command.icon />\n                </span>\n                <span class={styles.slashMenuLabel}>{t(`slashMenu.${command.labelKey}`)}</span>\n              </div>\n            )}\n          </For>\n        </Show>\n      </div>\n    </Show>\n  );\n}\n","// Floating editor toolbar with formatting buttons (appears on text selection).\n\nimport { Show, createSignal, createEffect, on } from 'solid-js';\nimport type { EditorView } from 'prosemirror-view';\nimport { toggleMark } from 'prosemirror-commands';\nimport { marks } from './prosemirror-config';\nimport { convertBlocks } from './blockCommands';\nimport { getSelectedBlockPositions } from './blockDragPlugin';\nimport type { BlockType, BlockAttrs } from './schema';\nimport styles from './Editor.module.css';\n\nimport FormatBoldIcon from '@material-symbols/svg-400/outlined/format_bold.svg?solid';\nimport FormatItalicIcon from '@material-symbols/svg-400/outlined/format_italic.svg?solid';\nimport FormatUnderlinedIcon from '@material-symbols/svg-400/outlined/format_underlined.svg?solid';\nimport FormatStrikethroughIcon from '@material-symbols/svg-400/outlined/format_strikethrough.svg?solid';\nimport CodeIcon from '@material-symbols/svg-400/outlined/code.svg?solid';\nimport FormatListBulletedIcon from '@material-symbols/svg-400/outlined/format_list_bulleted.svg?solid';\nimport FormatListNumberedIcon from '@material-symbols/svg-400/outlined/format_list_numbered.svg?solid';\nimport ChecklistIcon from '@material-symbols/svg-400/outlined/checklist.svg?solid';\nimport FormatQuoteIcon from '@material-symbols/svg-400/outlined/format_quote.svg?solid';\nimport TerminalIcon from '@material-symbols/svg-400/outlined/terminal.svg?solid';\n\nexport interface FormatState {\n  isBold: boolean;\n  isItalic: boolean;\n  isUnderline: boolean;\n  isStrikethrough: boolean;\n  isCode: boolean;\n  headingLevel: number | null;\n  isBulletList: boolean;\n  isOrderedList: boolean;\n  isTaskList: boolean;\n  isBlockquote: boolean;\n  isCodeBlock: boolean;\n}\n\ninterface EditorToolbarProps {\n  formatState: FormatState;\n  view: EditorView | undefined;\n  position?: { top: number; bottom: number; left: number } | null;\n  editorElement?: HTMLDivElement;\n}\n\nexport default function EditorToolbar(props: EditorToolbarProps) {\n  let toolbarRef: HTMLDivElement | undefined;\n  const [above, setAbove] = createSignal(false);\n  const [clampedLeft, setClampedLeft] = createSignal<number | null>(null);\n\n  // Check if toolbar fits below selection (flip above if not) and clamp horizontally\n  createEffect(\n    on(\n      () => props.position,\n      () => {\n        if (!props.position || !toolbarRef) {\n          setAbove(false);\n          setClampedLeft(null);\n          return;\n        }\n        // Use requestAnimationFrame to measure after render\n        requestAnimationFrame(() => {\n          if (!toolbarRef || !props.position) return;\n          const rect = toolbarRef.getBoundingClientRect();\n\n          // Vertical: flip above if would overflow bottom\n          const wouldOverflow = props.position.bottom + rect.height + 8 > window.innerHeight;\n          setAbove(wouldOverflow);\n\n          // Horizontal: clamp so toolbar stays within viewport\n          // The toolbar is centered (translateX(-50%)), so we need halfWidth for bounds\n          const halfWidth = rect.width / 2;\n\n          // Use the editor element bounds (accounts for sidebar)\n          const editorRect = props.editorElement?.getBoundingClientRect();\n          const editorLeft = editorRect?.left ?? 0;\n          const editorRight = editorRect?.right ?? window.innerWidth;\n\n          const minLeft = editorLeft + halfWidth;\n          const maxLeft = editorRight - halfWidth;\n          const left = props.position.left;\n\n          if (left < minLeft) {\n            setClampedLeft(minLeft);\n          } else if (left > maxLeft) {\n            setClampedLeft(maxLeft);\n          } else {\n            setClampedLeft(null); // No clamping needed\n          }\n        });\n      }\n    )\n  );\n\n  const formatButtonClass = (isActive: boolean) =>\n    isActive ? `${styles.formatButton} ${styles.isActive}` : styles.formatButton;\n\n  const toggleBold = () => {\n    if (!props.view) return;\n    toggleMark(marks.strong)(props.view.state, props.view.dispatch);\n    props.view.focus();\n  };\n\n  const toggleItalic = () => {\n    if (!props.view) return;\n    toggleMark(marks.em)(props.view.state, props.view.dispatch);\n    props.view.focus();\n  };\n\n  const toggleUnderline = () => {\n    if (!props.view) return;\n    toggleMark(marks.underline)(props.view.state, props.view.dispatch);\n    props.view.focus();\n  };\n\n  const toggleStrikethrough = () => {\n    if (!props.view) return;\n    toggleMark(marks.strikethrough)(props.view.state, props.view.dispatch);\n    props.view.focus();\n  };\n\n  const toggleCode = () => {\n    if (!props.view) return;\n    toggleMark(marks.code)(props.view.state, props.view.dispatch);\n    props.view.focus();\n  };\n\n  // Helper to apply block type conversion to all selected blocks\n  const setBlockType = (type: BlockType, attrs: Partial<BlockAttrs> = {}) => {\n    if (!props.view) return;\n    const { state, dispatch } = props.view;\n    const positions = getSelectedBlockPositions(state);\n\n    // If no blocks selected (e.g. empty selection), use current block\n    if (positions.length === 0) {\n      const { $from } = state.selection;\n      // Start depth 1 because depth 0 is doc\n      for (let d = $from.depth; d > 0; d--) {\n        if ($from.node(d).isBlock) {\n          convertBlocks([$from.before(d)], type, attrs)(state, dispatch);\n          break;\n        }\n      }\n    } else {\n      convertBlocks(positions, type, attrs)(state, dispatch);\n    }\n\n    props.view.focus();\n  };\n\n  const setHeading = (level: number) => {\n    if (props.formatState.headingLevel === level) {\n      setBlockType('paragraph');\n    } else {\n      setBlockType('heading', { level });\n    }\n  };\n\n  const toggleBulletList = () => {\n    if (props.formatState.isBulletList) {\n      setBlockType('paragraph');\n    } else {\n      setBlockType('bullet');\n    }\n  };\n\n  const toggleOrderedList = () => {\n    if (props.formatState.isOrderedList) {\n      setBlockType('paragraph');\n    } else {\n      setBlockType('number');\n    }\n  };\n\n  const toggleTaskList = () => {\n    if (props.formatState.isTaskList) {\n      setBlockType('paragraph');\n    } else {\n      setBlockType('task', { checked: false });\n    }\n  };\n\n  const toggleBlockquote = () => {\n    if (props.formatState.isBlockquote) {\n      setBlockType('paragraph');\n    } else {\n      setBlockType('quote');\n    }\n  };\n\n  const toggleCodeBlock = () => {\n    if (props.formatState.isCodeBlock) {\n      setBlockType('paragraph');\n    } else {\n      setBlockType('code');\n    }\n  };\n\n  return (\n    <Show when={props.position}>\n      <div\n        ref={toolbarRef}\n        class={`${styles.floatingToolbar} ${above() ? styles.above : ''}`}\n        data-testid=\"floating-toolbar\"\n        style={{\n          top: `${above() ? props.position?.top : props.position?.bottom}px`,\n          left: `${clampedLeft() ?? props.position?.left ?? 0}px`,\n        }}\n      >\n        <div class={styles.toolbarRow}>\n          <button class={formatButtonClass(props.formatState.isBold)} onClick={toggleBold} title=\"Bold (Ctrl+B)\">\n            <FormatBoldIcon />\n          </button>\n          <button class={formatButtonClass(props.formatState.isItalic)} onClick={toggleItalic} title=\"Italic (Ctrl+I)\">\n            <FormatItalicIcon />\n          </button>\n          <button\n            class={formatButtonClass(props.formatState.isUnderline)}\n            onClick={toggleUnderline}\n            title=\"Underline (Ctrl+U)\"\n          >\n            <FormatUnderlinedIcon />\n          </button>\n          <button\n            class={formatButtonClass(props.formatState.isStrikethrough)}\n            onClick={toggleStrikethrough}\n            title=\"Strikethrough (Ctrl+Shift+X)\"\n          >\n            <FormatStrikethroughIcon />\n          </button>\n          <button class={formatButtonClass(props.formatState.isCode)} onClick={toggleCode} title=\"Code (Ctrl+`)\">\n            <CodeIcon />\n          </button>\n        </div>\n        <div class={styles.toolbarRow}>\n          <button\n            class={formatButtonClass(props.formatState.headingLevel === 1)}\n            onClick={() => setHeading(1)}\n            title=\"Heading 1\"\n          >\n            H1\n          </button>\n          <button\n            class={formatButtonClass(props.formatState.headingLevel === 2)}\n            onClick={() => setHeading(2)}\n            title=\"Heading 2\"\n          >\n            H2\n          </button>\n          <button\n            class={formatButtonClass(props.formatState.headingLevel === 3)}\n            onClick={() => setHeading(3)}\n            title=\"Heading 3\"\n          >\n            H3\n          </button>\n          <span class={styles.separator} />\n          <button\n            class={formatButtonClass(props.formatState.isBulletList)}\n            onClick={toggleBulletList}\n            title=\"Bullet List\"\n          >\n            <FormatListBulletedIcon />\n          </button>\n          <button\n            class={formatButtonClass(props.formatState.isOrderedList)}\n            onClick={toggleOrderedList}\n            title=\"Numbered List\"\n          >\n            <FormatListNumberedIcon />\n          </button>\n          <button class={formatButtonClass(props.formatState.isTaskList)} onClick={toggleTaskList} title=\"Task List\">\n            <ChecklistIcon />\n          </button>\n          <button class={formatButtonClass(props.formatState.isBlockquote)} onClick={toggleBlockquote} title=\"Quote\">\n            <FormatQuoteIcon />\n          </button>\n          <button class={formatButtonClass(props.formatState.isCodeBlock)} onClick={toggleCodeBlock} title=\"Code Block\">\n            <TerminalIcon />\n          </button>\n        </div>\n      </div>\n    </Show>\n  );\n}\n","// WYSIWYG markdown editor component using ProseMirror with flat block architecture.\n\nimport { createSignal, onMount, onCleanup, createEffect, on, createMemo, Show, untrack } from 'solid-js';\nimport { EditorView } from 'prosemirror-view';\nimport type { Node as ProseMirrorNode } from 'prosemirror-model';\nimport { useI18n } from '../../i18n';\nimport {\n  rewriteAssetUrls,\n  reverseRewriteAssetUrls,\n  rewriteInternalLinkTitles,\n  type NodeTitleMap,\n} from './markdown-utils';\nimport { nodes, marks, createEditorState, schema } from './prosemirror-config';\nimport { parseMarkdown } from './markdown-parser';\nimport { serializeToMarkdown } from './markdown-serializer';\nimport { createBlockNodeView } from './BlockNodeView';\nimport { toggleTaskBlock } from './blockCommands';\nimport { createSlashCommandPlugin, type SlashMenuState } from './slashCommandPlugin';\nimport { createDropUploadPlugin } from './dropUploadPlugin';\nimport { createInvalidLinkPlugin, updateInvalidLinkState, INTERNAL_LINK_URL_PATTERN } from './invalidLinkPlugin';\nimport { useAssetUpload, isImageMimeType } from './useAssetUpload';\nimport { BlockContextMenu } from './BlockContextMenu';\nimport { EditorDropIndicator } from './EditorDropIndicator';\nimport SlashCommandMenu from './SlashCommandMenu';\nimport EditorToolbar, { type FormatState } from './EditorToolbar';\nimport type { AssetUrlMap } from '../../contexts/EditorContext';\nimport styles from './Editor.module.css';\n\ninterface EditorProps {\n  content: string;\n  nodeId?: string;\n  assetUrls?: AssetUrlMap;\n  linkedNodeTitles?: NodeTitleMap;\n  onChange: (markdown: string) => void;\n  placeholder?: string;\n  readOnly?: boolean;\n  wsId?: string;\n  getToken?: () => string | null;\n  onAssetUploaded?: () => void;\n  onError?: (error: string) => void;\n  onNavigateToNode?: (nodeId: string) => void;\n}\n\nexport default function Editor(props: EditorProps) {\n  const { t } = useI18n();\n  const [editorMode, setEditorMode] = createSignal<'wysiwyg' | 'markdown'>('wysiwyg');\n  const [markdownContent, setMarkdownContent] = createSignal(untrack(() => props.content));\n  const [view, setView] = createSignal<EditorView | undefined>();\n  const [slashMenuState, setSlashMenuState] = createSignal<SlashMenuState>({\n    active: false,\n    query: '',\n    triggerPos: 0,\n    position: { top: 0, left: 0 },\n  });\n  const [editorRef, setEditorRef] = createSignal<HTMLDivElement>();\n\n  // Create slash command plugin with callback\n  const slashPlugin = createSlashCommandPlugin(setSlashMenuState);\n\n  // Create invalid link decoration plugin\n  const invalidLinkPlugin = createInvalidLinkPlugin();\n\n  // Handle file drop uploads\n  const handleFileDrop = async (files: File[], pos: number) => {\n    const editorView = view();\n    if (!editorView || !props.wsId || !props.nodeId || !props.getToken) return;\n\n    const { uploadFile, error } = useAssetUpload({\n      wsId: props.wsId,\n      nodeId: props.nodeId,\n      getToken: props.getToken,\n    });\n\n    for (const file of files) {\n      const result = await uploadFile(file);\n      if (result) {\n        const isImage = isImageMimeType(result.mimeType);\n        let tr = editorView.state.tr;\n\n        if (isImage) {\n          // Flattened block schemas handle images inside blocks or as separate blocks\n          // For now, simpler to insert as a paragraph block with an image mark or inline image?\n          // Schema does not seem to have 'image' node type in 'nodes' export from schema.ts?\n          // Let's check schema.ts... Phase 1 spec didn't mention 'image' block, only 'inline*' content.\n          // Standard ProseMirror uses inline image nodes.\n          // Wait, schema.ts removed 'image' node from baseSchema?\n          // Actually schema.ts removed bullet_list etc but added block. baseSchema has image.\n          // let's assume image node exists in baseSchema marks or nodes.\n          // schema.ts extends baseSchema.spec.nodes.remove(...).addToEnd(...)\n          // baseSchema has 'image' node.\n\n          // However, we can only insert 'block' or 'divider' at top level.\n          // To insert an image, we should insert a paragraph block containing the image node.\n\n          const imageType = schema.nodes.image;\n          // Check if image node exists in our schema\n          if (imageType) {\n            const imageNode = imageType.create({\n              src: result.url,\n              alt: result.name,\n              title: null,\n            });\n\n            // Create a new paragraph block containing the image\n            const block = nodes.block.create({ type: 'paragraph', indent: 0 }, imageNode);\n            tr = tr.insert(pos, block);\n          }\n        } else {\n          // Insert link\n          const linkType = marks.link;\n          if (linkType) {\n            const linkMark = linkType.create({ href: result.url, title: null });\n            const textNode = schema.text(result.name, [linkMark]);\n            // Create a new paragraph block containing the link\n            const block = nodes.block.create({ type: 'paragraph', indent: 0 }, textNode);\n            tr = tr.insert(pos, block);\n          }\n        }\n\n        editorView.dispatch(tr);\n        props.onAssetUploaded?.();\n      } else {\n        const errMsg = error();\n        if (errMsg) props.onError?.(errMsg);\n      }\n    }\n  };\n\n  const dropPlugin = createDropUploadPlugin({ onFileDrop: handleFileDrop });\n\n  let lastLoadedNodeId: string | undefined = untrack(() => props.nodeId);\n  let lastEmittedContent: string = untrack(() => props.content);\n  let lastLinkedNodeTitles: NodeTitleMap | undefined = untrack(() => props.linkedNodeTitles);\n\n  const [formatState, setFormatState] = createSignal<FormatState>({\n    isBold: false,\n    isItalic: false,\n    isUnderline: false,\n    isStrikethrough: false,\n    isCode: false,\n    headingLevel: null,\n    isBulletList: false,\n    isOrderedList: false,\n    isTaskList: false,\n    isBlockquote: false,\n    isCodeBlock: false,\n  });\n\n  const [toolbarPosition, setToolbarPosition] = createSignal<{\n    top: number;\n    bottom: number;\n    left: number;\n  } | null>(null);\n\n  const localParseMarkdown = (md: string): ProseMirrorNode | null => {\n    let processed = rewriteAssetUrls(md, props.assetUrls || {});\n    if (props.wsId && props.linkedNodeTitles && Object.keys(props.linkedNodeTitles).length > 0) {\n      processed = rewriteInternalLinkTitles(processed, props.linkedNodeTitles, props.wsId);\n    }\n    return parseMarkdown(processed);\n  };\n\n  const localSerializeMarkdown = (doc: ProseMirrorNode): string => {\n    const md = serializeToMarkdown(doc);\n    return reverseRewriteAssetUrls(md, props.assetUrls || {});\n  };\n\n  const updateActiveStates = (editorView: EditorView) => {\n    const { state } = editorView;\n    const { from, $from, to, empty } = state.selection;\n\n    // Toolbar position\n    if (empty || editorMode() === 'markdown') {\n      setToolbarPosition(null);\n    } else {\n      try {\n        const start = editorView.coordsAtPos(from);\n        const end = editorView.coordsAtPos(to);\n        const isSameLine = Math.abs(start.top - end.top) < 20;\n        let left = start.left;\n        if (isSameLine) {\n          left = (start.left + end.right) / 2;\n        } else {\n          left = start.left + 40;\n        }\n        setToolbarPosition({\n          top: start.top,\n          bottom: end.bottom,\n          left,\n        });\n      } catch {\n        setToolbarPosition(null);\n      }\n    }\n\n    // Marks\n    const currentMarks = empty ? state.storedMarks || $from.marks() : [];\n    const isBold = marks.strong.isInSet(currentMarks) !== undefined || state.doc.rangeHasMark(from, to, marks.strong);\n    const isItalic = marks.em.isInSet(currentMarks) !== undefined || state.doc.rangeHasMark(from, to, marks.em);\n    const isUnderline =\n      marks.underline.isInSet(currentMarks) !== undefined || state.doc.rangeHasMark(from, to, marks.underline);\n    const isStrikethrough =\n      marks.strikethrough.isInSet(currentMarks) !== undefined || state.doc.rangeHasMark(from, to, marks.strikethrough);\n    const isCode = marks.code.isInSet(currentMarks) !== undefined || state.doc.rangeHasMark(from, to, marks.code);\n\n    // Block attributes\n    // Find the block node at the cursor/selection\n    let blockNode: ProseMirrorNode | null = null;\n\n    // In flat architecture, blocks are always direct children of doc (depth 1)\n    if ($from.depth >= 1) {\n      blockNode = $from.node(1);\n    }\n\n    // If not found (e.g. at start of doc), try nodeAt\n    if (!blockNode && from === 0) {\n      blockNode = state.doc.nodeAt(0);\n    }\n\n    let isBulletList = false;\n    let isOrderedList = false;\n    let isTaskList = false;\n    let isBlockquote = false;\n    let isCodeBlock = false;\n    let headingLevel: number | null = null;\n\n    // If we have a single block context, use it\n    if (blockNode && blockNode.type.name === 'block') {\n      const type = blockNode.attrs.type;\n      if (type === 'bullet') isBulletList = true;\n      if (type === 'number') isOrderedList = true;\n      if (type === 'task') isTaskList = true;\n      if (type === 'quote') isBlockquote = true;\n      if (type === 'code') isCodeBlock = true;\n      if (type === 'heading') headingLevel = blockNode.attrs.level;\n    }\n\n    setFormatState({\n      isBold,\n      isItalic,\n      isUnderline,\n      isStrikethrough,\n      isCode,\n      headingLevel,\n      isBulletList,\n      isOrderedList,\n      isTaskList,\n      isBlockquote,\n      isCodeBlock,\n    });\n  };\n\n  onMount(() => {\n    const editorEl = editorRef();\n    if (!editorEl) return;\n\n    const doc = localParseMarkdown(props.content);\n    if (!doc) return;\n    const state = createEditorState(doc, [slashPlugin, dropPlugin, invalidLinkPlugin]);\n\n    const editorView = new EditorView(editorEl, {\n      state,\n      editable: () => !props.readOnly,\n      nodeViews: {\n        block: createBlockNodeView,\n      },\n      dispatchTransaction(tr) {\n        const newState = editorView.state.apply(tr);\n        editorView.updateState(newState);\n\n        if (tr.docChanged) {\n          const md = localSerializeMarkdown(newState.doc);\n          setMarkdownContent(md);\n          lastEmittedContent = md;\n          props.onChange(md);\n        }\n\n        updateActiveStates(editorView);\n      },\n      handleDOMEvents: {\n        click: (_view, event) => {\n          const target = event.target as HTMLElement;\n\n          // Handle checkbox toggle: clicks on the real checkbox element\n          if (target.classList.contains('block-task-checkbox')) {\n            event.preventDefault();\n            const taskEl = target.closest('.block-task');\n            if (taskEl) {\n              const pos = editorView.posAtDOM(taskEl, 0);\n              const $pos = editorView.state.doc.resolve(pos);\n              const blockPos = $pos.depth >= 1 ? $pos.before(1) : pos;\n              toggleTaskBlock(blockPos)(editorView.state, editorView.dispatch);\n            }\n            return true;\n          }\n\n          const anchor = target.closest('a');\n          if (!anchor) return false;\n\n          const href = anchor.getAttribute('href');\n          if (!href) return false;\n\n          const match = href.match(INTERNAL_LINK_URL_PATTERN);\n          if (match && match[2] && props.onNavigateToNode) {\n            event.preventDefault();\n            props.onNavigateToNode(match[2]);\n            return true;\n          }\n\n          if (href.startsWith('http://') || href.startsWith('https://')) {\n            event.preventDefault();\n            window.open(href, '_blank', 'noopener,noreferrer');\n            return true;\n          }\n\n          return false;\n        },\n      },\n    });\n\n    const pmEl = editorEl.querySelector('.ProseMirror') as HTMLElement & { pmView?: EditorView };\n    if (pmEl) pmEl.pmView = editorView;\n\n    setView(editorView);\n    updateActiveStates(editorView);\n    updateInvalidLinkState(editorView, props.linkedNodeTitles || {}, props.wsId);\n\n    const handleScroll = () => updateActiveStates(editorView);\n    const scrollContainer = editorEl.closest('[class*=\"prosemirrorEditor\"]') || editorEl;\n    scrollContainer.addEventListener('scroll', handleScroll, { passive: true });\n    window.addEventListener('scroll', handleScroll, { passive: true });\n\n    onCleanup(() => {\n      editorView.destroy();\n      scrollContainer.removeEventListener('scroll', handleScroll);\n      window.removeEventListener('scroll', handleScroll);\n    });\n  });\n\n  createEffect(\n    on(\n      () => [props.nodeId, props.content, props.linkedNodeTitles] as const,\n      ([nodeId, content, linkedNodeTitles]) => {\n        const nodeChanged = nodeId !== lastLoadedNodeId;\n        const contentChangedExternally = content !== lastEmittedContent;\n        const titlesChanged = linkedNodeTitles !== lastLinkedNodeTitles;\n\n        if (nodeChanged || contentChangedExternally || titlesChanged) {\n          lastLoadedNodeId = nodeId;\n          lastEmittedContent = content;\n          lastLinkedNodeTitles = linkedNodeTitles;\n\n          if (nodeChanged || contentChangedExternally) {\n            setMarkdownContent(content);\n            setEditorMode('wysiwyg');\n          }\n\n          const editorView = view();\n          if (editorView) {\n            const doc = localParseMarkdown(content);\n            if (doc) {\n              const state = createEditorState(doc, [slashPlugin, dropPlugin, invalidLinkPlugin]);\n              editorView.updateState(state);\n              updateInvalidLinkState(editorView, linkedNodeTitles || {}, props.wsId);\n            }\n          }\n        }\n      },\n      { defer: true }\n    )\n  );\n\n  const handleMarkdownChange = (value: string) => {\n    setMarkdownContent(value);\n    lastEmittedContent = value;\n    props.onChange(value);\n  };\n\n  const switchToWysiwyg = () => {\n    const editorView = view();\n    if (editorView) {\n      const doc = localParseMarkdown(markdownContent());\n      if (doc) {\n        const state = createEditorState(doc, [slashPlugin, dropPlugin, invalidLinkPlugin]);\n        editorView.updateState(state);\n        updateActiveStates(editorView);\n        updateInvalidLinkState(editorView, props.linkedNodeTitles || {}, props.wsId);\n      }\n    }\n    setEditorMode('wysiwyg');\n  };\n\n  const switchToMarkdown = () => {\n    const editorView = view();\n    if (editorView) {\n      const md = localSerializeMarkdown(editorView.state.doc);\n      setMarkdownContent(md);\n    }\n    setEditorMode('markdown');\n  };\n\n  const toggleMode = () => {\n    if (editorMode() === 'wysiwyg') {\n      switchToMarkdown();\n    } else {\n      switchToWysiwyg();\n    }\n  };\n\n  const handleKeyDown = (e: KeyboardEvent) => {\n    if (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'm') {\n      e.preventDefault();\n      toggleMode();\n    }\n  };\n\n  onMount(() => {\n    document.addEventListener('keydown', handleKeyDown);\n  });\n  onCleanup(() => {\n    document.removeEventListener('keydown', handleKeyDown);\n  });\n\n  const wysiwygClass = createMemo(() =>\n    editorMode() === 'wysiwyg' ? styles.prosemirrorEditor : `${styles.prosemirrorEditor} ${styles.hidden}`\n  );\n\n  const markdownClass = createMemo(() =>\n    editorMode() === 'markdown' ? styles.markdownEditor : `${styles.markdownEditor} ${styles.hidden}`\n  );\n\n  return (\n    <div class={styles.editorContainer}>\n      <EditorToolbar\n        formatState={formatState()}\n        view={view()}\n        position={toolbarPosition()}\n        editorElement={editorRef()}\n      />\n\n      {/* Editor context menu */}\n      <BlockContextMenu view={view()} />\n\n      {/* Drop indicator during drag-and-drop */}\n      <EditorDropIndicator view={view()} />\n\n      <div ref={setEditorRef} class={wysiwygClass()} data-testid=\"wysiwyg-editor\" />\n\n      <textarea\n        class={markdownClass()}\n        value={markdownContent()}\n        onInput={(e) => handleMarkdownChange(e.target.value)}\n        placeholder={props.placeholder || t('editor.contentPlaceholder') || 'Write markdown...'}\n        readOnly={props.readOnly}\n        data-testid=\"markdown-editor\"\n      />\n\n      <div class={styles.modeIndicator}>\n        <button\n          class={editorMode() === 'wysiwyg' ? styles.modeIndicatorActive : undefined}\n          onClick={switchToWysiwyg}\n          title=\"Visual mode (Ctrl+Shift+M)\"\n          data-testid=\"editor-mode-visual\"\n        >\n          Visual\n        </button>\n        <button\n          class={editorMode() === 'markdown' ? styles.modeIndicatorActive : undefined}\n          onClick={switchToMarkdown}\n          title=\"Markdown mode (Ctrl+Shift+M)\"\n          data-testid=\"editor-mode-markdown\"\n        >\n          MD\n        </button>\n      </div>\n\n      <Show when={view()}>{(v) => <SlashCommandMenu view={v()} state={slashMenuState()} nodeId={props.nodeId} />}</Show>\n    </div>\n  );\n}\n"],"names":["isLocalFilename","src","includes","startsWith","ASSET_URL_PATTERN","extractFilenameFromAssetUrl","url","match","decodeURIComponent","reverseRewriteAssetUrls","markdown","assetUrls","reverseMap","filename","Object","entries","result","replace","alt","text","href","blockSpec","attrs","type","default","level","indent","checked","number","language","content","group","parseDOM","tag","getAttrs","dom","dataset","parseInt","classes","Array","from","classList","cls","slice","toDOM","node","baseAttrs","String","class","dividerSpec","schema","Schema","nodes","baseSchema","spec","remove","addToEnd","marks","style","getNodeType","name","nodeType","Error","getMarkType","markType","doc","block","divider","strong","em","code","link","underline","strikethrough","blockTypeRule","pattern","InputRule","state","start","end","$start","resolve","parentOffset","blockPos","before","tr","delete","setNodeMarkup","isListType","getCurrentBlock","$from","selection","nodeAt","pos","indentCommand","dispatch","outdentCommand","enterCommand","empty","size","newAttrs","splitPos","split","backspaceCommand","blockDragPluginKey","PluginKey","initialState","dropTarget","dropIndicatorY","getSelectedBlockPositions","positions","$to","to","range","blockRange","parent","currentPos","i","startIndex","endIndex","child","push","nodeSize","sameParent","depth","nodesBetween","setDragState","updates","setMeta","getDragState","getState","clearDragState","moveBlocks","view","sourcePositions","targetPos","length","sortedPositions","sort","a","b","nodesToMove","adjustedTarget","reversedNodes","reverse","insertPos","insert","blockDragPlugin","Plugin","key","init","apply","meta","getMeta","props","handleDOMEvents","dragstart","_view","event","dataTransfer","types","BLOCK_DRAG_MIME","BLOCKS_DRAG_MIME","dragover","preventDefault","dropEffect","target","clientX","clientY","coords","left","top","posInfo","posAtCoords","$pos","isBlock","nearestBlock","smallestDistance","Infinity","forEach","nodeStartCoords","coordsAtPos","nodeEndCoords","nodeMidY","bottom","distance","Math","abs","foundBlock","nearestMidY","dropAboveNearest","blockNode","y","above","blockStart","blockEnd","after","startCoords","endCoords","blockMidY","dropAbove","findDropTarget","drop","querySelectorAll","el","multiData","getData","singleData","selectedPositions","JSON","parse","sourcePos","isNaN","dragend","dragleave","relatedTarget","contains","decorations","dragState","this","DecorationSet","blockSelectionPluginKey","blockSelectionPlugin","Decoration","create","numberCounterPlugin","appendTransaction","transactions","_oldState","newState","some","transaction","docChanged","needsUpdate","counters","Map","currentCount","get","set","createEditorState","extraPlugins","EditorState","plugins","inputRules","rules","textContent","smartQuotes","ellipsis","emDash","keymap","Tab","Enter","Backspace","baseKeymap","history","dropCursor","color","width","gapCursor","addListNodes","listItemNode","update","nestedSchema","convertInlineContent","isText","map","m","filter","hardBreakType","hard_break","imageType","image","parseMarkdown","md","MarkdownIt","core","ruler","tokens","token","inlineToken","children","firstChild","attrSet","toLowerCase","inline","silent","max","posMax","closeTag","closePos","indexOf","markup","disable","createMarkdownIt","nestedDoc","MarkdownParser","blockquote","paragraph","list_item","tok","attrGet","bullet_list","ordered_list","order","heading","code_block","noCloseToken","fence","params","info","hr","mark","s","title","code_inline","hardbreak","flatBlocks","blocks","baseIndent","flattenList","flattenListItem","childCount","inner","listNode","listType","counter","item","itemNode","itemType","itemContent","isTask","blockType","blockAttrs","blockContent","BLOCK_CONTEXT_MENU_EVENT","BlockNodeView","constructor","getPos","document","createElement","className","updateDOMAttributes","handleContainer","contentEditable","appendChild","mountHandle","contentDOM","wrapperDOM","createContentElement","handleDispose","element","pre","wrapper","cb","trim","rowId","render","RowHandle","onDragStart","handleDragStart","bind","onContextMenu","handleContextMenu","onClick","handleClick","e","_rowId","isMultiSelection","setData","stringify","effectAllowed","blockRect","getBoundingClientRect","offsetX","offsetY","setDragImage","selectedCount","detail","x","dispatchEvent","CustomEvent","bubbles","taskWrapper","querySelector","selectNode","add","deselectNode","destroy","stopEvent","t","ignoreMutation","mutation","createBlockNodeView","convertBlock","toType","convertBlocks","modified","slashMenuKey","active","query","triggerPos","position","closeSlashMenu","close","dropUploadKey","setDragging","isDragging","currentState","isValidFileType","mimeType","INTERNAL_LINK_URL_PATTERN","invalidLinkPluginKey","buildDecorations","linkedNodeTitles","wsId","descendants","linkMark","find","console","warn","linkWsId","nodeId","isInvalidInternalLink","updateInvalidLinkState","ALLOWED_MIME_TYPES","Set","isImageMimeType","BlockContextMenu","useI18n","menuState","setMenuState","createSignal","handleBlockContextMenu","onMount","addEventListener","onCleanup","removeEventListener","handleAction","actionId","copy","duplicateBlock","currentIndent","indentBlock","outdentBlock","handleClose","_el$","_tmpl$","_$insert","_$createComponent","Show","when","ContextMenu","actions","getActions","isMulti","id","label","icon","ContentCopyIcon","shortcut","FormatIndentIncreaseIcon","separator","FormatIndentDecreaseIcon","SubjectIcon","TitleIcon","FormatListBulletedIcon","FormatListNumberedIcon","ChecklistIcon","FormatQuoteIcon","CodeIcon","bt","DeleteIcon","danger","onAction","onClose","_$effect","_$className","styles","EditorDropIndicator","indicatorY","setIndicatorY","containerRef","wrappedView","originalDispatch","createEffect","boundDispatch","updateIndicator","containerRect","relativeY","_tmpl$2","_$use","_el$2","_p$","_v$","_v$2","_$setStyleProperty","undefined","deleteSlashAndExecute","action","convertCurrentBlock","d","slashCommands","labelKey","keywords","execute","v","HorizontalRuleIcon","newPos","tr2","setSelection","Selection","near","DescriptionIcon","asyncAction","matchScore","lowerText","qi","ti","fuzzyMatch","filterCommands","translate","lowerQuery","scored","cmd","bestScore","kw","displayText","score","SlashCommandMenu","navigate","useNavigate","user","wsApi","useAuth","loadNode","fetchNodeChildren","useWorkspace","flushAutoSave","useEditor","selectedIndex","setSelectedIndex","adjustedPosition","setAdjustedPosition","menuRef","filteredCommands","requestAnimationFrame","menuRect","viewportHeight","window","innerHeight","viewportWidth","innerWidth","newTop","newLeft","height","index","selectedItem","scrollIntoView","useClickOutside","handleKeyDown","pluginState","commands","stopPropagation","executeCommand","async","command","cursorPos","ws","u","parentId","untitledTitle","newPage","page","createPage","workspace_id","wsName","workspace_name","nodeUrl","linkNode","insertTr","err","error","focus","menuPosition","fallback","For","each","_el$3","_tmpl$3","_el$4","_el$5","nextSibling","handleItemMouseEnter","$$click","handleItemClick","_v$5","_v$6","_v$7","_v$8","_$setAttribute","o","_v$3","_v$4","hasValidPosition","_$delegateEvents","EditorToolbar","toolbarRef","setAbove","clampedLeft","setClampedLeft","on","rect","wouldOverflow","halfWidth","editorRect","editorElement","minLeft","maxLeft","right","formatButtonClass","isActive","toggleBold","toggleMark","toggleItalic","toggleUnderline","toggleStrikethrough","toggleCode","setBlockType","setHeading","formatState","headingLevel","toggleBulletList","isBulletList","toggleOrderedList","isOrderedList","toggleTaskList","isTaskList","toggleBlockquote","isBlockquote","toggleCodeBlock","isCodeBlock","_el$6","_el$7","_el$8","_el$9","_el$0","_el$1","_el$10","_el$11","_el$12","_el$13","_el$14","_el$15","FormatBoldIcon","FormatItalicIcon","FormatUnderlinedIcon","FormatStrikethroughIcon","TerminalIcon","isBold","isItalic","isUnderline","isStrikethrough","_v$9","isCode","_v$0","_v$1","_v$10","_v$11","_v$12","_v$13","_v$14","_v$15","_v$16","_v$17","n","h","r","l","c","w","f","g","p","Editor","editorMode","setEditorMode","markdownContent","setMarkdownContent","untrack","setView","slashMenuState","setSlashMenuState","editorRef","setEditorRef","slashPlugin","onStateChange","newPluginState","setTimeout","selectionSet","textBlockStart","isTextblock","textToCursor","textBetween","slashMatch","_editorView","invalidLinkPlugin","newLinkedNodeTitles","newWsId","mapping","dropPlugin","options","onFileDrop","files","editorView","getToken","uploadFile","uploading","setUploading","setError","file","has","formData","FormData","append","response","fetch","method","headers","Authorization","body","ok","errText","status","json","mime_type","errMsg","message","useAssetUpload","isImage","imageNode","linkType","textNode","onAssetUploaded","onError","attributes","dragenter","editorDom","validFiles","lastLoadedNodeId","lastEmittedContent","lastLinkedNodeTitles","setFormatState","toolbarPosition","setToolbarPosition","localParseMarkdown","processed","keys","signedUrl","rewriteAssetUrls","nodeTitles","currentWsId","_text","currentTitle","localSerializeMarkdown","lines","listContext","numberCounters","prevType","serializeInline","ctx","pop","prevWasList","currentIsParagraph","indentStr","repeat","prefix","join","serializeToMarkdown","updateActiveStates","isSameLine","currentMarks","storedMarks","isInSet","rangeHasMark","editorEl","EditorView","editable","readOnly","nodeViews","dispatchTransaction","updateState","onChange","click","taskEl","closest","posAtDOM","toggleTaskBlock","anchor","getAttribute","onNavigateToNode","open","pmEl","pmView","handleScroll","scrollContainer","passive","nodeChanged","contentChangedExternally","defer","switchToWysiwyg","switchToMarkdown","ctrlKey","shiftKey","wysiwygClass","createMemo","markdownClass","$$input","handleMarkdownChange","value","placeholder"],"mappings":"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"}