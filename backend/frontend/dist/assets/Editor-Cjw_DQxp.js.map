{"version":3,"file":"Editor-Cjw_DQxp.js","sources":["../../../../frontend/src/components/editor/markdown-utils.ts","../../../../frontend/src/components/editor/schema.ts","../../../../frontend/src/components/editor/blockInputRules.ts","../../../../frontend/src/components/editor/blockKeymap.ts","../../../../frontend/src/components/editor/blockDragPlugin.ts","../../../../frontend/src/components/editor/blockSelectionPlugin.ts","../../../../frontend/src/components/editor/numberCounterPlugin.ts","../../../../frontend/src/components/editor/prosemirror-config.ts","../../../../frontend/src/components/editor/nested-schema.ts","../../../../frontend/src/components/editor/markdown-parser.ts","../../../../frontend/src/components/editor/markdown-serializer.ts","../../../../frontend/src/components/editor/BlockNodeView.ts","../../../../frontend/src/components/editor/slashCommandPlugin.ts","../../../../frontend/src/components/editor/dropUploadPlugin.ts","../../../../frontend/src/components/editor/invalidLinkPlugin.ts","../../../../frontend/src/components/editor/useAssetUpload.ts","../../../../frontend/src/components/editor/blockCommands.ts","../../../../frontend/src/components/editor/BlockContextMenu.tsx","../../../../frontend/src/components/editor/EditorDropIndicator.tsx","../../../../frontend/src/components/editor/slashCommands.ts","../../../../frontend/src/components/editor/SlashCommandMenu.tsx","../../../../frontend/src/components/editor/EditorToolbar.tsx","../../../../frontend/src/components/editor/Editor.tsx"],"sourcesContent":["// Utility functions for asset URL handling in markdown content.\n\nimport type { AssetUrlMap } from '../../contexts/EditorContext';\nimport type { NodeTitleMap } from '../../utils/markdown-utils';\n\n// Re-export NodeTitleMap and extractLinkedNodeIds from utils for backward compatibility\nexport type { NodeTitleMap } from '../../utils/markdown-utils';\nexport { extractLinkedNodeIds } from '../../utils/markdown-utils';\n\n/**\n * Check if a source looks like a local filename (not a URL or absolute path).\n */\nfunction isLocalFilename(src: string): boolean {\n  // Skip if it looks like a URL (contains ://)\n  if (src.includes('://')) return false;\n  // Skip if it starts with / (absolute path)\n  if (src.startsWith('/')) return false;\n  return true;\n}\n\n/**\n * Rewrite asset URLs from local filenames to signed URLs.\n * Transforms: ![alt](filename.png) -> ![alt](/assets/.../filename.png?sig=...)\n * Also transforms: [text](filename.pdf) -> [text](/assets/.../filename.pdf?sig=...)\n * Uses the asset URL map from the backend which contains signed URLs.\n */\nexport function rewriteAssetUrls(markdown: string, assetUrls: AssetUrlMap): string {\n  if (!assetUrls || Object.keys(assetUrls).length === 0) return markdown;\n\n  // Match markdown images with local filenames (not URLs or absolute paths)\n  // Matches: ![...](filename.ext) but not ![...](http...) or ![...](/...)\n  let result = markdown.replace(/!\\[([^\\]]*)\\]\\(([^/)][^)]*)\\)/g, (match, alt, src) => {\n    if (!isLocalFilename(src)) return match;\n    // Look up signed URL from asset map\n    const signedUrl = assetUrls[src];\n    if (signedUrl) {\n      return `![${alt}](${signedUrl})`;\n    }\n    // Keep original if no signed URL found\n    return match;\n  });\n\n  // Match markdown links with local filenames that are in the asset map\n  // This handles linked files like PDFs\n  result = result.replace(/\\[([^\\]]+)\\]\\(([^/)][^)]*)\\)/g, (match, text, href) => {\n    if (!isLocalFilename(href)) return match;\n    // Only convert if this filename is in the asset map\n    const signedUrl = assetUrls[href];\n    if (signedUrl) {\n      return `[${text}](${signedUrl})`;\n    }\n    return match;\n  });\n\n  return result;\n}\n\n// Regex to extract filename from signed asset URLs: /assets/{wsID}/{nodeID}/{filename}?...\nconst ASSET_URL_PATTERN = /^\\/assets\\/[^/]+\\/[^/]+\\/([^?]+)/;\n\n/**\n * Extract filename from a signed asset URL.\n * Returns the filename or null if the URL doesn't match the pattern.\n */\nfunction extractFilenameFromAssetUrl(url: string): string | null {\n  const match = url.match(ASSET_URL_PATTERN);\n  if (match && match[1]) {\n    // Decode URL-encoded characters (e.g., %20 -> space)\n    return decodeURIComponent(match[1]);\n  }\n  return null;\n}\n\n/**\n * Reverse asset URL rewriting from signed URLs to local filenames.\n * Transforms: ![alt](/assets/wsId/nodeId/filename.png?sig=...) -> ![alt](filename.png)\n * Used when saving content back to the backend.\n *\n * Handles both:\n * 1. URLs in the assetUrls map (exact match)\n * 2. Signed asset URLs matching /assets/{wsID}/{nodeID}/{filename}?... pattern\n */\nexport function reverseRewriteAssetUrls(markdown: string, assetUrls: AssetUrlMap): string {\n  // Build reverse map: signed URL -> filename\n  const reverseMap: Record<string, string> = {};\n  for (const [filename, url] of Object.entries(assetUrls || {})) {\n    reverseMap[url] = filename;\n  }\n\n  // Helper to convert a URL to filename\n  const urlToFilename = (url: string): string | null => {\n    // First try exact match in reverse map\n    if (reverseMap[url]) {\n      return reverseMap[url];\n    }\n    // Then try extracting from signed asset URL pattern\n    return extractFilenameFromAssetUrl(url);\n  };\n\n  // Match markdown images: ![alt](url)\n  let result = markdown.replace(/!\\[([^\\]]*)\\]\\(([^)]+)\\)/g, (match, alt, src) => {\n    const filename = urlToFilename(src);\n    if (filename) {\n      return `![${alt}](${filename})`;\n    }\n    return match;\n  });\n\n  // Match markdown links: [text](url)\n  // Only convert links that point to signed asset URLs\n  result = result.replace(/\\[([^\\]]+)\\]\\(([^)]+)\\)/g, (match, text, href) => {\n    // Only process asset URLs (not regular links)\n    const filename = extractFilenameFromAssetUrl(href);\n    if (filename) {\n      return `[${text}](${filename})`;\n    }\n    return match;\n  });\n\n  return result;\n}\n\n// --- Internal Page Link Utilities ---\n\n/**\n * Rewrite internal page link display text to show current titles.\n * Transforms: [OldTitle](/w/{wsId}+{slug}/{nodeId}+{slug}) -> [CurrentTitle](/w/{wsId}+{slug}/{nodeId}+{slug})\n *\n * The URL is preserved exactly as-is; only the display text is updated.\n * Links to nodes not in the title map are left unchanged.\n *\n * @param markdown The markdown content to transform\n * @param nodeTitles Map of node ID to current title\n * @param currentWsId The current workspace ID to filter links by\n * @returns Markdown with link display text updated to current titles\n */\nexport function rewriteInternalLinkTitles(markdown: string, nodeTitles: NodeTitleMap, currentWsId: string): string {\n  if (!markdown || !currentWsId || !nodeTitles || Object.keys(nodeTitles).length === 0) {\n    return markdown;\n  }\n\n  // Pattern captures: full match, text, wsId, nodeId (and anything after)\n  return markdown.replace(\n    /\\[([^\\]]*)\\]\\((\\/w\\/([^/+]+)(?:\\+[^/]*)?\\/([A-Za-z0-9]+)(?:\\+[^)]*)?)\\)/g,\n    (match, _text, url, wsId, nodeId) => {\n      // Only rewrite links to the current workspace\n      if (wsId !== currentWsId) {\n        return match;\n      }\n      // Look up the current title\n      const currentTitle = nodeTitles[nodeId];\n      if (currentTitle !== undefined) {\n        return `[${currentTitle}](${url})`;\n      }\n      // Keep original if no title found (page might be deleted)\n      return match;\n    }\n  );\n}\n\n/**\n * Reverse of rewriteInternalLinkTitles - used when saving content.\n * Since we don't modify the markdown when saving (titles stay in storage),\n * this function is provided for consistency but currently just returns the input.\n *\n * The design approach is:\n * - Storage: markdown keeps whatever title was there when the link was created\n * - Display: titles are resolved at render time from the title map\n * - Save: original markdown is preserved (no rewriting in storage)\n */\nexport function reverseInternalLinkTitles(markdown: string): string {\n  // Currently a no-op: we preserve original markdown on save\n  return markdown;\n}\n","// Flat block schema for Notion-style editor with uniform drag-drop.\n// Every visible line is a top-level block node with attributes for type, indentation, and styling.\n\nimport { Schema, type NodeSpec, type DOMOutputSpec } from 'prosemirror-model';\nimport { schema as baseSchema } from 'prosemirror-markdown';\n\n// Block types: correspond to different content kinds\nexport type BlockType = 'paragraph' | 'heading' | 'bullet' | 'number' | 'task' | 'quote' | 'code' | 'divider';\n\n// Block attributes: describe a single block's type, nesting level, and metadata\nexport interface BlockAttrs {\n  type: BlockType;\n  level?: number; // heading level (1-6)\n  indent: number; // nesting depth (0+), enables drag-and-drop without changing type\n  checked?: boolean; // task completion state (for type=task)\n  number?: number; // sequential number (for type=number)\n  language?: string; // code block language (for type=code)\n}\n\n// Block node specification: all content lines are unified under this node\nconst blockSpec: NodeSpec = {\n  attrs: {\n    type: { default: 'paragraph' },\n    level: { default: null },\n    indent: { default: 0 },\n    checked: { default: null },\n    number: { default: null },\n    language: { default: null },\n  },\n  content: 'inline*',\n  group: 'block',\n  parseDOM: [\n    // Headings: h1-h6\n    { tag: 'h1', attrs: { type: 'heading', level: 1 } },\n    { tag: 'h2', attrs: { type: 'heading', level: 2 } },\n    { tag: 'h3', attrs: { type: 'heading', level: 3 } },\n    { tag: 'h4', attrs: { type: 'heading', level: 4 } },\n    { tag: 'h5', attrs: { type: 'heading', level: 5 } },\n    { tag: 'h6', attrs: { type: 'heading', level: 6 } },\n\n    // Task list items: li.task-list-item with optional data-checked\n    {\n      tag: 'li.task-list-item',\n      getAttrs(dom: HTMLElement) {\n        return {\n          type: 'task',\n          checked: dom.dataset.checked === 'true',\n          indent: parseInt(dom.dataset.indent || '0', 10),\n        };\n      },\n    },\n\n    // Bullet and numbered list items: plain li, context determines bullet vs number\n    // For now, default to bullet; number type is handled via attributes from HTML5 data\n    {\n      tag: 'li',\n      getAttrs(dom: HTMLElement) {\n        return {\n          type: dom.dataset.type === 'number' ? 'number' : 'bullet',\n          indent: parseInt(dom.dataset.indent || '0', 10),\n        };\n      },\n    },\n\n    // Blockquote: blockquote > p or just blockquote\n    {\n      tag: 'blockquote',\n      attrs: { type: 'quote' },\n    },\n\n    // Code block: pre with optional data-language\n    {\n      tag: 'pre',\n      getAttrs(dom: HTMLElement) {\n        // Try to extract language from class names or data attribute\n        // Import extractCodeLanguage from dom-parser\n        let language: string | null = dom.dataset.language || null;\n\n        if (!language) {\n          const classes = Array.from(dom.classList);\n          for (const cls of classes) {\n            if (cls.startsWith('language-')) {\n              language = cls.slice(9);\n              break;\n            }\n            if (cls.startsWith('lang-')) {\n              language = cls.slice(5);\n              break;\n            }\n            if (cls.startsWith('hljs-')) {\n              language = cls.slice(5);\n              break;\n            }\n          }\n        }\n\n        return {\n          type: 'code',\n          language,\n        };\n      },\n    },\n\n    // Horizontal rule: hr\n    {\n      tag: 'hr',\n      attrs: { type: 'divider' },\n    },\n\n    // Paragraph: default, catch-all\n    { tag: 'p', attrs: { type: 'paragraph' } },\n  ],\n  toDOM(node): DOMOutputSpec {\n    const { type, level, indent, checked, language } = node.attrs;\n    const baseAttrs: Record<string, string> = {\n      'data-type': type,\n      'data-indent': String(indent),\n    };\n\n    switch (type) {\n      case 'heading': {\n        const tag = `h${level || 1}`;\n        return [tag, baseAttrs, 0];\n      }\n\n      case 'bullet':\n      case 'number': {\n        const attrs = { ...baseAttrs, class: `block-${type}` };\n        return ['div', attrs, 0];\n      }\n\n      case 'task': {\n        const attrs = {\n          ...baseAttrs,\n          class: 'block-task',\n          'data-checked': String(checked || false),\n        };\n        return ['div', attrs, 0];\n      }\n\n      case 'quote': {\n        return ['blockquote', baseAttrs, 0];\n      }\n\n      case 'code': {\n        const attrs = {\n          ...baseAttrs,\n          'data-language': language || '',\n        };\n        return ['pre', attrs, ['code', 0]];\n      }\n\n      case 'divider': {\n        return ['hr', baseAttrs];\n      }\n\n      default:\n        return ['p', baseAttrs, 0];\n    }\n  },\n};\n\n// Divider node: empty block for horizontal rules\nconst dividerSpec: NodeSpec = {\n  attrs: {\n    type: { default: 'divider' },\n    indent: { default: 0 },\n  },\n  content: 'inline*',\n  group: 'block',\n  parseDOM: [{ tag: 'hr', attrs: { type: 'divider' } }],\n  toDOM(node): DOMOutputSpec {\n    return ['hr', { 'data-type': 'divider', 'data-indent': String(node.attrs.indent) }];\n  },\n};\n\n// Create flat block schema: replace nested list/heading/paragraph nodes with single block node\nexport const schema = new Schema({\n  nodes: baseSchema.spec.nodes\n    .remove('bullet_list')\n    .remove('ordered_list')\n    .remove('list_item')\n    .remove('paragraph')\n    .remove('heading')\n    .remove('blockquote')\n    .remove('code_block')\n    .remove('horizontal_rule')\n    .addToEnd('block', blockSpec)\n    .addToEnd('divider', dividerSpec),\n  marks: baseSchema.spec.marks\n    .addToEnd('underline', {\n      parseDOM: [{ tag: 'u' }, { style: 'text-decoration=underline' }],\n      toDOM(): DOMOutputSpec {\n        return ['u', 0];\n      },\n    })\n    .addToEnd('strikethrough', {\n      parseDOM: [{ tag: 's' }, { tag: 'del' }, { style: 'text-decoration=line-through' }],\n      toDOM(): DOMOutputSpec {\n        return ['s', 0];\n      },\n    }),\n});\n\n// Helper to get node type with runtime check\nfunction getNodeType(name: string) {\n  const nodeType = schema.nodes[name];\n  if (!nodeType) throw new Error(`Node type '${name}' not found in schema`);\n  return nodeType;\n}\n\n// Helper to get mark type with runtime check\nfunction getMarkType(name: string) {\n  const markType = schema.marks[name];\n  if (!markType) throw new Error(`Mark type '${name}' not found in schema`);\n  return markType;\n}\n\n// Exported node types for use in plugins and commands\nexport const nodes = {\n  doc: getNodeType('doc'),\n  block: getNodeType('block'),\n  divider: getNodeType('divider'),\n};\n\n// Exported mark types for use in plugins and commands\nexport const marks = {\n  strong: getMarkType('strong'),\n  em: getMarkType('em'),\n  code: getMarkType('code'),\n  link: getMarkType('link'),\n  underline: getMarkType('underline'),\n  strikethrough: getMarkType('strikethrough'),\n};\n","// Input rules for flat block editor.\n// Convert markdown-style syntax to block attributes.\n\nimport { inputRules, InputRule } from 'prosemirror-inputrules';\nimport { smartQuotes, ellipsis, emDash } from 'prosemirror-inputrules';\nimport type { EditorState } from 'prosemirror-state';\n\n/**\n * Helper to create a block type conversion input rule.\n * Deletes the trigger text and updates the current block's attributes.\n */\nfunction blockTypeRule(pattern: RegExp, getAttrs: (match: RegExpMatchArray) => Record<string, unknown>): InputRule {\n  return new InputRule(pattern, (state: EditorState, match, start, end) => {\n    const $start = state.doc.resolve(start);\n\n    // Only apply at the start of a block\n    if ($start.parentOffset !== 0) return null;\n\n    const blockPos = $start.before(1);\n    const attrs = getAttrs(match);\n\n    return state.tr.delete(start, end).setNodeMarkup(blockPos, undefined, attrs);\n  });\n}\n\n/**\n * Build input rules for flat block editor.\n */\nexport function buildBlockInputRules() {\n  return inputRules({\n    rules: [\n      // Bullet list: - or * at start followed by space\n      blockTypeRule(/^[-*]\\s$/, () => ({\n        type: 'bullet',\n        indent: 0,\n        level: null,\n        checked: null,\n        language: null,\n      })),\n\n      // Numbered list: 1. at start (any number)\n      blockTypeRule(/^(\\d+)\\.\\s$/, () => ({\n        type: 'number',\n        indent: 0,\n        level: null,\n        checked: null,\n        language: null,\n      })),\n\n      // Task list (unchecked): - [ ] at start\n      blockTypeRule(/^[-*]\\s*\\[\\s\\]\\s$/, () => ({\n        type: 'task',\n        indent: 0,\n        checked: false,\n        level: null,\n        language: null,\n      })),\n\n      // Task list (unchecked): [ ] at start (fallback if bullet rule consumed dash)\n      blockTypeRule(/^\\[\\s\\]\\s$/, () => ({\n        type: 'task',\n        indent: 0,\n        checked: false,\n        level: null,\n        language: null,\n      })),\n\n      // Task list (checked): - [x] or - [X] at start\n      blockTypeRule(/^[-*]\\s*\\[[xX]\\]\\s$/, () => ({\n        type: 'task',\n        indent: 0,\n        checked: true,\n        level: null,\n        language: null,\n      })),\n\n      // Task list (checked): [x] or [X] at start (fallback)\n      blockTypeRule(/^\\[[xX]\\]\\s$/, () => ({\n        type: 'task',\n        indent: 0,\n        checked: true,\n        level: null,\n        language: null,\n      })),\n\n      // Heading 1: # at start\n      blockTypeRule(/^#\\s$/, () => ({\n        type: 'heading',\n        level: 1,\n        indent: 0,\n        checked: null,\n        language: null,\n      })),\n\n      // Heading 2: ## at start\n      blockTypeRule(/^##\\s$/, () => ({\n        type: 'heading',\n        level: 2,\n        indent: 0,\n        checked: null,\n        language: null,\n      })),\n\n      // Heading 3: ### at start\n      blockTypeRule(/^###\\s$/, () => ({\n        type: 'heading',\n        level: 3,\n        indent: 0,\n        checked: null,\n        language: null,\n      })),\n\n      // Heading 4: #### at start\n      blockTypeRule(/^####\\s$/, () => ({\n        type: 'heading',\n        level: 4,\n        indent: 0,\n        checked: null,\n        language: null,\n      })),\n\n      // Heading 5: ##### at start\n      blockTypeRule(/^#####\\s$/, () => ({\n        type: 'heading',\n        level: 5,\n        indent: 0,\n        checked: null,\n        language: null,\n      })),\n\n      // Heading 6: ###### at start\n      blockTypeRule(/^######\\s$/, () => ({\n        type: 'heading',\n        level: 6,\n        indent: 0,\n        checked: null,\n        language: null,\n      })),\n\n      // Blockquote: > at start\n      blockTypeRule(/^>\\s$/, () => ({\n        type: 'quote',\n        indent: 0,\n        level: null,\n        checked: null,\n        language: null,\n      })),\n\n      // Code block: ``` with optional language at start followed by space\n      new InputRule(/^```(\\w*)\\s$/, (state: EditorState, match, start, end) => {\n        const $start = state.doc.resolve(start);\n\n        // Only apply in an empty block at the start\n        if ($start.parentOffset !== 0) return null;\n\n        const blockPos = $start.before(1);\n\n        // Let's just trust the regex for now.\n        // If we require space, the user types space.\n\n        return state.tr.delete(start, end).setNodeMarkup(blockPos, undefined, {\n          type: 'code',\n          language: match[1] || null,\n          indent: 0,\n          level: null,\n          checked: null,\n        });\n      }),\n\n      // Divider: --- at start of empty block (exactly three dashes)\n      // Note: emDash rule might convert -- to — (em dash) before this rule triggers on the 3rd dash.\n      // So we match either --- or —-\n      new InputRule(/^(---|—-|—)$/, (state: EditorState, match, start, end) => {\n        const $start = state.doc.resolve(start);\n        const blockPos = $start.before(1);\n        const block = state.doc.nodeAt(blockPos);\n\n        // Only convert if the block only contains \"---\" (minus the last char which is being typed)\n        // match[0] is \"---\" (len 3) or \"—-\" (len 2).\n        // content in doc is \"--\" (len 2) or \"—\" (len 1).\n        // So doc content length should be match[0].length - 1.\n        if (block && block.textContent.length === match[0].length - 1) {\n          return state.tr.delete(start, end).setNodeMarkup(blockPos, undefined, {\n            type: 'divider',\n            indent: 0,\n            level: null,\n            checked: null,\n            language: null,\n          });\n        }\n\n        return null;\n      }),\n\n      // Smart typography\n      ...smartQuotes,\n      ellipsis,\n      emDash,\n    ],\n  });\n}\n","// Keyboard bindings for flat block editor.\n// Handles Tab/Shift-Tab for indentation, Enter for block splitting, Backspace for merging.\n\nimport { keymap } from 'prosemirror-keymap';\nimport { type Command, type EditorState } from 'prosemirror-state';\nimport { type BlockType } from './schema';\n\n/**\n * Check if a block type is list-like (supports indentation).\n */\nfunction isListType(type: BlockType): boolean {\n  return ['bullet', 'number', 'task'].includes(type);\n}\n\n/**\n * Get the current block node and position from cursor position.\n */\nfunction getCurrentBlock(state: EditorState) {\n  const { $from } = state.selection;\n  const blockPos = $from.before(1);\n  const node = state.doc.nodeAt(blockPos);\n  return { node, pos: blockPos, $from };\n}\n\n/**\n * Tab: Increase indentation for list-like blocks.\n */\nconst indentCommand: Command = (state, dispatch) => {\n  const { node, pos } = getCurrentBlock(state);\n  if (!node) return false;\n\n  const { type, indent } = node.attrs;\n  if (!isListType(type as BlockType)) return false;\n  if ((indent as number) >= 8) return false;\n\n  if (dispatch) {\n    dispatch(\n      state.tr.setNodeMarkup(pos, undefined, {\n        ...node.attrs,\n        indent: (indent as number) + 1,\n      })\n    );\n  }\n  return true;\n};\n\n/**\n * Shift-Tab: Decrease indentation.\n */\nconst outdentCommand: Command = (state, dispatch) => {\n  const { node, pos } = getCurrentBlock(state);\n  if (!node) return false;\n\n  const { indent } = node.attrs;\n  if ((indent as number) <= 0) return false;\n\n  if (dispatch) {\n    dispatch(\n      state.tr.setNodeMarkup(pos, undefined, {\n        ...node.attrs,\n        indent: (indent as number) - 1,\n      })\n    );\n  }\n  return true;\n};\n\n/**\n * Enter: Split block or convert empty list item to paragraph.\n */\nconst enterCommand: Command = (state, dispatch) => {\n  const { $from, empty } = state.selection;\n  if (!empty) return false;\n\n  const { node, pos } = getCurrentBlock(state);\n  if (!node) return false;\n\n  const { type, indent } = node.attrs;\n\n  // Only handle list-type blocks specially\n  if (!isListType(type as BlockType)) return false;\n\n  // If block is empty, convert to paragraph or decrease indent\n  if (node.content.size === 0) {\n    if (dispatch) {\n      const newAttrs =\n        (indent as number) > 0\n          ? { type, indent: (indent as number) - 1, checked: type === 'task' ? false : null }\n          : { type: 'paragraph', indent: 0, checked: null };\n      dispatch(state.tr.setNodeMarkup(pos, undefined, newAttrs));\n    }\n    return true;\n  }\n\n  // Split at cursor position\n  if (dispatch) {\n    const splitPos = $from.pos;\n    const newAttrs = { ...node.attrs };\n\n    // Reset checked state for new task items\n    if (type === 'task') {\n      newAttrs.checked = false;\n    }\n\n    // We split block (depth 1)\n    // Pass typesAfter to ensure the new block has correct attributes\n    dispatch(state.tr.split(splitPos, 1, [{ type: node.type, attrs: newAttrs }]));\n\n    // Scroll to view selection\n    // dispatch(state.tr.scrollIntoView()); // usually handled by view\n  }\n  return true;\n};\n\n/**\n * Backspace at start of block: Merge with previous or convert to paragraph.\n */\nconst backspaceCommand: Command = (state, dispatch) => {\n  const { $from, empty } = state.selection;\n  if (!empty || $from.parentOffset !== 0) return false;\n\n  const { node, pos } = getCurrentBlock(state);\n  if (!node) return false;\n\n  const { type, indent } = node.attrs;\n\n  // If indented, outdent first\n  if ((indent as number) > 0) {\n    if (dispatch) {\n      dispatch(\n        state.tr.setNodeMarkup(pos, undefined, {\n          ...node.attrs,\n          indent: (indent as number) - 1,\n        })\n      );\n    }\n    return true;\n  }\n\n  // If list/quote type, convert to paragraph\n  if (['bullet', 'number', 'task', 'quote'].includes(type as string)) {\n    if (dispatch) {\n      dispatch(\n        state.tr.setNodeMarkup(pos, undefined, {\n          type: 'paragraph',\n          indent: 0,\n          checked: null,\n          level: null,\n          language: null,\n        })\n      );\n    }\n    return true;\n  }\n\n  // Let default backspace handle merging paragraphs\n  return false;\n};\n\n/**\n * Build keymap for flat block editor.\n * Should be added to plugins list.\n */\nexport function buildBlockKeymap() {\n  return keymap({\n    Tab: indentCommand,\n    'Shift-Tab': outdentCommand,\n    Enter: enterCommand,\n    Backspace: backspaceCommand,\n  });\n}\n\n/**\n * Export individual commands for testing and programmatic use.\n */\nexport const blockKeymapCommands = {\n  indent: indentCommand,\n  outdent: outdentCommand,\n  enter: enterCommand,\n  backspace: backspaceCommand,\n};\n","// ProseMirror plugin for block-level drag-and-drop functionality.\n// Manages drag state and provides drop indicator decorations.\n\nimport { Plugin, PluginKey, type EditorState, type Transaction } from 'prosemirror-state';\nimport { DecorationSet, type EditorView } from 'prosemirror-view';\n\n// Drag state interface\nexport interface DragState {\n  /** Position of the block being dragged (null if not dragging) */\n  sourcePos: number | null;\n  /** Position to drop (between blocks) */\n  dropTarget: number | null;\n  /** Y coordinate for visual indicator */\n  dropIndicatorY: number | null;\n  /** Positions of multiple selected blocks being dragged */\n  selectedPositions: number[] | null;\n}\n\n// Plugin key for accessing drag state\nexport const blockDragPluginKey = new PluginKey<DragState>('blockDrag');\n\n// Initial state\nconst initialState: DragState = {\n  sourcePos: null,\n  dropTarget: null,\n  dropIndicatorY: null,\n  selectedPositions: null,\n};\n\n/**\n * Get positions of all blocks in the current selection.\n * Used for multi-block drag operations.\n */\nexport function getSelectedBlockPositions(state: EditorState): number[] {\n  const positions: number[] = [];\n  // Use blockRange to identify the range of blocks\n  const $from = state.doc.resolve(state.selection.from);\n  const $to = state.doc.resolve(state.selection.to);\n  const range = $from.blockRange($to);\n\n  if (range && range.parent.type.name === 'doc') {\n    // Iterate manually through the range indices to ensure we capture all top-level blocks\n    // `range.start` is the position of the start of the range (before first block)\n    let currentPos = range.start;\n    for (let i = range.startIndex; i < range.endIndex; i++) {\n      const child = range.parent.child(i);\n      if (child.type.name === 'block') {\n        positions.push(currentPos);\n      }\n      currentPos += child.nodeSize;\n    }\n    return positions;\n  }\n\n  // Handle single block selection specifically\n  // If the selection is inside a block, blockRange might return null (inline content range)\n  // or the parent might be the block itself (not doc)\n  // We want to return the position of the block itself.\n  if ($from.sameParent($to) && $from.parent.type.name === 'block') {\n    // The position of the block is before its content starts?\n    // nodeAt(pos) expects the pos BEFORE the node.\n    // $from.before(depth) returns the pos before the start of the node at depth.\n    // Since blocks are top-level in flat schema, depth is likely 1.\n    // But we use $from.depth to be safe if checking sameParent.\n    positions.push($from.before($from.depth));\n    return positions;\n  }\n\n  // Fallback to nodesBetween if blockRange doesn't give us doc-level blocks\n  state.doc.nodesBetween(state.selection.from, state.selection.to, (node, pos) => {\n    // Only include flat blocks, not the doc or inline content\n    if (node.type.name === 'block' && pos >= 0) {\n      positions.push(pos);\n    }\n    return true; // Continue traversal\n  });\n\n  return positions;\n}\n\n/**\n * Create a transaction to update drag state.\n */\nexport function setDragState(tr: Transaction, updates: Partial<DragState>): Transaction {\n  return tr.setMeta(blockDragPluginKey, updates);\n}\n\n/**\n * Get current drag state from editor state.\n */\nexport function getDragState(state: EditorState): DragState {\n  return blockDragPluginKey.getState(state) ?? initialState;\n}\n\n/**\n * Clear all drag state (call on drop or dragend).\n */\nexport function clearDragState(tr: Transaction): Transaction {\n  return tr.setMeta(blockDragPluginKey, initialState);\n}\n\n/**\n * Find the nearest block boundary position from coordinates.\n * Returns the position and whether to drop above or below.\n */\nexport function findDropTarget(\n  view: EditorView,\n  clientX: number,\n  clientY: number\n): { pos: number; y: number; above: boolean } | null {\n  const coords = { left: clientX, top: clientY };\n  const posInfo = view.posAtCoords(coords);\n  if (!posInfo) return null;\n\n  const $pos = view.state.doc.resolve(posInfo.pos);\n\n  // Find the block-level parent\n  let depth = $pos.depth;\n  while (depth > 0 && !$pos.node(depth).isBlock) {\n    depth--;\n  }\n\n  // If depth is 0, the coordinates are outside block content.\n  // This can happen when dropping at the very edge/bottom of the editor.\n  // In this case, find the nearest block by iterating through all blocks.\n  if (depth === 0) {\n    const doc = view.state.doc;\n    let nearestBlock: { pos: number; top: number; bottom: number } | null = null;\n    let smallestDistance = Infinity;\n\n    doc.forEach((node, pos) => {\n      if (node.type.name === 'block') {\n        const nodeStartCoords = view.coordsAtPos(pos);\n        const nodeEndCoords = view.coordsAtPos(pos + node.nodeSize);\n        const nodeMidY = (nodeStartCoords.top + nodeEndCoords.bottom) / 2;\n        const distance = Math.abs(clientY - nodeMidY);\n\n        if (distance < smallestDistance) {\n          smallestDistance = distance;\n          nearestBlock = { pos, top: nodeStartCoords.top, bottom: nodeEndCoords.bottom };\n        }\n      }\n    });\n\n    if (!nearestBlock) return null;\n\n    // Type assertion needed: TS doesn't track assignments inside callbacks\n    const foundBlock = nearestBlock as { pos: number; top: number; bottom: number };\n\n    // Determine if we should drop above or below this block\n    const nearestMidY = (foundBlock.top + foundBlock.bottom) / 2;\n    const dropAboveNearest = clientY < nearestMidY;\n\n    // For the nearest block, calculate start and end positions\n    const blockNode = doc.nodeAt(foundBlock.pos);\n    if (!blockNode) return null;\n\n    return {\n      pos: dropAboveNearest ? foundBlock.pos : foundBlock.pos + blockNode.nodeSize,\n      y: dropAboveNearest ? foundBlock.top : foundBlock.bottom,\n      above: dropAboveNearest,\n    };\n  }\n\n  const blockStart = $pos.before(depth);\n  const blockEnd = $pos.after(depth);\n  const startCoords = view.coordsAtPos(blockStart);\n  const endCoords = view.coordsAtPos(blockEnd);\n\n  // Determine if we should drop above or below this block\n  const blockMidY = (startCoords.top + endCoords.bottom) / 2;\n  const dropAbove = clientY < blockMidY;\n\n  return {\n    pos: dropAbove ? blockStart : blockEnd,\n    y: dropAbove ? startCoords.top : endCoords.bottom,\n    above: dropAbove,\n  };\n}\n\n/**\n * Execute a block move transaction.\n * Handles moving single or multiple blocks.\n */\nexport function moveBlocks(view: EditorView, sourcePositions: number[], targetPos: number): boolean {\n  if (sourcePositions.length === 0) return false;\n\n  const { state } = view;\n  let tr = state.tr;\n\n  // Sort positions in descending order to handle deletions correctly\n  const sortedPositions = [...sourcePositions].sort((a, b) => b - a);\n\n  // Collect nodes to move\n  const nodesToMove: { node: typeof state.doc.nodeAt extends (p: number) => infer R ? R : never; pos: number }[] = [];\n  for (const pos of sortedPositions) {\n    const node = state.doc.nodeAt(pos);\n    if (node) {\n      nodesToMove.push({ node, pos });\n    }\n  }\n\n  if (nodesToMove.length === 0) return false;\n\n  // Calculate adjusted target position after deletions\n  let adjustedTarget = targetPos;\n  for (const { node, pos } of nodesToMove) {\n    if (node && pos < targetPos) {\n      adjustedTarget -= node.nodeSize;\n    }\n  }\n\n  // Delete nodes from highest position first (so positions remain valid)\n  for (const { node, pos } of nodesToMove) {\n    if (node) {\n      tr = tr.delete(pos, pos + node.nodeSize);\n    }\n  }\n\n  // Insert nodes at target (in original order)\n  const reversedNodes = [...nodesToMove].reverse();\n  let insertPos = adjustedTarget;\n  for (const { node } of reversedNodes) {\n    if (node) {\n      tr = tr.insert(insertPos, node);\n      insertPos += node.nodeSize;\n    }\n  }\n\n  // Clear drag state\n  tr = clearDragState(tr);\n\n  view.dispatch(tr);\n  return true;\n}\n\n// Note: Drop indicator is rendered externally based on dropIndicatorY from state\n\n/**\n * Block drag-and-drop plugin.\n * Tracks drag state and provides decorations for drop indicator.\n */\nexport const blockDragPlugin = new Plugin<DragState>({\n  key: blockDragPluginKey,\n\n  state: {\n    init: () => initialState,\n    apply(tr, state) {\n      const meta = tr.getMeta(blockDragPluginKey);\n      if (meta) {\n        return { ...state, ...meta };\n      }\n      return state;\n    },\n  },\n\n  props: {\n    // Handle drag events at the view level\n    handleDOMEvents: {\n      dragover(view, event) {\n        // Only handle if we're dragging a block\n        const state = getDragState(view.state);\n        if (state.sourcePos === null && state.selectedPositions === null) {\n          return false;\n        }\n\n        event.preventDefault();\n        if (event.dataTransfer) {\n          event.dataTransfer.dropEffect = 'move';\n        }\n\n        const target = findDropTarget(view, event.clientX, event.clientY);\n        if (target) {\n          view.dispatch(\n            setDragState(view.state.tr, {\n              dropTarget: target.pos,\n              dropIndicatorY: target.y,\n            })\n          );\n        }\n\n        return true;\n      },\n\n      drop(view, event) {\n        const state = getDragState(view.state);\n        const { sourcePos, dropTarget, selectedPositions } = state;\n\n        // Clean up dragging class from all blocks\n        view.dom.querySelectorAll('.block-row.dragging').forEach((el) => {\n          el.classList.remove('dragging');\n        });\n\n        // Handle multi-block drop\n        if (selectedPositions && selectedPositions.length > 0 && dropTarget !== null) {\n          event.preventDefault();\n          return moveBlocks(view, selectedPositions, dropTarget);\n        }\n\n        // Handle single block drop\n        if (sourcePos !== null && dropTarget !== null) {\n          event.preventDefault();\n          return moveBlocks(view, [sourcePos], dropTarget);\n        }\n\n        // Clear state even if we didn't handle the drop\n        view.dispatch(clearDragState(view.state.tr));\n        return false;\n      },\n\n      dragend(view) {\n        // Clean up dragging class from all blocks\n        view.dom.querySelectorAll('.block-row.dragging').forEach((el) => {\n          el.classList.remove('dragging');\n        });\n        view.dispatch(clearDragState(view.state.tr));\n        return false;\n      },\n\n      dragleave(view, event) {\n        // Only clear if leaving the editor entirely\n        const relatedTarget = event.relatedTarget as Node | null;\n        if (!view.dom.contains(relatedTarget)) {\n          view.dispatch(\n            setDragState(view.state.tr, {\n              dropTarget: null,\n              dropIndicatorY: null,\n            })\n          );\n        }\n        return false;\n      },\n    },\n\n    // Provide decorations for drop indicator\n    decorations(state) {\n      const dragState = this.getState(state);\n      if (!dragState || dragState.dropIndicatorY === null) {\n        return DecorationSet.empty;\n      }\n\n      // Return empty for now - actual indicator rendered via CSS/view\n      // The indicator Y position is available for external rendering\n      return DecorationSet.empty;\n    },\n  },\n});\n\n/**\n * MIME type for block drag data.\n */\nexport const BLOCK_DRAG_MIME = 'application/x-prosemirror-block';\nexport const BLOCKS_DRAG_MIME = 'application/x-prosemirror-blocks';\n","import { Plugin, PluginKey } from 'prosemirror-state';\nimport { Decoration, DecorationSet } from 'prosemirror-view';\nimport { getSelectedBlockPositions } from './blockDragPlugin';\n\n/**\n * Plugin to handle visual states for multi-block selections.\n * Adds 'in-selection' class to selected blocks when more than one block is selected.\n */\nexport const blockSelectionPluginKey = new PluginKey('blockSelection');\n\nexport const blockSelectionPlugin = new Plugin({\n  key: blockSelectionPluginKey,\n  props: {\n    decorations(state) {\n      const positions = getSelectedBlockPositions(state);\n\n      // We only apply special styling when multiple blocks are selected.\n      // Standard ProseMirror selection handles single-block text selection.\n      if (positions.length <= 1) {\n        return DecorationSet.empty;\n      }\n\n      const decorations: Decoration[] = [];\n      const { doc } = state;\n\n      for (const pos of positions) {\n        const node = doc.nodeAt(pos);\n        if (node) {\n          // Add 'in-selection' class to the block node\n          decorations.push(Decoration.node(pos, pos + node.nodeSize, { class: 'in-selection' }));\n        }\n      }\n\n      return DecorationSet.create(doc, decorations);\n    },\n  },\n});\n","import { Plugin } from 'prosemirror-state';\n\n/**\n * Plugin to automatically manage numbering for numbered lists.\n * It computes the sequential number for each 'number' block based on its indentation level\n * and updates the 'number' attribute via a transaction.\n */\nexport const numberCounterPlugin = new Plugin({\n  appendTransaction(transactions, _oldState, newState) {\n    // Only recompute if document changed\n    if (!transactions.some((transaction) => transaction.docChanged)) return null;\n\n    const tr = newState.tr;\n    let needsUpdate = false;\n    const counters = new Map<number, number>(); // indent -> current count\n\n    newState.doc.forEach((node, pos) => {\n      // In flat architecture, blocks are always direct children of doc\n      if (node.type.name !== 'block') return;\n\n      const indent = node.attrs.indent || 0;\n\n      if (node.attrs.type === 'number') {\n        const currentCount = (counters.get(indent) || 0) + 1;\n        counters.set(indent, currentCount);\n\n        // Reset deeper counters\n        for (const [level] of counters) {\n          if (level > indent) counters.delete(level);\n        }\n\n        const oldNumber = node.attrs.number;\n        if (oldNumber !== currentCount) {\n          tr.setNodeMarkup(pos, undefined, { ...node.attrs, number: currentCount });\n          needsUpdate = true;\n        }\n      } else {\n        // Non-numbered block.\n        // Resets counters at and below this indent\n        // This logic ensures that a paragraph at the same level breaks the list\n        for (const [level] of counters) {\n          if (indent <= level) {\n            counters.delete(level);\n          }\n        }\n      }\n    });\n\n    return needsUpdate ? tr : null;\n  },\n});\n","// ProseMirror configuration for the flat block editor.\n// Integrates schema, plugins, and keymaps for the new block-based architecture.\n\nimport { EditorState, type Plugin } from 'prosemirror-state';\nimport { history } from 'prosemirror-history';\nimport { keymap } from 'prosemirror-keymap';\nimport { baseKeymap } from 'prosemirror-commands';\nimport { dropCursor } from 'prosemirror-dropcursor';\nimport { gapCursor } from 'prosemirror-gapcursor';\nimport type { Node as ProseMirrorNode } from 'prosemirror-model';\n\n// Import flat block schema\nimport { schema } from './schema';\n\n// Import new block-specific plugins and rules\nimport { buildBlockInputRules } from './blockInputRules';\nimport { buildBlockKeymap } from './blockKeymap';\nimport { blockDragPlugin } from './blockDragPlugin';\nimport { blockSelectionPlugin } from './blockSelectionPlugin';\nimport { numberCounterPlugin } from './numberCounterPlugin';\n\n// Re-export schema components for use in other files\nexport { schema };\nexport { nodes, marks } from './schema';\n\n/**\n * Create a new EditorState with all necessary plugins for the block editor.\n */\nexport function createEditorState(doc: ProseMirrorNode, extraPlugins?: Plugin[]) {\n  return EditorState.create({\n    doc,\n    schema,\n    plugins: [\n      // Input rules for converting markdown syntax to blocks (e.g. \"- \" -> bullet block)\n      buildBlockInputRules(),\n\n      // Keymap for block operations (Enter, Backspace, Tab, etc.)\n      buildBlockKeymap(),\n\n      // Standard ProseMirror keymap (Ctrl+Z, basic editing)\n      keymap(baseKeymap),\n\n      // Undo/Redo history\n      history(),\n\n      // Drag and drop system\n      blockDragPlugin,\n      blockSelectionPlugin,\n      numberCounterPlugin,\n\n      // UI polish\n      dropCursor({ color: 'var(--c-primary)', width: 2 }),\n      gapCursor(),\n\n      // Extra plugins passed from Editor (e.g. slash menu, upload)\n      ...(extraPlugins || []),\n    ],\n  });\n}\n","import { Schema } from 'prosemirror-model';\nimport { schema as baseSchema } from 'prosemirror-markdown';\nimport { addListNodes } from 'prosemirror-schema-list';\n\n// Extend base schema nodes with list nodes and custom list_item attributes\nlet nodes = addListNodes(baseSchema.spec.nodes, 'paragraph block*', 'block');\n\n// Update list_item to support 'checked' attribute for task lists\nconst listItemNode = nodes.get('list_item');\nif (listItemNode) {\n  nodes = nodes.update('list_item', {\n    ...listItemNode,\n    attrs: {\n      ...listItemNode.attrs,\n      checked: { default: null }, // null = bullet/number, boolean = task\n    },\n  });\n}\n\n// Add underline and strikethrough marks if missing\nlet marks = baseSchema.spec.marks;\n\nif (!marks.get('underline')) {\n  marks = marks.addToEnd('underline', {\n    parseDOM: [{ tag: 'u' }, { style: 'text-decoration=underline' }],\n    toDOM() {\n      return ['u', 0];\n    },\n  });\n}\n\nif (!marks.get('strikethrough')) {\n  marks = marks.addToEnd('strikethrough', {\n    parseDOM: [{ tag: 's' }, { tag: 'del' }, { style: 'text-decoration=line-through' }],\n    toDOM() {\n      return ['s', 0];\n    },\n  });\n}\n\n// Rename 'strike' to 'strikethrough' if it exists differently or ensure naming consistency\n// prosemirror-markdown usually has 'em', 'strong', 'link', 'code'.\n// We ensure 'underline' and 'strikethrough' are present.\n\nexport const nestedSchema = new Schema({\n  nodes,\n  marks,\n});\n","// Markdown-to-flat-blocks parser: converts markdown to ProseMirror document with flat block structure.\n// Strategy: Parse markdown using MarkdownParser (which handles nesting correctly), then flatten the result.\n\nimport MarkdownIt from 'markdown-it';\nimport type Token from 'markdown-it/lib/token.mjs';\nimport { MarkdownParser } from 'prosemirror-markdown';\nimport { nestedSchema } from './nested-schema';\nimport { schema, nodes, type BlockAttrs } from './schema';\nimport type { Node as ProseMirrorNode } from 'prosemirror-model';\n\n// Create markdown-it instance with task list and underline support\nfunction createMarkdownIt(): MarkdownIt {\n  const md = new MarkdownIt();\n\n  // Parse task list checkboxes: [ ] and [x] at start of content\n  md.core.ruler.after('inline', 'task_list', (state) => {\n    const tokens = state.tokens;\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n      if (!token) continue;\n      if (token.type === 'list_item_open') {\n        // Look for inline content in this list item\n        const inlineToken = tokens[i + 2];\n        if (inlineToken && inlineToken.type === 'inline' && inlineToken.children) {\n          const firstChild = inlineToken.children[0];\n          if (firstChild && firstChild.type === 'text' && firstChild.content) {\n            const match = firstChild.content.match(/^\\[([ xX])\\]\\s*/);\n            if (match && match[1]) {\n              // Mark this as a task list item\n              token.attrSet('checked', match[1].toLowerCase() === 'x' ? 'true' : 'false');\n              // Remove checkbox syntax from text\n              firstChild.content = firstChild.content.slice(match[0].length);\n            }\n          }\n        }\n      }\n    }\n    return true;\n  });\n\n  // Parse inline underline: <u>text</u>\n  md.inline.ruler.before('html_inline', 'underline', (state, silent) => {\n    const start = state.pos;\n    const max = state.posMax;\n    const src = state.src;\n\n    if (src.slice(start, start + 3).toLowerCase() !== '<u>') return false;\n\n    const closeTag = '</u>';\n    const closePos = src.toLowerCase().indexOf(closeTag, start + 3);\n    if (closePos === -1 || closePos >= max) return false;\n\n    if (!silent) {\n      const openToken = state.push('underline_open', 'u', 1);\n      openToken.markup = '<u>';\n\n      const content = src.slice(start + 3, closePos);\n      const textToken = state.push('text', '', 0);\n      textToken.content = content;\n\n      const closeToken = state.push('underline_close', 'u', -1);\n      closeToken.markup = '</u>';\n    }\n\n    state.pos = closePos + closeTag.length;\n    return true;\n  });\n\n  return md;\n}\n\n/**\n * Convert inline content from nested schema to flat schema.\n * This is necessary because the nested schema creates text nodes with a different schema instance.\n */\nfunction convertInlineContent(content: ProseMirrorNode | null): ProseMirrorNode[] {\n  if (!content) return [];\n\n  const result: ProseMirrorNode[] = [];\n  content.content.forEach((child) => {\n    if (child.isText) {\n      // Convert text node: create new text with same content and converted marks\n      const marks = child.marks\n        .map((m) => {\n          const markType = schema.marks[m.type.name];\n          return markType ? markType.create(m.attrs) : null;\n        })\n        .filter((m): m is NonNullable<typeof m> => m !== null);\n\n      result.push(schema.text(child.text || '', marks));\n    } else if (child.type.name === 'hard_break') {\n      // Convert hard_break\n      const hardBreakType = schema.nodes.hard_break;\n      if (hardBreakType) result.push(hardBreakType.create());\n    } else if (child.type.name === 'image') {\n      // Convert image\n      const imageType = schema.nodes.image;\n      if (imageType) result.push(imageType.create(child.attrs));\n    }\n    // Other inline types can be added here if needed\n  });\n\n  return result;\n}\n\n/**\n * Converts markdown text to a ProseMirror document with flat block structure.\n * Parses using nested schema first, then flattens the structure.\n */\nexport function parseMarkdown(markdown: string): ProseMirrorNode {\n  const md = createMarkdownIt();\n  const parser = new MarkdownParser(nestedSchema, md, {\n    blockquote: { block: 'blockquote' },\n    paragraph: { block: 'paragraph' },\n    list_item: {\n      block: 'list_item',\n      getAttrs: (tok: Token) => {\n        const checked = tok.attrGet('checked');\n        if (checked === 'true') return { checked: true };\n        if (checked === 'false') return { checked: false };\n        return { checked: null };\n      },\n    },\n    bullet_list: { block: 'bullet_list' },\n    ordered_list: { block: 'ordered_list', getAttrs: (tok: Token) => ({ order: +(tok.attrGet('start') || 1) }) },\n    heading: { block: 'heading', getAttrs: (tok: Token) => ({ level: +tok.tag.slice(1) }) },\n    code_block: { block: 'code_block', noCloseToken: true },\n    fence: { block: 'code_block', getAttrs: (tok: Token) => ({ params: tok.info || '' }), noCloseToken: true },\n    hr: { node: 'horizontal_rule' },\n    em: { mark: 'em' },\n    strong: { mark: 'strong' },\n    underline: { mark: 'underline' },\n    s: { mark: 'strikethrough' },\n    link: {\n      mark: 'link',\n      getAttrs: (tok: Token) => ({\n        href: tok.attrGet('href'),\n        title: tok.attrGet('title') || null,\n      }),\n    },\n    code_inline: { mark: 'code' },\n    image: {\n      node: 'image',\n      getAttrs: (tok: Token) => ({\n        src: tok.attrGet('src'),\n        title: tok.attrGet('title') || null,\n        alt: tok.content || null,\n      }),\n    },\n    hardbreak: { node: 'hard_break' },\n  });\n\n  // Parse markdown using nested schema\n  const nestedDoc = parser.parse(markdown);\n\n  // Flatten the nested structure to flat blocks\n  const flatBlocks: ProseMirrorNode[] = [];\n  flattenDocument(nestedDoc, flatBlocks, 0);\n\n  return nodes.doc.create(null, flatBlocks);\n}\n\n/**\n * Recursively flattens nested ProseMirror document into flat blocks.\n * Converts nested lists to flat blocks with indent attributes.\n */\nfunction flattenDocument(node: ProseMirrorNode, blocks: ProseMirrorNode[], baseIndent: number): void {\n  node.forEach((child) => {\n    if (child.type.name === 'bullet_list' || child.type.name === 'ordered_list') {\n      flattenList(child, blocks, baseIndent, child.type.name as 'bullet_list' | 'ordered_list');\n    } else if (child.type.name === 'list_item') {\n      // Should not happen at top level, but handle it\n      flattenListItem(child, blocks, baseIndent, 'bullet');\n    } else if (child.type.name === 'heading') {\n      const content = convertInlineContent(child);\n      const blockNode = nodes.block.create({ type: 'heading', level: child.attrs.level, indent: 0 }, content);\n      blocks.push(blockNode);\n    } else if (child.type.name === 'paragraph') {\n      const content = convertInlineContent(child);\n      const blockNode = nodes.block.create({ type: 'paragraph', indent: 0 }, content);\n      blocks.push(blockNode);\n    } else if (child.type.name === 'blockquote') {\n      // Handle blockquote content (which might be paragraphs or other blocks in standard MD)\n      // For flat blocks, we assume blockquote is a single block type 'quote'\n      // If blockquote contains multiple paragraphs, we might need multiple quote blocks?\n      // For now, let's flatten formatting but keep it as one block if possible, or multiple.\n      // But 'quote' block acts like a paragraph with quote styling.\n\n      // If the blockquote contains paragraphs, we should extract their content.\n      // Simple approach: Iterate children of blockquote.\n      if (child.childCount > 0) {\n        child.forEach((inner) => {\n          if (inner.type.name === 'paragraph') {\n            const content = convertInlineContent(inner);\n            const blockNode = nodes.block.create({ type: 'quote', indent: 0 }, content);\n            blocks.push(blockNode);\n          }\n        });\n      } else {\n        // Fallback for empty or text-only (if schema allowed)\n        const content = convertInlineContent(child);\n        const blockNode = nodes.block.create({ type: 'quote', indent: 0 }, content);\n        blocks.push(blockNode);\n      }\n    } else if (child.type.name === 'code_block') {\n      const content = child.textContent;\n      const language = child.attrs.params || '';\n      const blockNode = nodes.block.create(\n        { type: 'code', language: language || undefined, indent: 0 },\n        schema.text(content)\n      );\n      blocks.push(blockNode);\n    } else if (child.type.name === 'horizontal_rule') {\n      const blockNode = nodes.divider.create({ type: 'divider', indent: 0 });\n      blocks.push(blockNode);\n    }\n  });\n}\n\n/**\n * Flattens a list (bullet or ordered) into flat blocks with proper indentation.\n */\nfunction flattenList(\n  listNode: ProseMirrorNode,\n  blocks: ProseMirrorNode[],\n  baseIndent: number,\n  listType: 'bullet_list' | 'ordered_list'\n): void {\n  let counter = 1;\n  listNode.forEach((item) => {\n    if (item.type.name === 'list_item') {\n      const number = listType === 'ordered_list' ? counter++ : undefined;\n      flattenListItem(item, blocks, baseIndent, listType === 'ordered_list' ? 'number' : 'bullet', number);\n    }\n  });\n}\n\n/**\n * Flattens a single list item and any nested lists within it.\n */\nfunction flattenListItem(\n  itemNode: ProseMirrorNode,\n  blocks: ProseMirrorNode[],\n  baseIndent: number,\n  itemType: 'bullet' | 'number' | 'task',\n  number?: number\n): void {\n  let itemContent: ProseMirrorNode | null = null;\n\n  // Separate item content from nested lists\n  itemNode.forEach((child) => {\n    if (child.type.name === 'paragraph') {\n      itemContent = child;\n    }\n  });\n\n  // Create block for this item\n  const isTask = itemNode.attrs.checked !== null;\n  const blockType = isTask ? 'task' : itemType;\n  const blockAttrs: BlockAttrs = {\n    type: blockType,\n    indent: baseIndent,\n    ...(isTask && { checked: itemNode.attrs.checked }),\n    ...(blockType === 'number' && typeof number === 'number' && { number }),\n  };\n\n  const blockContent = itemContent ? convertInlineContent(itemContent as ProseMirrorNode) : [];\n  const blockNode = nodes.block.create(blockAttrs, blockContent);\n  blocks.push(blockNode);\n\n  // Flatten nested lists\n  itemNode.forEach((child) => {\n    if (child.type.name === 'bullet_list' || child.type.name === 'ordered_list') {\n      flattenList(child, blocks, baseIndent + 1, child.type.name as 'bullet_list' | 'ordered_list');\n    }\n  });\n}\n","// Flat-blocks-to-markdown serializer: reconstructs nested markdown from flat block structure.\n// Groups consecutive list items by indent and type, emits proper list markers and indentation.\n\nimport type { Node as ProseMirrorNode } from 'prosemirror-model';\nimport type { BlockAttrs } from './schema';\n\ninterface ListContext {\n  type: 'bullet' | 'number' | 'task';\n  indent: number;\n}\n\n/**\n * Serializes a flat block document back to markdown.\n * Reconstructs list structure by tracking consecutive blocks of same type/indent.\n */\nexport function serializeToMarkdown(doc: ProseMirrorNode): string {\n  const lines: string[] = [];\n  const listContext: ListContext[] = [];\n  const numberCounters = new Map<number, number>(); // indent → counter\n  let prevType: string | null = null;\n\n  doc.forEach((block) => {\n    const { type, indent, checked, level, language } = block.attrs as BlockAttrs;\n    const content = serializeInline(block);\n\n    // Close list contexts that no longer apply\n    while (listContext.length > 0) {\n      const ctx = listContext[listContext.length - 1];\n      if (ctx === undefined) break;\n      // Close if: indent has decreased, or type has changed at same indent\n      if (ctx.indent > indent || (ctx.indent === indent && ctx.type !== type && isListType(type))) {\n        listContext.pop();\n      } else {\n        break;\n      }\n    }\n\n    // Add blank line before paragraphs that follow non-paragraphs (e.g., after list items)\n    // This ensures proper separation in markdown so they parse correctly\n    const prevWasList = prevType === 'bullet' || prevType === 'number' || prevType === 'task';\n    const currentIsParagraph = type === 'paragraph';\n    if (lines.length > 0 && prevWasList && currentIsParagraph) {\n      lines.push('');\n    }\n    // Also add blank line between paragraphs\n    if (lines.length > 0 && prevType === 'paragraph' && currentIsParagraph) {\n      lines.push('');\n    }\n    // Add blank line before list items that follow paragraphs\n    if (lines.length > 0 && prevType === 'paragraph' && isListType(type)) {\n      lines.push('');\n    }\n\n    // Build line with appropriate prefix\n    const indentStr = '  '.repeat(indent);\n    let prefix = '';\n\n    switch (type) {\n      case 'bullet': {\n        prefix = '- ';\n        if (!listContext.some((ctx) => ctx.indent === indent && ctx.type === 'bullet')) {\n          listContext.push({ type: 'bullet', indent });\n        }\n        break;\n      }\n\n      case 'number': {\n        const counter = (numberCounters.get(indent) || 0) + 1;\n        numberCounters.set(indent, counter);\n        prefix = `${counter}. `;\n        if (!listContext.some((ctx) => ctx.indent === indent && ctx.type === 'number')) {\n          listContext.push({ type: 'number', indent });\n        }\n        break;\n      }\n\n      case 'task': {\n        prefix = checked ? '- [x] ' : '- [ ] ';\n        if (!listContext.some((ctx) => ctx.indent === indent && ctx.type === 'task')) {\n          listContext.push({ type: 'task', indent });\n        }\n        break;\n      }\n\n      case 'heading': {\n        prefix = '#'.repeat(level || 1) + ' ';\n        // Reset number counters at this indent level when leaving list\n        numberCounters.delete(indent);\n        break;\n      }\n\n      case 'quote': {\n        prefix = '> ';\n        numberCounters.delete(indent);\n        break;\n      }\n\n      case 'code': {\n        lines.push('```' + (language || ''));\n        lines.push(content);\n        lines.push('```');\n        prevType = type;\n        return;\n      }\n\n      case 'divider': {\n        lines.push('---');\n        prevType = type;\n        return;\n      }\n\n      default:\n        prefix = '';\n        numberCounters.delete(indent);\n    }\n\n    lines.push(indentStr + prefix + content);\n    prevType = type;\n  });\n\n  return lines.join('\\n');\n}\n\n/**\n * Serializes the inline content of a block (handles marks and nested formatting).\n */\nfunction serializeInline(block: ProseMirrorNode): string {\n  let result = '';\n\n  block.forEach((node) => {\n    if (node.isText) {\n      let text = node.text || '';\n\n      // Apply marks\n      node.marks.forEach((mark) => {\n        if (mark.type.name === 'strong') {\n          text = `**${text}**`;\n        } else if (mark.type.name === 'em') {\n          text = `*${text}*`;\n        } else if (mark.type.name === 'code') {\n          text = `\\`${text}\\``;\n        } else if (mark.type.name === 'strikethrough') {\n          text = `~~${text}~~`;\n        } else if (mark.type.name === 'underline') {\n          text = `<u>${text}</u>`;\n        } else if (mark.type.name === 'link') {\n          const href = mark.attrs.href || '#';\n          const title = mark.attrs.title;\n          text = `[${text}](${href}${title ? ` \"${title}\"` : ''})`;\n        }\n      });\n\n      result += text;\n    } else if (node.type.name === 'image') {\n      const { src, alt, title } = node.attrs;\n      result += `![${alt || ''}](${src || ''}${title ? ` \"${title}\"` : ''})`;\n    } else if (node.type.name === 'hard_break') {\n      result += '\\\\\\n';\n    }\n  });\n\n  return result;\n}\n\n/**\n * Checks if a block type is a list type.\n */\nfunction isListType(type: string): boolean {\n  return type === 'bullet' || type === 'number' || type === 'task';\n}\n","// ProseMirror NodeView implementation for flat blocks with integrated drag handles.\n\nimport { render } from 'solid-js/web';\nimport type { Node as ProseMirrorNode } from 'prosemirror-model';\nimport type { EditorView, NodeView, ViewMutationRecord } from 'prosemirror-view';\nimport { RowHandle } from '../shared/RowHandle';\nimport { setDragState, getSelectedBlockPositions, BLOCK_DRAG_MIME, BLOCKS_DRAG_MIME } from './blockDragPlugin';\n\n/**\n * Custom event detail for block context menu requests.\n */\nexport interface BlockContextMenuDetail {\n  pos: number;\n  x: number;\n  y: number;\n  selectedCount: number;\n}\n\n/**\n * Custom event dispatched when a block's context menu is requested.\n */\nexport const BLOCK_CONTEXT_MENU_EVENT = 'block-context-menu';\n\n/**\n * NodeView implementation for flat block nodes.\n */\nexport class BlockNodeView implements NodeView {\n  dom: HTMLElement;\n  contentDOM: HTMLElement;\n  private handleDispose: (() => void) | null = null;\n  private handleContainer: HTMLElement;\n\n  constructor(\n    private node: ProseMirrorNode,\n    private view: EditorView,\n    private getPos: () => number | undefined\n  ) {\n    this.dom = document.createElement('div');\n    this.dom.className = 'block-row row-with-handle';\n    this.updateDOMAttributes();\n\n    this.handleContainer = document.createElement('div');\n    this.handleContainer.className = 'block-handle-container';\n    this.handleContainer.contentEditable = 'false';\n    this.dom.appendChild(this.handleContainer);\n\n    this.mountHandle();\n\n    const { contentDOM, wrapperDOM } = this.createContentElement();\n    this.contentDOM = contentDOM;\n    this.dom.appendChild(wrapperDOM || contentDOM);\n  }\n\n  private createContentElement(): { contentDOM: HTMLElement; wrapperDOM?: HTMLElement } {\n    const { type, level, checked, language } = this.node.attrs;\n    let element: HTMLElement;\n\n    switch (type) {\n      case 'heading': {\n        const tag = `h${level || 1}`;\n        element = document.createElement(tag);\n        break;\n      }\n      case 'code': {\n        const pre = document.createElement('pre');\n        const code = document.createElement('code');\n        pre.appendChild(code);\n        if (language) {\n          pre.dataset.language = language;\n        }\n        pre.className = 'block-content';\n        return { contentDOM: code, wrapperDOM: pre };\n      }\n      case 'quote': {\n        element = document.createElement('blockquote');\n        break;\n      }\n      case 'divider': {\n        element = document.createElement('hr');\n        break;\n      }\n      case 'task': {\n        element = document.createElement('div');\n        element.className = 'block-task';\n        element.dataset.checked = String(checked || false);\n        break;\n      }\n      case 'bullet':\n      case 'number': {\n        element = document.createElement('div');\n        element.className = `block-${type}`;\n        if (this.node.attrs.number !== undefined && this.node.attrs.number !== null) {\n          element.dataset.number = String(this.node.attrs.number);\n        }\n        break;\n      }\n      default: {\n        element = document.createElement('p');\n        break;\n      }\n    }\n\n    element.className = `${element.className || ''} block-content`.trim();\n    return { contentDOM: element };\n  }\n\n  private updateDOMAttributes(): void {\n    const { type, indent, level, checked, language } = this.node.attrs;\n\n    this.dom.dataset.type = type;\n    this.dom.dataset.indent = String(indent || 0);\n\n    if (level !== null && level !== undefined) {\n      this.dom.dataset.level = String(level);\n    }\n    if (checked !== null && checked !== undefined) {\n      this.dom.dataset.checked = String(checked);\n    }\n    if (language) {\n      this.dom.dataset.language = language;\n    }\n  }\n\n  private mountHandle(): void {\n    const pos = this.getPos();\n    const rowId = pos !== undefined ? String(pos) : '0';\n\n    this.handleDispose = render(\n      () =>\n        RowHandle({\n          rowId,\n          onDragStart: this.handleDragStart.bind(this),\n          onContextMenu: this.handleContextMenu.bind(this),\n          onClick: this.handleClick.bind(this),\n        }),\n      this.handleContainer\n    );\n  }\n\n  private handleDragStart(e: DragEvent, _rowId: string): void {\n    const pos = this.getPos();\n    if (pos === undefined) return;\n\n    const selectedPositions = getSelectedBlockPositions(this.view.state);\n    const isMultiSelection = selectedPositions.length > 1 && selectedPositions.includes(pos);\n\n    // Set dataTransfer synchronously (required for drag)\n    if (e.dataTransfer) {\n      if (isMultiSelection) {\n        e.dataTransfer.setData(BLOCKS_DRAG_MIME, JSON.stringify(selectedPositions));\n      } else {\n        e.dataTransfer.setData(BLOCK_DRAG_MIME, String(pos));\n      }\n      e.dataTransfer.effectAllowed = 'move';\n\n      // Set drag image\n      const blockRect = this.dom.getBoundingClientRect();\n      const offsetX = e.clientX - blockRect.left;\n      const offsetY = e.clientY - blockRect.top;\n      e.dataTransfer.setDragImage(this.dom, offsetX, offsetY);\n    }\n\n    this.dom.classList.add('dragging');\n\n    // Defer state update to avoid interfering with native drag initialization\n    setTimeout(() => {\n      this.view.dispatch(\n        setDragState(this.view.state.tr, {\n          sourcePos: pos,\n          selectedPositions: isMultiSelection ? selectedPositions : null,\n        })\n      );\n    }, 0);\n  }\n\n  private handleContextMenu(e: MouseEvent, _rowId: string): void {\n    const pos = this.getPos();\n    if (pos === undefined) return;\n\n    const selectedPositions = getSelectedBlockPositions(this.view.state);\n    const selectedCount =\n      selectedPositions.length > 1 && selectedPositions.includes(pos) ? selectedPositions.length : 1;\n\n    const detail: BlockContextMenuDetail = {\n      pos,\n      x: e.clientX,\n      y: e.clientY,\n      selectedCount,\n    };\n\n    this.view.dom.dispatchEvent(\n      new CustomEvent(BLOCK_CONTEXT_MENU_EVENT, {\n        detail,\n        bubbles: true,\n      })\n    );\n  }\n\n  private handleClick(e: MouseEvent, rowId: string): void {\n    this.handleContextMenu(e, rowId);\n  }\n\n  update(node: ProseMirrorNode): boolean {\n    if (node.type !== this.node.type) {\n      return false;\n    }\n\n    if (node.attrs.type !== this.node.attrs.type) {\n      return false;\n    }\n\n    this.node = node;\n    this.updateDOMAttributes();\n\n    if (node.attrs.type === 'task') {\n      const taskContent = this.dom.querySelector('.block-task');\n      if (taskContent) {\n        (taskContent as HTMLElement).dataset.checked = String(node.attrs.checked || false);\n      }\n    }\n\n    if (node.attrs.type === 'number') {\n      if (node.attrs.number !== undefined && node.attrs.number !== null) {\n        this.contentDOM.dataset.number = String(node.attrs.number);\n      }\n    }\n\n    return true;\n  }\n\n  selectNode(): void {\n    this.dom.classList.add('selected');\n  }\n\n  deselectNode(): void {\n    this.dom.classList.remove('selected');\n  }\n\n  destroy(): void {\n    this.dom.classList.remove('dragging');\n\n    if (this.handleDispose) {\n      this.handleDispose();\n      this.handleDispose = null;\n    }\n  }\n\n  ignoreMutation(mutation: ViewMutationRecord): boolean {\n    if (mutation.type !== 'selection' && this.handleContainer.contains(mutation.target as Node)) {\n      return true;\n    }\n    return false;\n  }\n}\n\nexport function createBlockNodeView(\n  node: ProseMirrorNode,\n  view: EditorView,\n  getPos: () => number | undefined\n): BlockNodeView {\n  return new BlockNodeView(node, view, getPos);\n}\n","// ProseMirror plugin for detecting \"/\" slash commands and tracking menu state.\n\nimport { Plugin, PluginKey } from 'prosemirror-state';\nimport type { EditorView } from 'prosemirror-view';\n\nexport interface SlashMenuState {\n  active: boolean;\n  query: string;\n  triggerPos: number;\n  position: { top: number; left: number };\n}\n\nexport const slashMenuKey = new PluginKey<SlashMenuState>('slashMenu');\n\nconst initialState: SlashMenuState = {\n  active: false,\n  query: '',\n  triggerPos: 0,\n  position: { top: 0, left: 0 },\n};\n\n/**\n * Creates a ProseMirror plugin that detects \"/\" at line start or after whitespace\n * and triggers the slash command menu.\n */\nexport function createSlashCommandPlugin(onStateChange: (state: SlashMenuState) => void): Plugin<SlashMenuState> {\n  return new Plugin<SlashMenuState>({\n    key: slashMenuKey,\n\n    state: {\n      init() {\n        return { ...initialState };\n      },\n\n      apply(tr, pluginState, _oldState, newState) {\n        // Check if there's a meta flag to close the menu\n        const meta = tr.getMeta(slashMenuKey);\n        if (meta?.close) {\n          if (pluginState.active) {\n            const newPluginState = { ...initialState };\n            // Schedule state change callback\n            setTimeout(() => onStateChange(newPluginState), 0);\n            return newPluginState;\n          }\n          return pluginState;\n        }\n\n        // Only process on document changes or selection changes\n        if (!tr.docChanged && !tr.selectionSet) {\n          return pluginState;\n        }\n\n        const { selection } = newState;\n        const { $from } = selection;\n\n        // Only trigger in empty selections (cursor position)\n        if (!selection.empty) {\n          if (pluginState.active) {\n            const newPluginState = { ...initialState };\n            setTimeout(() => onStateChange(newPluginState), 0);\n            return newPluginState;\n          }\n          return pluginState;\n        }\n\n        // Get text from start of text block to cursor\n        // In flat block schema, blocks are top-level and content is directly inside\n        const textBlockStart = $from.start($from.depth);\n\n        // Ensure we are inside a textblock (not identifying the doc or non-textblock)\n        if (!$from.parent.isTextblock) return pluginState;\n\n        const textToCursor = newState.doc.textBetween(textBlockStart, $from.pos, '', '');\n\n        // Match \"/\" at line start or after whitespace, followed by optional query\n        const slashMatch = textToCursor.match(/(^|\\s)\\/([^\\s]*)$/);\n\n        if (slashMatch) {\n          const query = slashMatch[2] || '';\n          const slashOffset = textToCursor.length - slashMatch[0].length + (slashMatch[1] ? 1 : 0);\n          const triggerPos = textBlockStart + slashOffset;\n\n          const newPluginState: SlashMenuState = {\n            active: true,\n            query,\n            triggerPos,\n            position: pluginState.position, // Preserve position until view.update calculates it\n          };\n\n          // Only notify on query changes if already active (position update comes from view.update)\n          if (pluginState.active && query !== pluginState.query) {\n            setTimeout(() => onStateChange(newPluginState), 0);\n          }\n          // If becoming active, view.update will call onStateChange with correct position\n          return newPluginState;\n        }\n\n        // No match - close menu if it was open\n        if (pluginState.active) {\n          const newPluginState = { ...initialState };\n          setTimeout(() => onStateChange(newPluginState), 0);\n          return newPluginState;\n        }\n\n        return pluginState;\n      },\n    },\n\n    view(_editorView: EditorView) {\n      return {\n        update(view: EditorView) {\n          const pluginState = slashMenuKey.getState(view.state);\n          if (pluginState?.active) {\n            // Calculate menu position based on trigger position\n            try {\n              const coords = view.coordsAtPos(pluginState.triggerPos);\n              const newTop = coords.bottom + 4;\n              const newLeft = coords.left;\n\n              // Only update position if we get valid coordinates (not 0,0)\n              // This can happen during rapid typing or when position is off-screen\n              const hasValidPosition = newTop > 0 || newLeft > 0;\n              const position = hasValidPosition ? { top: newTop, left: newLeft } : pluginState.position; // Keep existing position if new one is invalid\n\n              const newState: SlashMenuState = {\n                ...pluginState,\n                position,\n              };\n              onStateChange(newState);\n            } catch {\n              // Position calculation may fail during rapid updates\n              // Still notify state change to update query filtering\n              onStateChange(pluginState);\n            }\n          }\n        },\n      };\n    },\n\n    props: {\n      handleKeyDown(view, event) {\n        const pluginState = slashMenuKey.getState(view.state);\n        if (!pluginState?.active) return false;\n\n        // Intercept these keys to prevent ProseMirror from handling them\n        // The menu component's document listener handles the actual navigation\n        if (event.key === 'ArrowDown' || event.key === 'ArrowUp' || event.key === 'Enter' || event.key === 'Tab') {\n          return true; // Tell ProseMirror we handled it\n        }\n\n        if (event.key === 'Escape') {\n          closeSlashMenu(view);\n          return true;\n        }\n\n        return false;\n      },\n    },\n  });\n}\n\n/**\n * Close the slash menu programmatically.\n */\nexport function closeSlashMenu(view: EditorView): void {\n  view.dispatch(view.state.tr.setMeta(slashMenuKey, { close: true }));\n}\n","// ProseMirror plugin for drag-and-drop file upload support.\n\nimport { Plugin, PluginKey } from 'prosemirror-state';\nimport type { EditorView } from 'prosemirror-view';\n\nexport interface DropUploadState {\n  isDragging: boolean;\n}\n\nexport const dropUploadKey = new PluginKey<DropUploadState>('dropUpload');\n\nexport interface DropUploadOptions {\n  /** Callback when files are dropped. Returns position in document. */\n  onFileDrop: (files: File[], pos: number) => void;\n}\n\n/**\n * Creates a ProseMirror plugin that handles drag-and-drop file uploads.\n * Sets isDragging state during drag for CSS styling.\n */\nexport function createDropUploadPlugin(options: DropUploadOptions): Plugin<DropUploadState> {\n  return new Plugin<DropUploadState>({\n    key: dropUploadKey,\n\n    state: {\n      init() {\n        return { isDragging: false };\n      },\n      apply(tr, pluginState) {\n        const meta = tr.getMeta(dropUploadKey);\n        if (meta !== undefined) {\n          return { isDragging: meta.isDragging };\n        }\n        return pluginState;\n      },\n    },\n\n    props: {\n      attributes(state): { [name: string]: string } {\n        const pluginState = dropUploadKey.getState(state);\n        if (pluginState?.isDragging) {\n          return { class: 'drop-target-active' };\n        }\n        return {};\n      },\n\n      handleDOMEvents: {\n        dragenter(view: EditorView, event: DragEvent) {\n          // Only handle if dragging files\n          if (!event.dataTransfer?.types.includes('Files')) {\n            return false;\n          }\n          event.preventDefault();\n          setDragging(view, true);\n          return false;\n        },\n\n        dragover(_view: EditorView, event: DragEvent) {\n          // Only handle if dragging files\n          if (!event.dataTransfer?.types.includes('Files')) {\n            return false;\n          }\n          event.preventDefault();\n          // Set drop effect\n          if (event.dataTransfer) {\n            event.dataTransfer.dropEffect = 'copy';\n          }\n          return false;\n        },\n\n        dragleave(view: EditorView, event: DragEvent) {\n          // Check if we're leaving the editor entirely\n          const target = event.relatedTarget as Node | null;\n          const editorDom = view.dom;\n          if (!target || !editorDom.contains(target)) {\n            setDragging(view, false);\n          }\n          return false;\n        },\n\n        drop(view: EditorView, event: DragEvent) {\n          setDragging(view, false);\n\n          const files = event.dataTransfer?.files;\n          if (!files || files.length === 0) {\n            return false;\n          }\n\n          // Check if any files match our supported types\n          const validFiles: File[] = [];\n          for (const file of files) {\n            if (isValidFileType(file.type)) {\n              validFiles.push(file);\n            }\n          }\n\n          if (validFiles.length === 0) {\n            return false;\n          }\n\n          event.preventDefault();\n\n          // Get drop position in document\n          const pos = view.posAtCoords({ left: event.clientX, top: event.clientY });\n          if (!pos) {\n            // Fallback to end of document\n            options.onFileDrop(validFiles, view.state.doc.content.size);\n            return true;\n          }\n\n          options.onFileDrop(validFiles, pos.pos);\n          return true;\n        },\n      },\n    },\n  });\n}\n\nfunction setDragging(view: EditorView, isDragging: boolean): void {\n  const currentState = dropUploadKey.getState(view.state);\n  if (currentState?.isDragging !== isDragging) {\n    view.dispatch(view.state.tr.setMeta(dropUploadKey, { isDragging }));\n  }\n}\n\nfunction isValidFileType(mimeType: string): boolean {\n  return (\n    mimeType === 'image/png' ||\n    mimeType === 'image/jpeg' ||\n    mimeType === 'image/gif' ||\n    mimeType === 'image/webp' ||\n    mimeType === 'image/svg+xml' ||\n    mimeType === 'image/avif' ||\n    mimeType === 'application/pdf'\n  );\n}\n","// ProseMirror plugin for highlighting invalid (broken) internal page links.\n\nimport { Plugin, PluginKey } from 'prosemirror-state';\nimport { Decoration, DecorationSet } from 'prosemirror-view';\nimport type { EditorView } from 'prosemirror-view';\nimport type { Node as ProseMirrorNode } from 'prosemirror-model';\nimport type { NodeTitleMap } from './markdown-utils';\n\n/**\n * Pattern to extract nodeId from internal page link URLs.\n * Matches: /w/{wsId}+{slug}/{nodeId}+{slug}\n * Captures: group 1 = wsId, group 2 = nodeId\n * Note: Pattern aligned with parseNodeUrl in urls.ts\n */\nexport const INTERNAL_LINK_URL_PATTERN = /^\\/w\\/([^/+]+)(?:\\+[^/]*)?\\/([a-zA-Z0-9_-]+)(?:\\+.*)?$/;\n\nexport interface InvalidLinkPluginState {\n  decorations: DecorationSet;\n  linkedNodeTitles: NodeTitleMap;\n  wsId: string | undefined;\n}\n\nexport const invalidLinkPluginKey = new PluginKey<InvalidLinkPluginState>('invalidLink');\n\n/**\n * Check if a link URL is an internal page link and if the target page exists.\n * Returns true if the link is invalid (broken).\n */\nfunction isInvalidInternalLink(href: string, linkedNodeTitles: NodeTitleMap, wsId: string | undefined): boolean {\n  if (!wsId || !href) return false;\n\n  const match = href.match(INTERNAL_LINK_URL_PATTERN);\n  if (!match) {\n    // Debug: log if pattern doesn't match internal-looking links\n    if (href.startsWith('/w/')) {\n      console.warn('[invalidLink] Pattern did not match:', href);\n    }\n    return false;\n  }\n\n  const linkWsId = match[1];\n  const nodeId = match[2];\n\n  // Only check links within the current workspace\n  if (linkWsId !== wsId) return false;\n\n  // Link is invalid if the node ID is not in the titles map\n  if (!nodeId) return false;\n\n  return !(nodeId in linkedNodeTitles);\n}\n\n/**\n * Build decoration set by scanning the document for invalid links.\n */\nfunction buildDecorations(\n  doc: ProseMirrorNode,\n  linkedNodeTitles: NodeTitleMap,\n  wsId: string | undefined\n): DecorationSet {\n  const decorations: Decoration[] = [];\n\n  doc.descendants((node, pos) => {\n    // Check each mark on text nodes\n    if (node.isText) {\n      const linkMark = node.marks.find((m) => m.type.name === 'link');\n      if (linkMark && linkMark.attrs.href) {\n        const href = linkMark.attrs.href as string;\n        if (isInvalidInternalLink(href, linkedNodeTitles, wsId)) {\n          // Add inline decoration for the entire text node with the link\n          decorations.push(Decoration.inline(pos, pos + node.nodeSize, { class: 'invalid-link' }));\n        }\n      }\n    }\n    return true; // Continue traversing\n  });\n\n  return DecorationSet.create(doc, decorations);\n}\n\n/**\n * Creates a ProseMirror plugin that highlights invalid internal page links.\n * Invalid links are those pointing to pages that don't exist (not in linkedNodeTitles).\n */\nexport function createInvalidLinkPlugin(): Plugin<InvalidLinkPluginState> {\n  return new Plugin<InvalidLinkPluginState>({\n    key: invalidLinkPluginKey,\n\n    state: {\n      init() {\n        return {\n          decorations: DecorationSet.empty,\n          linkedNodeTitles: {},\n          wsId: undefined,\n        };\n      },\n\n      apply(tr, pluginState, _oldState, newState) {\n        // Check for meta to update linkedNodeTitles or wsId\n        const meta = tr.getMeta(invalidLinkPluginKey);\n        if (meta) {\n          const newLinkedNodeTitles = meta.linkedNodeTitles ?? pluginState.linkedNodeTitles;\n          const newWsId = meta.wsId ?? pluginState.wsId;\n\n          // Rebuild decorations with new titles\n          return {\n            decorations: buildDecorations(newState.doc, newLinkedNodeTitles, newWsId),\n            linkedNodeTitles: newLinkedNodeTitles,\n            wsId: newWsId,\n          };\n        }\n\n        // If document changed, rebuild decorations\n        if (tr.docChanged) {\n          return {\n            ...pluginState,\n            decorations: buildDecorations(newState.doc, pluginState.linkedNodeTitles, pluginState.wsId),\n          };\n        }\n\n        // Map decorations through the transaction\n        return {\n          ...pluginState,\n          decorations: pluginState.decorations.map(tr.mapping, tr.doc),\n        };\n      },\n    },\n\n    props: {\n      decorations(state) {\n        return invalidLinkPluginKey.getState(state)?.decorations ?? DecorationSet.empty;\n      },\n    },\n  });\n}\n\n/**\n * Update the plugin's linkedNodeTitles and wsId.\n * Call this when the titles map or workspace changes.\n */\nexport function updateInvalidLinkState(\n  view: EditorView,\n  linkedNodeTitles: NodeTitleMap,\n  wsId: string | undefined\n): void {\n  const tr = view.state.tr.setMeta(invalidLinkPluginKey, { linkedNodeTitles, wsId });\n  view.dispatch(tr);\n}\n","// Hook for uploading assets to a node via multipart form data.\n\nimport { createSignal } from 'solid-js';\nimport type { UploadNodeAssetResponse } from '@sdk/types.gen';\n\n// Client-side limits for quick feedback. Backend enforces these authoritatively.\nconst MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB\n\nconst ALLOWED_MIME_TYPES = new Set([\n  'image/png',\n  'image/jpeg',\n  'image/gif',\n  'image/webp',\n  'image/svg+xml',\n  'image/avif',\n  'application/pdf',\n]);\n\nexport interface UploadResult {\n  name: string;\n  mimeType: string;\n  url: string;\n}\n\nexport interface UseAssetUploadOptions {\n  wsId: string;\n  nodeId: string;\n  getToken: () => string | null;\n}\n\nexport interface UseAssetUploadReturn {\n  uploadFile: (file: File) => Promise<UploadResult | null>;\n  uploading: () => boolean;\n  error: () => string | null;\n}\n\nexport function useAssetUpload(options: UseAssetUploadOptions): UseAssetUploadReturn {\n  const [uploading, setUploading] = createSignal(false);\n  const [error, setError] = createSignal<string | null>(null);\n\n  const uploadFile = async (file: File): Promise<UploadResult | null> => {\n    setError(null);\n\n    // Validate file size\n    if (file.size > MAX_FILE_SIZE) {\n      const err = `File too large: ${file.name} (max 10MB)`;\n      setError(err);\n      console.error(err);\n      return null;\n    }\n\n    // Validate MIME type\n    if (!ALLOWED_MIME_TYPES.has(file.type)) {\n      const err = `Unsupported file type: ${file.type}`;\n      setError(err);\n      console.error(err);\n      return null;\n    }\n\n    const token = options.getToken();\n    if (!token) {\n      const err = 'Not authenticated';\n      setError(err);\n      console.error(err);\n      return null;\n    }\n\n    setUploading(true);\n    try {\n      const formData = new FormData();\n      formData.append('file', file);\n\n      const response = await fetch(`/api/v1/workspaces/${options.wsId}/nodes/${options.nodeId}/assets`, {\n        method: 'POST',\n        headers: {\n          Authorization: `Bearer ${token}`,\n        },\n        body: formData,\n      });\n\n      if (!response.ok) {\n        const errText = await response.text();\n        throw new Error(`Upload failed: ${response.status} ${errText}`);\n      }\n\n      const result: UploadNodeAssetResponse = await response.json();\n      return {\n        name: result.name,\n        mimeType: result.mime_type,\n        url: result.url,\n      };\n    } catch (err) {\n      const errMsg = err instanceof Error ? err.message : String(err);\n      setError(errMsg);\n      console.error('Asset upload failed:', err);\n      return null;\n    } finally {\n      setUploading(false);\n    }\n  };\n\n  return {\n    uploadFile,\n    uploading,\n    error,\n  };\n}\n\n/** Check if a MIME type represents an image */\nexport function isImageMimeType(mimeType: string): boolean {\n  return mimeType.startsWith('image/');\n}\n","import { type Command } from 'prosemirror-state';\nimport { type BlockType } from './schema';\n\n/**\n * Delete a block at the given position.\n */\nexport function deleteBlock(pos: number): Command {\n  return (state, dispatch) => {\n    const node = state.doc.nodeAt(pos);\n    if (!node) return false;\n\n    if (dispatch) {\n      dispatch(state.tr.delete(pos, pos + node.nodeSize));\n    }\n    return true;\n  };\n}\n\n/**\n * Delete multiple blocks at the given positions.\n * Positions should be in document order.\n */\nexport function deleteBlocks(positions: number[]): Command {\n  return (state, dispatch) => {\n    if (positions.length === 0) return false;\n\n    // Sort in descending order to delete from end first\n    const sortedPositions = [...positions].sort((a, b) => b - a);\n\n    let tr = state.tr;\n    for (const pos of sortedPositions) {\n      const node = tr.doc.nodeAt(pos);\n      if (node) {\n        // Remap position through previous deletions\n        const mappedPos = tr.mapping.map(pos);\n        tr = tr.delete(mappedPos, mappedPos + node.nodeSize);\n      }\n    }\n\n    if (dispatch) {\n      dispatch(tr);\n    }\n    return true;\n  };\n}\n\n/**\n * Duplicate a block at the given position.\n * New block is inserted immediately after.\n */\nexport function duplicateBlock(pos: number): Command {\n  return (state, dispatch) => {\n    const node = state.doc.nodeAt(pos);\n    if (!node) return false;\n\n    if (dispatch) {\n      const insertPos = pos + node.nodeSize;\n      dispatch(state.tr.insert(insertPos, node.copy(node.content)));\n    }\n    return true;\n  };\n}\n\n/**\n * Duplicate multiple blocks at the given positions.\n * New blocks are inserted after the last selected block.\n */\nexport function duplicateBlocks(positions: number[]): Command {\n  return (state, dispatch) => {\n    if (positions.length === 0) return false;\n\n    // Sort positions in ascending order\n    const sortedPositions = [...positions].sort((a, b) => a - b);\n\n    // Find last position and collect nodes\n    const nodes: (typeof state.doc.nodeAt extends (p: number) => infer R ? Exclude<R, null> : never)[] = [];\n    let lastPos = 0;\n    let lastNodeSize = 0;\n\n    for (const pos of sortedPositions) {\n      const node = state.doc.nodeAt(pos);\n      if (node) {\n        nodes.push(node);\n        if (pos > lastPos) {\n          lastPos = pos;\n          lastNodeSize = node.nodeSize;\n        }\n      }\n    }\n\n    if (nodes.length === 0) return false;\n\n    if (dispatch) {\n      let tr = state.tr;\n      let insertPos = lastPos + lastNodeSize;\n\n      for (const node of nodes) {\n        tr = tr.insert(insertPos, node.copy(node.content));\n        insertPos += node.nodeSize;\n      }\n\n      dispatch(tr);\n    }\n    return true;\n  };\n}\n\n/**\n * Convert a block to a different type.\n */\nexport function convertBlock(\n  pos: number,\n  toType: BlockType,\n  attrs?: { level?: number; checked?: boolean; language?: string }\n): Command {\n  return (state, dispatch) => {\n    const node = state.doc.nodeAt(pos);\n    if (!node) return false;\n\n    if (dispatch) {\n      const newAttrs = {\n        ...node.attrs,\n        type: toType,\n        ...attrs,\n      };\n\n      // Clear type-specific attrs when converting\n      if (toType !== 'heading') {\n        newAttrs.level = undefined;\n      }\n      if (toType !== 'task') {\n        newAttrs.checked = undefined;\n      }\n      if (toType !== 'code') {\n        newAttrs.language = undefined;\n      }\n\n      dispatch(state.tr.setNodeMarkup(pos, undefined, newAttrs));\n    }\n    return true;\n  };\n}\n\n/**\n * Convert multiple blocks to a different type.\n */\nexport function convertBlocks(\n  positions: number[],\n  toType: BlockType,\n  attrs?: { level?: number; checked?: boolean; language?: string }\n): Command {\n  return (state, dispatch) => {\n    if (positions.length === 0) return false;\n\n    let tr = state.tr;\n    let modified = false;\n\n    for (const pos of positions) {\n      const node = tr.doc.nodeAt(pos);\n      if (!node) continue;\n\n      const newAttrs = {\n        ...node.attrs,\n        type: toType,\n        ...attrs,\n      };\n\n      // Clear type-specific attrs when converting\n      if (toType !== 'heading') {\n        newAttrs.level = undefined;\n      }\n      if (toType !== 'task') {\n        newAttrs.checked = undefined;\n      }\n      if (toType !== 'code') {\n        newAttrs.language = undefined;\n      }\n\n      tr = tr.setNodeMarkup(pos, undefined, newAttrs);\n      modified = true;\n    }\n\n    if (!modified) return false;\n\n    if (dispatch) {\n      dispatch(tr);\n    }\n    return true;\n  };\n}\n\n/**\n * Increase indentation of a block.\n * Maximum indent level is 8.\n */\nexport function indentBlock(pos: number): Command {\n  return (state, dispatch) => {\n    const node = state.doc.nodeAt(pos);\n    if (!node) return false;\n\n    const currentIndent = (node.attrs.indent as number) || 0;\n    if (currentIndent >= 8) return false; // Max indent\n\n    if (dispatch) {\n      dispatch(\n        state.tr.setNodeMarkup(pos, undefined, {\n          ...node.attrs,\n          indent: currentIndent + 1,\n        })\n      );\n    }\n    return true;\n  };\n}\n\n/**\n * Decrease indentation of a block.\n * Minimum indent level is 0.\n */\nexport function outdentBlock(pos: number): Command {\n  return (state, dispatch) => {\n    const node = state.doc.nodeAt(pos);\n    if (!node) return false;\n\n    const currentIndent = (node.attrs.indent as number) || 0;\n    if (currentIndent <= 0) return false;\n\n    if (dispatch) {\n      dispatch(\n        state.tr.setNodeMarkup(pos, undefined, {\n          ...node.attrs,\n          indent: currentIndent - 1,\n        })\n      );\n    }\n    return true;\n  };\n}\n\n/**\n * Indent multiple blocks.\n */\nexport function indentBlocks(positions: number[]): Command {\n  return (state, dispatch) => {\n    if (positions.length === 0) return false;\n\n    let tr = state.tr;\n    let modified = false;\n\n    for (const pos of positions) {\n      const node = tr.doc.nodeAt(pos);\n      if (!node) continue;\n\n      const currentIndent = (node.attrs.indent as number) || 0;\n      if (currentIndent >= 8) continue;\n\n      tr = tr.setNodeMarkup(pos, undefined, {\n        ...node.attrs,\n        indent: currentIndent + 1,\n      });\n      modified = true;\n    }\n\n    if (!modified) return false;\n\n    if (dispatch) {\n      dispatch(tr);\n    }\n    return true;\n  };\n}\n\n/**\n * Outdent multiple blocks.\n */\nexport function outdentBlocks(positions: number[]): Command {\n  return (state, dispatch) => {\n    if (positions.length === 0) return false;\n\n    let tr = state.tr;\n    let modified = false;\n\n    for (const pos of positions) {\n      const node = tr.doc.nodeAt(pos);\n      if (!node) continue;\n\n      const currentIndent = (node.attrs.indent as number) || 0;\n      if (currentIndent <= 0) continue;\n\n      tr = tr.setNodeMarkup(pos, undefined, {\n        ...node.attrs,\n        indent: currentIndent - 1,\n      });\n      modified = true;\n    }\n\n    if (!modified) return false;\n\n    if (dispatch) {\n      dispatch(tr);\n    }\n    return true;\n  };\n}\n\n/**\n * Toggle task completion state.\n */\nexport function toggleTaskBlock(pos: number): Command {\n  return (state, dispatch) => {\n    const node = state.doc.nodeAt(pos);\n    if (!node || node.attrs.type !== 'task') return false;\n\n    if (dispatch) {\n      dispatch(\n        state.tr.setNodeMarkup(pos, undefined, {\n          ...node.attrs,\n          checked: !node.attrs.checked,\n        })\n      );\n    }\n    return true;\n  };\n}\n","// Editor-specific block context menu component.\n// Wraps the shared ContextMenu with editor-specific actions.\n\nimport { createSignal, onMount, onCleanup, Show, type JSX } from 'solid-js';\nimport type { EditorView } from 'prosemirror-view';\nimport { ContextMenu, type ContextMenuAction } from '../shared/ContextMenu';\nimport { useI18n } from '../../i18n';\nimport { deleteBlock, duplicateBlock, convertBlock, indentBlock, outdentBlock } from './blockCommands';\nimport type { BlockType } from './schema';\nimport { BLOCK_CONTEXT_MENU_EVENT, type BlockContextMenuDetail } from './BlockNodeView';\nimport styles from './BlockContextMenu.module.css';\n\nimport ContentCopyIcon from '@material-symbols/svg-400/outlined/content_copy.svg?solid';\nimport FormatIndentIncreaseIcon from '@material-symbols/svg-400/outlined/format_indent_increase.svg?solid';\nimport FormatIndentDecreaseIcon from '@material-symbols/svg-400/outlined/format_indent_decrease.svg?solid';\nimport DeleteIcon from '@material-symbols/svg-400/outlined/delete.svg?solid';\nimport SubjectIcon from '@material-symbols/svg-400/outlined/subject.svg?solid';\nimport TitleIcon from '@material-symbols/svg-400/outlined/title.svg?solid';\nimport FormatListBulletedIcon from '@material-symbols/svg-400/outlined/format_list_bulleted.svg?solid';\nimport FormatListNumberedIcon from '@material-symbols/svg-400/outlined/format_list_numbered.svg?solid';\nimport ChecklistIcon from '@material-symbols/svg-400/outlined/checklist.svg?solid';\nimport FormatQuoteIcon from '@material-symbols/svg-400/outlined/format_quote.svg?solid';\nimport CodeIcon from '@material-symbols/svg-400/outlined/code.svg?solid';\n\nexport interface BlockContextMenuProps {\n  /** The ProseMirror editor view */\n  view: EditorView | undefined;\n  /** CSS class for the container */\n  class?: string;\n}\n\n/**\n * Block context menu component for the editor.\n * Listens for custom events from BlockNodeView and shows appropriate actions.\n */\nexport function BlockContextMenu(props: BlockContextMenuProps) {\n  const { t } = useI18n();\n  const [menuState, setMenuState] = createSignal<{\n    position: { x: number; y: number };\n    blockPos: number;\n    selectedCount: number;\n  } | null>(null);\n\n  // Listen for context menu events from BlockNodeView\n  const handleBlockContextMenu = (e: Event) => {\n    const event = e as CustomEvent<BlockContextMenuDetail>;\n    const { pos, x, y, selectedCount } = event.detail;\n\n    setMenuState({\n      position: { x, y },\n      blockPos: pos,\n      selectedCount,\n    });\n  };\n\n  onMount(() => {\n    const view = props.view;\n    if (view) {\n      view.dom.addEventListener(BLOCK_CONTEXT_MENU_EVENT, handleBlockContextMenu);\n    }\n  });\n\n  onCleanup(() => {\n    const view = props.view;\n    if (view) {\n      view.dom.removeEventListener(BLOCK_CONTEXT_MENU_EVENT, handleBlockContextMenu);\n    }\n  });\n\n  /**\n   * Get context menu actions based on current state.\n   */\n  const getActions = (): ContextMenuAction[] => {\n    const state = menuState();\n    if (!state) return [];\n\n    const { selectedCount } = state;\n    const isMulti = selectedCount > 1;\n\n    const actions: ContextMenuAction[] = [\n      {\n        id: 'duplicate',\n        label: isMulti\n          ? t('editor.duplicateBlocks') || `Duplicate ${selectedCount} blocks`\n          : t('editor.duplicateBlock') || 'Duplicate block',\n        icon: <ContentCopyIcon />,\n        shortcut: '⌘D',\n      },\n    ];\n\n    // Only show convert options for single blocks\n    if (!isMulti) {\n      actions.push(\n        {\n          id: 'indent',\n          label: t('editor.indent') || 'Indent',\n          icon: <FormatIndentIncreaseIcon />,\n          shortcut: 'Tab',\n          separator: true,\n        },\n        {\n          id: 'outdent',\n          label: t('editor.outdent') || 'Outdent',\n          icon: <FormatIndentDecreaseIcon />,\n          shortcut: '⇧Tab',\n        }\n      );\n\n      // Block type conversion options\n      const blockTypes: { id: string; type: BlockType; label: string; icon: JSX.Element }[] = [\n        {\n          id: 'convert-paragraph',\n          type: 'paragraph',\n          label: t('editor.paragraph') || 'Paragraph',\n          icon: <SubjectIcon />,\n        },\n        {\n          id: 'convert-heading1',\n          type: 'heading',\n          label: (t('editor.heading') || 'Heading') + ' 1',\n          icon: <TitleIcon />,\n        },\n        {\n          id: 'convert-heading2',\n          type: 'heading',\n          label: (t('editor.heading') || 'Heading') + ' 2',\n          icon: <TitleIcon />,\n        },\n        {\n          id: 'convert-bullet',\n          type: 'bullet',\n          label: t('editor.bulletList') || 'Bullet list',\n          icon: <FormatListBulletedIcon />,\n        },\n        {\n          id: 'convert-number',\n          type: 'number',\n          label: t('editor.numberedList') || 'Numbered list',\n          icon: <FormatListNumberedIcon />,\n        },\n        { id: 'convert-task', type: 'task', label: t('editor.taskList') || 'Task list', icon: <ChecklistIcon /> },\n        { id: 'convert-quote', type: 'quote', label: t('editor.blockquote') || 'Quote', icon: <FormatQuoteIcon /> },\n        { id: 'convert-code', type: 'code', label: t('editor.codeBlock') || 'Code block', icon: <CodeIcon /> },\n      ];\n\n      blockTypes.forEach((bt, i) => {\n        actions.push({\n          id: bt.id,\n          label: bt.label,\n          icon: bt.icon,\n          separator: i === 0,\n        });\n      });\n    }\n\n    // Delete action always last with separator\n    actions.push({\n      id: 'delete',\n      label: isMulti\n        ? t('editor.deleteBlocks') || `Delete ${selectedCount} blocks`\n        : t('editor.deleteBlock') || 'Delete block',\n      icon: <DeleteIcon />,\n      shortcut: '⌫',\n      danger: true,\n      separator: true,\n    });\n\n    return actions;\n  };\n\n  /**\n   * Handle action selection.\n   * Uses view.state and view.dispatch directly to avoid stale closures and binding issues.\n   */\n  const handleAction = (actionId: string) => {\n    const view = props.view;\n    const state = menuState();\n    if (!view || !state) {\n      setMenuState(null);\n      return;\n    }\n\n    const { blockPos } = state;\n\n    switch (actionId) {\n      case 'delete':\n        deleteBlock(blockPos)(view.state, view.dispatch);\n        break;\n      case 'duplicate':\n        duplicateBlock(blockPos)(view.state, view.dispatch);\n        break;\n      case 'indent':\n        indentBlock(blockPos)(view.state, view.dispatch);\n        break;\n      case 'outdent':\n        outdentBlock(blockPos)(view.state, view.dispatch);\n        break;\n      case 'convert-paragraph':\n        convertBlock(blockPos, 'paragraph')(view.state, view.dispatch);\n        break;\n      case 'convert-heading1':\n        convertBlock(blockPos, 'heading', { level: 1 })(view.state, view.dispatch);\n        break;\n      case 'convert-heading2':\n        convertBlock(blockPos, 'heading', { level: 2 })(view.state, view.dispatch);\n        break;\n      case 'convert-bullet':\n        convertBlock(blockPos, 'bullet')(view.state, view.dispatch);\n        break;\n      case 'convert-number':\n        convertBlock(blockPos, 'number')(view.state, view.dispatch);\n        break;\n      case 'convert-task':\n        convertBlock(blockPos, 'task', { checked: false })(view.state, view.dispatch);\n        break;\n      case 'convert-quote':\n        convertBlock(blockPos, 'quote')(view.state, view.dispatch);\n        break;\n      case 'convert-code':\n        convertBlock(blockPos, 'code')(view.state, view.dispatch);\n        break;\n      default:\n        // Unknown action\n        break;\n    }\n\n    // Close menu after action\n    setMenuState(null);\n  };\n\n  /**\n   * Handle menu close.\n   */\n  const handleClose = () => {\n    setMenuState(null);\n  };\n\n  return (\n    <div class={`${styles.container} ${props.class || ''}`}>\n      <Show when={menuState()}>\n        {(state) => (\n          <ContextMenu\n            position={state().position}\n            actions={getActions()}\n            onAction={handleAction}\n            onClose={handleClose}\n          />\n        )}\n      </Show>\n    </div>\n  );\n}\n","// Editor drop indicator component that renders during block drag-and-drop.\n// Shows a horizontal line at the insertion point between blocks.\n\nimport { createSignal, createEffect, onCleanup, Show } from 'solid-js';\nimport type { EditorView } from 'prosemirror-view';\nimport { getDragState } from './blockDragPlugin';\nimport styles from './EditorDropIndicator.module.css';\n\nexport interface EditorDropIndicatorProps {\n  view: EditorView | undefined;\n}\n\n/**\n * Drop indicator that shows where a dragged block will be inserted.\n * Wraps the EditorView's dispatch to track drag state changes.\n */\nexport function EditorDropIndicator(props: EditorDropIndicatorProps) {\n  const [indicatorY, setIndicatorY] = createSignal<number | null>(null);\n  let containerRef: HTMLDivElement | undefined;\n\n  // Track when we've wrapped dispatch to avoid wrapping multiple times\n  let wrappedView: EditorView | null = null;\n  let originalDispatch: EditorView['dispatch'] | null = null;\n\n  /**\n   * Update indicator position based on drag state.\n   */\n  const updateIndicator = (view: EditorView) => {\n    const dragState = getDragState(view.state);\n    const isCurrentlyDragging =\n      dragState.sourcePos !== null || (dragState.selectedPositions && dragState.selectedPositions.length > 0);\n\n    if (isCurrentlyDragging && dragState.dropIndicatorY !== null && containerRef) {\n      // Convert viewport Y to container-relative Y\n      const containerRect = containerRef.getBoundingClientRect();\n      const relativeY = dragState.dropIndicatorY - containerRect.top;\n      setIndicatorY(relativeY);\n    } else {\n      setIndicatorY(null);\n    }\n  };\n\n  // Watch for view changes and wrap dispatch\n  createEffect(() => {\n    const view = props.view;\n\n    // Unwrap previous view if different\n    if (wrappedView && wrappedView !== view && originalDispatch) {\n      wrappedView.dispatch = originalDispatch;\n      wrappedView = null;\n      originalDispatch = null;\n    }\n\n    if (!view || wrappedView === view) return;\n\n    // Store original dispatch\n    const boundDispatch = view.dispatch.bind(view);\n    originalDispatch = boundDispatch;\n    wrappedView = view;\n\n    // Wrap dispatch to intercept state changes\n    view.dispatch = function (tr) {\n      boundDispatch(tr);\n      updateIndicator(view);\n    };\n  });\n\n  onCleanup(() => {\n    // Restore original dispatch on cleanup\n    if (wrappedView && originalDispatch) {\n      wrappedView.dispatch = originalDispatch;\n    }\n  });\n\n  return (\n    <div ref={containerRef} class={styles.container}>\n      <Show when={indicatorY() !== null}>\n        <div class={styles.indicator} style={{ top: `${indicatorY()}px` }} role=\"presentation\" aria-hidden=\"true\" />\n      </Show>\n    </div>\n  );\n}\n","// Slash command registry defining available block types for the editor menu.\n\nimport type { EditorView } from 'prosemirror-view';\nimport { Selection } from 'prosemirror-state';\nimport { nodes } from './prosemirror-config';\nimport type { BlockAttrs } from './schema';\nimport { convertBlock } from './blockCommands';\n\nimport SubjectIcon from '@material-symbols/svg-400/outlined/subject.svg?solid';\nimport TitleIcon from '@material-symbols/svg-400/outlined/title.svg?solid';\nimport FormatListBulletedIcon from '@material-symbols/svg-400/outlined/format_list_bulleted.svg?solid';\nimport FormatListNumberedIcon from '@material-symbols/svg-400/outlined/format_list_numbered.svg?solid';\nimport ChecklistIcon from '@material-symbols/svg-400/outlined/checklist.svg?solid';\nimport FormatQuoteIcon from '@material-symbols/svg-400/outlined/format_quote.svg?solid';\nimport CodeIcon from '@material-symbols/svg-400/outlined/code.svg?solid';\nimport HorizontalRuleIcon from '@material-symbols/svg-400/outlined/horizontal_rule.svg?solid';\nimport DescriptionIcon from '@material-symbols/svg-400/outlined/description.svg?solid';\n\nexport interface SlashCommand {\n  id: string;\n  labelKey: string; // i18n key under slashMenu.*\n  keywords: string[];\n  icon: SolidSVG;\n  execute: (view: EditorView, from: number, to: number) => void;\n  asyncAction?: 'createSubpage'; // Async actions handled by SlashCommandMenu\n}\n\n// Helper to delete the \"/\" trigger text and execute a command\nfunction deleteSlashAndExecute(view: EditorView, from: number, to: number, action: (view: EditorView) => void) {\n  // Delete the slash command text first\n  const tr = view.state.tr.delete(from, to);\n  view.dispatch(tr);\n\n  // Then execute the action (conversion usually)\n  action(view);\n}\n\n// Helper to convert current block (where cursor is) to another type\nfunction convertCurrentBlock(\n  view: EditorView,\n  type: 'paragraph' | 'heading' | 'bullet' | 'number' | 'task' | 'quote' | 'code' | 'divider',\n  attrs: Partial<BlockAttrs> = {}\n) {\n  const { state, dispatch } = view;\n  const { $from } = state.selection;\n\n  // Find the block ancestor\n  for (let d = $from.depth; d > 0; d--) {\n    const node = $from.node(d);\n    if (node.isBlock) {\n      convertBlock($from.before(d), type, attrs)(state, dispatch);\n      return;\n    }\n  }\n}\n\nexport const slashCommands: SlashCommand[] = [\n  {\n    id: 'paragraph',\n    labelKey: 'paragraph',\n    keywords: ['paragraph', 'text', 'plain'],\n    icon: SubjectIcon,\n    execute: (view, from, to) => {\n      deleteSlashAndExecute(view, from, to, (v) => {\n        convertCurrentBlock(v, 'paragraph');\n      });\n    },\n  },\n  {\n    id: 'heading1',\n    labelKey: 'heading1',\n    keywords: ['heading', 'h1', 'title', 'header'],\n    icon: TitleIcon,\n    execute: (view, from, to) => {\n      deleteSlashAndExecute(view, from, to, (v) => {\n        convertCurrentBlock(v, 'heading', { level: 1 });\n      });\n    },\n  },\n  {\n    id: 'heading2',\n    labelKey: 'heading2',\n    keywords: ['heading', 'h2', 'subtitle', 'header'],\n    icon: TitleIcon,\n    execute: (view, from, to) => {\n      deleteSlashAndExecute(view, from, to, (v) => {\n        convertCurrentBlock(v, 'heading', { level: 2 });\n      });\n    },\n  },\n  {\n    id: 'heading3',\n    labelKey: 'heading3',\n    keywords: ['heading', 'h3', 'header'],\n    icon: TitleIcon,\n    execute: (view, from, to) => {\n      deleteSlashAndExecute(view, from, to, (v) => {\n        convertCurrentBlock(v, 'heading', { level: 3 });\n      });\n    },\n  },\n  {\n    id: 'bulletList',\n    labelKey: 'bulletList',\n    keywords: ['bullet', 'list', 'unordered', 'ul'],\n    icon: FormatListBulletedIcon,\n    execute: (view, from, to) => {\n      deleteSlashAndExecute(view, from, to, (v) => {\n        convertCurrentBlock(v, 'bullet');\n      });\n    },\n  },\n  {\n    id: 'orderedList',\n    labelKey: 'orderedList',\n    keywords: ['ordered', 'list', 'numbered', 'ol'],\n    icon: FormatListNumberedIcon,\n    execute: (view, from, to) => {\n      deleteSlashAndExecute(view, from, to, (v) => {\n        convertCurrentBlock(v, 'number');\n      });\n    },\n  },\n  {\n    id: 'taskList',\n    labelKey: 'taskList',\n    keywords: ['task', 'checkbox', 'todo', 'checklist', 'check'],\n    icon: ChecklistIcon,\n    execute: (view, from, to) => {\n      deleteSlashAndExecute(view, from, to, (v) => {\n        convertCurrentBlock(v, 'task', { checked: false });\n      });\n    },\n  },\n  {\n    id: 'blockquote',\n    labelKey: 'blockquote',\n    keywords: ['quote', 'blockquote', 'citation'],\n    icon: FormatQuoteIcon,\n    execute: (view, from, to) => {\n      deleteSlashAndExecute(view, from, to, (v) => {\n        convertCurrentBlock(v, 'quote');\n      });\n    },\n  },\n  {\n    id: 'codeBlock',\n    labelKey: 'codeBlock',\n    keywords: ['code', 'codeblock', 'pre', 'programming'],\n    icon: CodeIcon,\n    execute: (view, from, to) => {\n      deleteSlashAndExecute(view, from, to, (v) => {\n        convertCurrentBlock(v, 'code');\n      });\n    },\n  },\n  {\n    id: 'divider',\n    labelKey: 'divider',\n    keywords: ['divider', 'hr', 'horizontal', 'rule', 'line'],\n    icon: HorizontalRuleIcon,\n    execute: (view) => {\n      convertCurrentBlock(view, 'divider');\n\n      // Insert paragraph after\n      const { state } = view;\n      const { $from } = state.selection;\n      const blockPos = $from.before(1);\n      const blockNode = state.doc.nodeAt(blockPos);\n\n      if (blockNode) {\n        const newPos = blockPos + blockNode.nodeSize;\n        const tr2 = state.tr.insert(newPos, nodes.block.create({ type: 'paragraph', indent: blockNode.attrs.indent }));\n        tr2.setSelection(Selection.near(tr2.doc.resolve(newPos + 1)));\n        view.dispatch(tr2);\n      }\n    },\n  },\n  {\n    id: 'subpage',\n    labelKey: 'subpage',\n    keywords: ['subpage', 'page', 'child', 'nested', 'link'],\n    icon: DescriptionIcon,\n    asyncAction: 'createSubpage',\n    execute: () => {\n      // Handled by SlashCommandMenu via asyncAction\n    },\n  },\n];\n\n/**\n * Check if query matches text with fuzzy character sequence matching.\n * Returns true if all characters of query appear in order in text.\n * E.g., \"bl\" matches \"bullet\", \"blt\" matches \"bullet list\".\n */\nfunction fuzzyMatch(query: string, text: string): boolean {\n  let qi = 0;\n  for (let ti = 0; ti < text.length && qi < query.length; ti++) {\n    if (text[ti] === query[qi]) qi++;\n  }\n  return qi === query.length;\n}\n\n/**\n * Score how well a query matches text.\n * Higher score = better match. Returns 0 if no match.\n * - 100: Exact match\n * - 90: Prefix match\n * - 70: Contains match\n * - 50: Fuzzy match\n */\nfunction matchScore(query: string, text: string): number {\n  const lowerText = text.toLowerCase();\n  if (lowerText === query) return 100;\n  if (lowerText.startsWith(query)) return 90;\n  if (lowerText.includes(query)) return 70;\n  if (fuzzyMatch(query, lowerText)) return 50;\n  return 0;\n}\n\ntype TranslateFn = (key: string) => string | undefined;\n\n/**\n * Filter commands by query string with fuzzy matching.\n * Matches against labelKey, keywords, and display text (via translate function).\n * Results are sorted by match quality.\n */\nexport function filterCommands(query: string, translate?: TranslateFn): SlashCommand[] {\n  if (!query) return slashCommands;\n\n  const lowerQuery = query.toLowerCase();\n\n  // Score each command\n  const scored = slashCommands\n    .map((cmd) => {\n      let bestScore = 0;\n\n      // Match on label key\n      bestScore = Math.max(bestScore, matchScore(lowerQuery, cmd.labelKey));\n\n      // Match on keywords\n      for (const kw of cmd.keywords) {\n        bestScore = Math.max(bestScore, matchScore(lowerQuery, kw));\n      }\n\n      // Match on display text if translate function provided\n      if (translate) {\n        const displayText = translate(`slashMenu.${cmd.labelKey}`);\n        if (displayText) {\n          bestScore = Math.max(bestScore, matchScore(lowerQuery, displayText));\n        }\n      }\n\n      return { cmd, score: bestScore };\n    })\n    .filter((item) => item.score > 0);\n\n  // Sort by score descending\n  scored.sort((a, b) => b.score - a.score);\n\n  return scored.map((item) => item.cmd);\n}\n","// Slash command menu overlay component for selecting block types.\n\nimport { createSignal, createEffect, For, Show, onMount, onCleanup } from 'solid-js';\nimport { useNavigate } from '@solidjs/router';\nimport type { EditorView } from 'prosemirror-view';\nimport { schema, marks } from './prosemirror-config';\nimport { useI18n } from '../../i18n';\nimport { useAuth } from '../../contexts/AuthContext';\nimport { useWorkspace } from '../../contexts/WorkspaceContext';\nimport { useEditor } from '../../contexts/EditorContext';\nimport { useClickOutside } from '../../composables/useClickOutside';\nimport { nodeUrl } from '../../utils/urls';\nimport { filterCommands, type SlashCommand } from './slashCommands';\nimport { closeSlashMenu, slashMenuKey, type SlashMenuState } from './slashCommandPlugin';\nimport styles from './Editor.module.css';\n\ninterface SlashCommandMenuProps {\n  view: EditorView;\n  state: SlashMenuState;\n  nodeId?: string;\n}\n\nexport default function SlashCommandMenu(props: SlashCommandMenuProps) {\n  const { t } = useI18n();\n  const navigate = useNavigate();\n  const { user, wsApi } = useAuth();\n  const { loadNode, fetchNodeChildren } = useWorkspace();\n  const { flushAutoSave } = useEditor();\n  const [selectedIndex, setSelectedIndex] = createSignal(0);\n  const [adjustedPosition, setAdjustedPosition] = createSignal<{ top: number; left: number } | null>(null);\n  let menuRef: HTMLDivElement | undefined;\n\n  // Filter commands based on query (pass translate function for display text matching)\n  const filteredCommands = () => filterCommands(props.state.query, t);\n\n  // Reset selection and position when query changes or menu activates\n  createEffect(() => {\n    // Track query to trigger effect when it changes\n    void props.state.query;\n    void props.state.active;\n    setSelectedIndex(0);\n    setAdjustedPosition(null); // Reset adjusted position when menu state changes\n  });\n\n  // Adjust position after menu is rendered to prevent viewport overflow\n  createEffect(() => {\n    if (!props.state.active || !menuRef) return;\n\n    // Wait for next frame to ensure the menu has been rendered\n    requestAnimationFrame(() => {\n      if (!menuRef) return;\n\n      const menuRect = menuRef.getBoundingClientRect();\n      const viewportHeight = window.innerHeight;\n      const viewportWidth = window.innerWidth;\n\n      let newTop = props.state.position.top;\n      let newLeft = props.state.position.left;\n\n      // If position is (0, 0), it's likely invalid - recalculate from trigger position\n      if (newTop === 0 && newLeft === 0) {\n        try {\n          const coords = props.view.coordsAtPos(props.state.triggerPos);\n          newTop = coords.bottom + 4;\n          newLeft = coords.left;\n        } catch {\n          // If we can't get coords, keep (0, 0) - will be hidden by Show condition below\n        }\n      }\n\n      // If menu extends beyond viewport bottom, position it above the cursor\n      if (newTop + menuRect.height > viewportHeight) {\n        // Get the cursor coordinates to position above\n        const coords = props.view.coordsAtPos(props.state.triggerPos);\n        // Position menu above cursor (subtract menu height and a small gap)\n        newTop = coords.top - menuRect.height - 4;\n\n        // If still overflowing at top, just position at top of viewport with margin\n        if (newTop < 0) {\n          newTop = 8;\n        }\n      }\n\n      // Prevent menu from extending beyond right edge\n      if (newLeft + menuRect.width > viewportWidth) {\n        newLeft = viewportWidth - menuRect.width - 8;\n      }\n\n      // Prevent menu from extending beyond left edge\n      if (newLeft < 0) {\n        newLeft = 8;\n      }\n\n      // Only update if position changed\n      if (newTop !== props.state.position.top || newLeft !== props.state.position.left) {\n        setAdjustedPosition({ top: newTop, left: newLeft });\n      }\n    });\n  });\n\n  // Scroll selected item into view when selection changes\n  createEffect(() => {\n    const index = selectedIndex();\n    if (menuRef) {\n      const selectedItem = menuRef.querySelector(`[data-index=\"${index}\"]`);\n      if (selectedItem) {\n        selectedItem.scrollIntoView({ block: 'nearest' });\n      }\n    }\n  });\n\n  // Handle click outside to close menu\n  useClickOutside(\n    () => menuRef,\n    () => {\n      if (props.state.active) {\n        closeSlashMenu(props.view);\n      }\n    }\n  );\n\n  // Handle keyboard navigation\n  // Note: We check plugin state directly from ProseMirror rather than props\n  // because props.state may be stale in event handlers (SolidJS closure issue)\n  onMount(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      // Check plugin state directly from ProseMirror (authoritative source)\n      const pluginState = slashMenuKey.getState(props.view.state);\n      if (!pluginState?.active) return;\n\n      const commands = filterCommands(pluginState.query, t);\n      if (commands.length === 0) return;\n\n      switch (e.key) {\n        case 'ArrowDown':\n          e.preventDefault();\n          e.stopPropagation();\n          setSelectedIndex((i) => (i + 1) % commands.length);\n          break;\n        case 'ArrowUp':\n          e.preventDefault();\n          e.stopPropagation();\n          setSelectedIndex((i) => (i - 1 + commands.length) % commands.length);\n          break;\n        case 'Enter':\n        case 'Tab':\n          e.preventDefault();\n          e.stopPropagation();\n          executeCommand(commands[selectedIndex()]);\n          break;\n        case 'Escape':\n          e.preventDefault();\n          e.stopPropagation();\n          closeSlashMenu(props.view);\n          break;\n      }\n    };\n\n    document.addEventListener('keydown', handleKeyDown, true);\n    onCleanup(() => {\n      document.removeEventListener('keydown', handleKeyDown, true);\n    });\n  });\n\n  const executeCommand = async (command: SlashCommand | undefined) => {\n    if (!command) return;\n\n    // Get current plugin state from ProseMirror (authoritative source)\n    const pluginState = slashMenuKey.getState(props.view.state);\n    if (!pluginState) return;\n\n    const { triggerPos } = pluginState;\n    const cursorPos = props.view.state.selection.from;\n\n    // Handle async actions\n    if (command.asyncAction === 'createSubpage') {\n      const ws = wsApi();\n      const u = user();\n      const parentId = props.nodeId;\n      if (!ws || !u || !parentId) return;\n\n      // Delete the slash text first\n      const tr = props.view.state.tr.delete(triggerPos, cursorPos);\n      props.view.dispatch(tr);\n\n      try {\n        // Create the subpage\n        const untitledTitle = t('slashMenu.untitledSubpage') || 'Untitled';\n        const newPage = await ws.nodes.page.createPage(parentId, { title: untitledTitle });\n        if (!newPage?.id) return;\n\n        // Build the URL for the new page\n        const wsId = u.workspace_id;\n        const wsName = u.workspace_name;\n        const url = nodeUrl(wsId || '', wsName, newPage.id, untitledTitle);\n\n        // Insert a proper link node with link mark (not raw markdown text)\n        const linkMark = marks.link.create({ href: url, title: null });\n        const linkNode = schema.text(untitledTitle, [linkMark]);\n        const insertTr = props.view.state.tr.insert(props.view.state.selection.from, linkNode);\n        props.view.dispatch(insertTr);\n\n        // Flush auto-save to persist the link immediately\n        flushAutoSave();\n\n        // Refresh parent's children in sidebar to show new subpage\n        // (loadNodes only refreshes root nodes, fetchNodeChildren refreshes the parent's children)\n        await fetchNodeChildren(parentId);\n\n        // Load the new page data and navigate to it\n        await loadNode(newPage.id);\n        navigate(url);\n      } catch (err) {\n        console.error('Failed to create subpage:', err);\n      }\n\n      props.view.focus();\n      return;\n    }\n\n    // Execute the command (it will delete the \"/\" and query text)\n    command.execute(props.view, triggerPos, cursorPos);\n\n    // Focus back on editor\n    props.view.focus();\n  };\n\n  const handleItemClick = (command: SlashCommand) => {\n    executeCommand(command);\n  };\n\n  const handleItemMouseEnter = (index: number) => {\n    setSelectedIndex(index);\n  };\n\n  // Use adjusted position if available, otherwise use original position\n  const menuPosition = () => adjustedPosition() ?? props.state.position;\n\n  // Hide menu visually while position is being calculated (0, 0)\n  const hasValidPosition = () => {\n    const pos = menuPosition();\n    return pos.top !== 0 || pos.left !== 0;\n  };\n\n  return (\n    <Show when={props.state.active}>\n      <div\n        ref={menuRef}\n        class={styles.slashMenu}\n        data-testid=\"slash-command-menu\"\n        style={{\n          top: `${menuPosition().top}px`,\n          left: `${menuPosition().left}px`,\n          visibility: hasValidPosition() ? 'visible' : 'hidden',\n        }}\n      >\n        <Show\n          when={filteredCommands().length > 0}\n          fallback={<div class={styles.slashMenuEmpty}>{t('slashMenu.noResults')}</div>}\n        >\n          <For each={filteredCommands()}>\n            {(command, index) => (\n              <div\n                class={`${styles.slashMenuItem} ${index() === selectedIndex() ? styles.selected : ''}`}\n                data-index={index()}\n                onClick={() => handleItemClick(command)}\n                onMouseEnter={() => handleItemMouseEnter(index())}\n              >\n                <span class={styles.slashMenuIcon}>\n                  <command.icon />\n                </span>\n                <span class={styles.slashMenuLabel}>{t(`slashMenu.${command.labelKey}`)}</span>\n              </div>\n            )}\n          </For>\n        </Show>\n      </div>\n    </Show>\n  );\n}\n","// Floating editor toolbar with formatting buttons (appears on text selection).\n\nimport { Show, createSignal, createEffect, on } from 'solid-js';\nimport type { EditorView } from 'prosemirror-view';\nimport { toggleMark } from 'prosemirror-commands';\nimport { marks } from './prosemirror-config';\nimport { convertBlocks } from './blockCommands';\nimport { getSelectedBlockPositions } from './blockDragPlugin';\nimport type { BlockType, BlockAttrs } from './schema';\nimport styles from './Editor.module.css';\n\nimport FormatBoldIcon from '@material-symbols/svg-400/outlined/format_bold.svg?solid';\nimport FormatItalicIcon from '@material-symbols/svg-400/outlined/format_italic.svg?solid';\nimport FormatUnderlinedIcon from '@material-symbols/svg-400/outlined/format_underlined.svg?solid';\nimport FormatStrikethroughIcon from '@material-symbols/svg-400/outlined/format_strikethrough.svg?solid';\nimport CodeIcon from '@material-symbols/svg-400/outlined/code.svg?solid';\nimport FormatListBulletedIcon from '@material-symbols/svg-400/outlined/format_list_bulleted.svg?solid';\nimport FormatListNumberedIcon from '@material-symbols/svg-400/outlined/format_list_numbered.svg?solid';\nimport ChecklistIcon from '@material-symbols/svg-400/outlined/checklist.svg?solid';\nimport FormatQuoteIcon from '@material-symbols/svg-400/outlined/format_quote.svg?solid';\nimport TerminalIcon from '@material-symbols/svg-400/outlined/terminal.svg?solid';\n\nexport interface FormatState {\n  isBold: boolean;\n  isItalic: boolean;\n  isUnderline: boolean;\n  isStrikethrough: boolean;\n  isCode: boolean;\n  headingLevel: number | null;\n  isBulletList: boolean;\n  isOrderedList: boolean;\n  isTaskList: boolean;\n  isBlockquote: boolean;\n  isCodeBlock: boolean;\n}\n\ninterface EditorToolbarProps {\n  formatState: FormatState;\n  view: EditorView | undefined;\n  position?: { top: number; bottom: number; left: number } | null;\n  editorElement?: HTMLDivElement;\n}\n\nexport default function EditorToolbar(props: EditorToolbarProps) {\n  let toolbarRef: HTMLDivElement | undefined;\n  const [above, setAbove] = createSignal(false);\n  const [clampedLeft, setClampedLeft] = createSignal<number | null>(null);\n\n  // Check if toolbar fits below selection (flip above if not) and clamp horizontally\n  createEffect(\n    on(\n      () => props.position,\n      () => {\n        if (!props.position || !toolbarRef) {\n          setAbove(false);\n          setClampedLeft(null);\n          return;\n        }\n        // Use requestAnimationFrame to measure after render\n        requestAnimationFrame(() => {\n          if (!toolbarRef || !props.position) return;\n          const rect = toolbarRef.getBoundingClientRect();\n\n          // Vertical: flip above if would overflow bottom\n          const wouldOverflow = props.position.bottom + rect.height + 8 > window.innerHeight;\n          setAbove(wouldOverflow);\n\n          // Horizontal: clamp so toolbar stays within viewport\n          // The toolbar is centered (translateX(-50%)), so we need halfWidth for bounds\n          const halfWidth = rect.width / 2;\n\n          // Use the editor element bounds (accounts for sidebar)\n          const editorRect = props.editorElement?.getBoundingClientRect();\n          const editorLeft = editorRect?.left ?? 0;\n          const editorRight = editorRect?.right ?? window.innerWidth;\n\n          const minLeft = editorLeft + halfWidth;\n          const maxLeft = editorRight - halfWidth;\n          const left = props.position.left;\n\n          if (left < minLeft) {\n            setClampedLeft(minLeft);\n          } else if (left > maxLeft) {\n            setClampedLeft(maxLeft);\n          } else {\n            setClampedLeft(null); // No clamping needed\n          }\n        });\n      }\n    )\n  );\n\n  const formatButtonClass = (isActive: boolean) =>\n    isActive ? `${styles.formatButton} ${styles.isActive}` : styles.formatButton;\n\n  const toggleBold = () => {\n    if (!props.view) return;\n    toggleMark(marks.strong)(props.view.state, props.view.dispatch);\n    props.view.focus();\n  };\n\n  const toggleItalic = () => {\n    if (!props.view) return;\n    toggleMark(marks.em)(props.view.state, props.view.dispatch);\n    props.view.focus();\n  };\n\n  const toggleUnderline = () => {\n    if (!props.view) return;\n    toggleMark(marks.underline)(props.view.state, props.view.dispatch);\n    props.view.focus();\n  };\n\n  const toggleStrikethrough = () => {\n    if (!props.view) return;\n    toggleMark(marks.strikethrough)(props.view.state, props.view.dispatch);\n    props.view.focus();\n  };\n\n  const toggleCode = () => {\n    if (!props.view) return;\n    toggleMark(marks.code)(props.view.state, props.view.dispatch);\n    props.view.focus();\n  };\n\n  // Helper to apply block type conversion to all selected blocks\n  const setBlockType = (type: BlockType, attrs: Partial<BlockAttrs> = {}) => {\n    if (!props.view) return;\n    const { state, dispatch } = props.view;\n    const positions = getSelectedBlockPositions(state);\n\n    // If no blocks selected (e.g. empty selection), use current block\n    if (positions.length === 0) {\n      const { $from } = state.selection;\n      // Start depth 1 because depth 0 is doc\n      for (let d = $from.depth; d > 0; d--) {\n        if ($from.node(d).isBlock) {\n          convertBlocks([$from.before(d)], type, attrs)(state, dispatch);\n          break;\n        }\n      }\n    } else {\n      convertBlocks(positions, type, attrs)(state, dispatch);\n    }\n\n    props.view.focus();\n  };\n\n  const setHeading = (level: number) => {\n    if (props.formatState.headingLevel === level) {\n      setBlockType('paragraph');\n    } else {\n      setBlockType('heading', { level });\n    }\n  };\n\n  const toggleBulletList = () => {\n    if (props.formatState.isBulletList) {\n      setBlockType('paragraph');\n    } else {\n      setBlockType('bullet');\n    }\n  };\n\n  const toggleOrderedList = () => {\n    if (props.formatState.isOrderedList) {\n      setBlockType('paragraph');\n    } else {\n      setBlockType('number');\n    }\n  };\n\n  const toggleTaskList = () => {\n    if (props.formatState.isTaskList) {\n      setBlockType('paragraph');\n    } else {\n      setBlockType('task', { checked: false });\n    }\n  };\n\n  const toggleBlockquote = () => {\n    if (props.formatState.isBlockquote) {\n      setBlockType('paragraph');\n    } else {\n      setBlockType('quote');\n    }\n  };\n\n  const toggleCodeBlock = () => {\n    if (props.formatState.isCodeBlock) {\n      setBlockType('paragraph');\n    } else {\n      setBlockType('code');\n    }\n  };\n\n  return (\n    <Show when={props.position}>\n      <div\n        ref={toolbarRef}\n        class={`${styles.floatingToolbar} ${above() ? styles.above : ''}`}\n        data-testid=\"floating-toolbar\"\n        style={{\n          top: `${above() ? props.position?.top : props.position?.bottom}px`,\n          left: `${clampedLeft() ?? props.position?.left ?? 0}px`,\n        }}\n      >\n        <div class={styles.toolbarRow}>\n          <button class={formatButtonClass(props.formatState.isBold)} onClick={toggleBold} title=\"Bold (Ctrl+B)\">\n            <FormatBoldIcon />\n          </button>\n          <button class={formatButtonClass(props.formatState.isItalic)} onClick={toggleItalic} title=\"Italic (Ctrl+I)\">\n            <FormatItalicIcon />\n          </button>\n          <button\n            class={formatButtonClass(props.formatState.isUnderline)}\n            onClick={toggleUnderline}\n            title=\"Underline (Ctrl+U)\"\n          >\n            <FormatUnderlinedIcon />\n          </button>\n          <button\n            class={formatButtonClass(props.formatState.isStrikethrough)}\n            onClick={toggleStrikethrough}\n            title=\"Strikethrough (Ctrl+Shift+X)\"\n          >\n            <FormatStrikethroughIcon />\n          </button>\n          <button class={formatButtonClass(props.formatState.isCode)} onClick={toggleCode} title=\"Code (Ctrl+`)\">\n            <CodeIcon />\n          </button>\n        </div>\n        <div class={styles.toolbarRow}>\n          <button\n            class={formatButtonClass(props.formatState.headingLevel === 1)}\n            onClick={() => setHeading(1)}\n            title=\"Heading 1\"\n          >\n            H1\n          </button>\n          <button\n            class={formatButtonClass(props.formatState.headingLevel === 2)}\n            onClick={() => setHeading(2)}\n            title=\"Heading 2\"\n          >\n            H2\n          </button>\n          <button\n            class={formatButtonClass(props.formatState.headingLevel === 3)}\n            onClick={() => setHeading(3)}\n            title=\"Heading 3\"\n          >\n            H3\n          </button>\n          <span class={styles.separator} />\n          <button\n            class={formatButtonClass(props.formatState.isBulletList)}\n            onClick={toggleBulletList}\n            title=\"Bullet List\"\n          >\n            <FormatListBulletedIcon />\n          </button>\n          <button\n            class={formatButtonClass(props.formatState.isOrderedList)}\n            onClick={toggleOrderedList}\n            title=\"Numbered List\"\n          >\n            <FormatListNumberedIcon />\n          </button>\n          <button class={formatButtonClass(props.formatState.isTaskList)} onClick={toggleTaskList} title=\"Task List\">\n            <ChecklistIcon />\n          </button>\n          <button class={formatButtonClass(props.formatState.isBlockquote)} onClick={toggleBlockquote} title=\"Quote\">\n            <FormatQuoteIcon />\n          </button>\n          <button class={formatButtonClass(props.formatState.isCodeBlock)} onClick={toggleCodeBlock} title=\"Code Block\">\n            <TerminalIcon />\n          </button>\n        </div>\n      </div>\n    </Show>\n  );\n}\n","// WYSIWYG markdown editor component using ProseMirror with flat block architecture.\n\nimport { createSignal, onMount, onCleanup, createEffect, on, createMemo, Show, untrack } from 'solid-js';\nimport { EditorView } from 'prosemirror-view';\nimport type { Node as ProseMirrorNode } from 'prosemirror-model';\nimport { useI18n } from '../../i18n';\nimport {\n  rewriteAssetUrls,\n  reverseRewriteAssetUrls,\n  rewriteInternalLinkTitles,\n  type NodeTitleMap,\n} from './markdown-utils';\nimport { nodes, marks, createEditorState, schema } from './prosemirror-config';\nimport { parseMarkdown } from './markdown-parser';\nimport { serializeToMarkdown } from './markdown-serializer';\nimport { createBlockNodeView } from './BlockNodeView';\nimport { createSlashCommandPlugin, type SlashMenuState } from './slashCommandPlugin';\nimport { createDropUploadPlugin } from './dropUploadPlugin';\nimport { createInvalidLinkPlugin, updateInvalidLinkState, INTERNAL_LINK_URL_PATTERN } from './invalidLinkPlugin';\nimport { useAssetUpload, isImageMimeType } from './useAssetUpload';\nimport { BlockContextMenu } from './BlockContextMenu';\nimport { EditorDropIndicator } from './EditorDropIndicator';\nimport SlashCommandMenu from './SlashCommandMenu';\nimport EditorToolbar, { type FormatState } from './EditorToolbar';\nimport type { AssetUrlMap } from '../../contexts/EditorContext';\nimport styles from './Editor.module.css';\n\ninterface EditorProps {\n  content: string;\n  nodeId?: string;\n  assetUrls?: AssetUrlMap;\n  linkedNodeTitles?: NodeTitleMap;\n  onChange: (markdown: string) => void;\n  placeholder?: string;\n  readOnly?: boolean;\n  wsId?: string;\n  getToken?: () => string | null;\n  onAssetUploaded?: () => void;\n  onError?: (error: string) => void;\n  onNavigateToNode?: (nodeId: string) => void;\n}\n\nexport default function Editor(props: EditorProps) {\n  const { t } = useI18n();\n  const [editorMode, setEditorMode] = createSignal<'wysiwyg' | 'markdown'>('wysiwyg');\n  const [markdownContent, setMarkdownContent] = createSignal(untrack(() => props.content));\n  const [view, setView] = createSignal<EditorView | undefined>();\n  const [slashMenuState, setSlashMenuState] = createSignal<SlashMenuState>({\n    active: false,\n    query: '',\n    triggerPos: 0,\n    position: { top: 0, left: 0 },\n  });\n  const [editorRef, setEditorRef] = createSignal<HTMLDivElement>();\n\n  // Create slash command plugin with callback\n  const slashPlugin = createSlashCommandPlugin(setSlashMenuState);\n\n  // Create invalid link decoration plugin\n  const invalidLinkPlugin = createInvalidLinkPlugin();\n\n  // Handle file drop uploads\n  const handleFileDrop = async (files: File[], pos: number) => {\n    const editorView = view();\n    if (!editorView || !props.wsId || !props.nodeId || !props.getToken) return;\n\n    const { uploadFile, error } = useAssetUpload({\n      wsId: props.wsId,\n      nodeId: props.nodeId,\n      getToken: props.getToken,\n    });\n\n    for (const file of files) {\n      const result = await uploadFile(file);\n      if (result) {\n        const isImage = isImageMimeType(result.mimeType);\n        let tr = editorView.state.tr;\n\n        if (isImage) {\n          // Flattened block schemas handle images inside blocks or as separate blocks\n          // For now, simpler to insert as a paragraph block with an image mark or inline image?\n          // Schema does not seem to have 'image' node type in 'nodes' export from schema.ts?\n          // Let's check schema.ts... Phase 1 spec didn't mention 'image' block, only 'inline*' content.\n          // Standard ProseMirror uses inline image nodes.\n          // Wait, schema.ts removed 'image' node from baseSchema?\n          // Actually schema.ts removed bullet_list etc but added block. baseSchema has image.\n          // let's assume image node exists in baseSchema marks or nodes.\n          // schema.ts extends baseSchema.spec.nodes.remove(...).addToEnd(...)\n          // baseSchema has 'image' node.\n\n          // However, we can only insert 'block' or 'divider' at top level.\n          // To insert an image, we should insert a paragraph block containing the image node.\n\n          const imageType = schema.nodes.image;\n          // Check if image node exists in our schema\n          if (imageType) {\n            const imageNode = imageType.create({\n              src: result.url,\n              alt: result.name,\n              title: null,\n            });\n\n            // Create a new paragraph block containing the image\n            const block = nodes.block.create({ type: 'paragraph', indent: 0 }, imageNode);\n            tr = tr.insert(pos, block);\n          }\n        } else {\n          // Insert link\n          const linkType = marks.link;\n          if (linkType) {\n            const linkMark = linkType.create({ href: result.url, title: null });\n            const textNode = schema.text(result.name, [linkMark]);\n            // Create a new paragraph block containing the link\n            const block = nodes.block.create({ type: 'paragraph', indent: 0 }, textNode);\n            tr = tr.insert(pos, block);\n          }\n        }\n\n        editorView.dispatch(tr);\n        props.onAssetUploaded?.();\n      } else {\n        const errMsg = error();\n        if (errMsg) props.onError?.(errMsg);\n      }\n    }\n  };\n\n  const dropPlugin = createDropUploadPlugin({ onFileDrop: handleFileDrop });\n\n  let lastLoadedNodeId: string | undefined = untrack(() => props.nodeId);\n  let lastEmittedContent: string = untrack(() => props.content);\n  let lastLinkedNodeTitles: NodeTitleMap | undefined = untrack(() => props.linkedNodeTitles);\n\n  const [formatState, setFormatState] = createSignal<FormatState>({\n    isBold: false,\n    isItalic: false,\n    isUnderline: false,\n    isStrikethrough: false,\n    isCode: false,\n    headingLevel: null,\n    isBulletList: false,\n    isOrderedList: false,\n    isTaskList: false,\n    isBlockquote: false,\n    isCodeBlock: false,\n  });\n\n  const [toolbarPosition, setToolbarPosition] = createSignal<{\n    top: number;\n    bottom: number;\n    left: number;\n  } | null>(null);\n\n  const localParseMarkdown = (md: string): ProseMirrorNode | null => {\n    let processed = rewriteAssetUrls(md, props.assetUrls || {});\n    if (props.wsId && props.linkedNodeTitles && Object.keys(props.linkedNodeTitles).length > 0) {\n      processed = rewriteInternalLinkTitles(processed, props.linkedNodeTitles, props.wsId);\n    }\n    return parseMarkdown(processed);\n  };\n\n  const localSerializeMarkdown = (doc: ProseMirrorNode): string => {\n    const md = serializeToMarkdown(doc);\n    return reverseRewriteAssetUrls(md, props.assetUrls || {});\n  };\n\n  const updateActiveStates = (editorView: EditorView) => {\n    const { state } = editorView;\n    const { from, $from, to, empty } = state.selection;\n\n    // Toolbar position\n    if (empty || editorMode() === 'markdown') {\n      setToolbarPosition(null);\n    } else {\n      try {\n        const start = editorView.coordsAtPos(from);\n        const end = editorView.coordsAtPos(to);\n        const isSameLine = Math.abs(start.top - end.top) < 20;\n        let left = start.left;\n        if (isSameLine) {\n          left = (start.left + end.right) / 2;\n        } else {\n          left = start.left + 40;\n        }\n        setToolbarPosition({\n          top: start.top,\n          bottom: end.bottom,\n          left,\n        });\n      } catch {\n        setToolbarPosition(null);\n      }\n    }\n\n    // Marks\n    const currentMarks = empty ? state.storedMarks || $from.marks() : [];\n    const isBold = marks.strong.isInSet(currentMarks) !== undefined || state.doc.rangeHasMark(from, to, marks.strong);\n    const isItalic = marks.em.isInSet(currentMarks) !== undefined || state.doc.rangeHasMark(from, to, marks.em);\n    const isUnderline =\n      marks.underline.isInSet(currentMarks) !== undefined || state.doc.rangeHasMark(from, to, marks.underline);\n    const isStrikethrough =\n      marks.strikethrough.isInSet(currentMarks) !== undefined || state.doc.rangeHasMark(from, to, marks.strikethrough);\n    const isCode = marks.code.isInSet(currentMarks) !== undefined || state.doc.rangeHasMark(from, to, marks.code);\n\n    // Block attributes\n    // Find the block node at the cursor/selection\n    let blockNode: ProseMirrorNode | null = null;\n\n    // In flat architecture, blocks are always direct children of doc (depth 1)\n    if ($from.depth >= 1) {\n      blockNode = $from.node(1);\n    }\n\n    // If not found (e.g. at start of doc), try nodeAt\n    if (!blockNode && from === 0) {\n      blockNode = state.doc.nodeAt(0);\n    }\n\n    let isBulletList = false;\n    let isOrderedList = false;\n    let isTaskList = false;\n    let isBlockquote = false;\n    let isCodeBlock = false;\n    let headingLevel: number | null = null;\n\n    // If we have a single block context, use it\n    if (blockNode && blockNode.type.name === 'block') {\n      const type = blockNode.attrs.type;\n      if (type === 'bullet') isBulletList = true;\n      if (type === 'number') isOrderedList = true;\n      if (type === 'task') isTaskList = true;\n      if (type === 'quote') isBlockquote = true;\n      if (type === 'code') isCodeBlock = true;\n      if (type === 'heading') headingLevel = blockNode.attrs.level;\n    }\n\n    setFormatState({\n      isBold,\n      isItalic,\n      isUnderline,\n      isStrikethrough,\n      isCode,\n      headingLevel,\n      isBulletList,\n      isOrderedList,\n      isTaskList,\n      isBlockquote,\n      isCodeBlock,\n    });\n  };\n\n  onMount(() => {\n    const editorEl = editorRef();\n    if (!editorEl) return;\n\n    const doc = localParseMarkdown(props.content);\n    if (!doc) return;\n    const state = createEditorState(doc, [slashPlugin, dropPlugin, invalidLinkPlugin]);\n\n    const editorView = new EditorView(editorEl, {\n      state,\n      editable: () => !props.readOnly,\n      nodeViews: {\n        block: createBlockNodeView,\n      },\n      dispatchTransaction(tr) {\n        const newState = editorView.state.apply(tr);\n        editorView.updateState(newState);\n\n        if (tr.docChanged) {\n          const md = localSerializeMarkdown(newState.doc);\n          setMarkdownContent(md);\n          lastEmittedContent = md;\n          props.onChange(md);\n        }\n\n        updateActiveStates(editorView);\n      },\n      handleDOMEvents: {\n        click: (_view, event) => {\n          const target = event.target as HTMLElement;\n          const anchor = target.closest('a');\n          if (!anchor) return false;\n\n          const href = anchor.getAttribute('href');\n          if (!href) return false;\n\n          const match = href.match(INTERNAL_LINK_URL_PATTERN);\n          if (match && match[2] && props.onNavigateToNode) {\n            event.preventDefault();\n            props.onNavigateToNode(match[2]);\n            return true;\n          }\n\n          if (href.startsWith('http://') || href.startsWith('https://')) {\n            event.preventDefault();\n            window.open(href, '_blank', 'noopener,noreferrer');\n            return true;\n          }\n\n          return false;\n        },\n      },\n    });\n\n    const pmEl = editorEl.querySelector('.ProseMirror') as HTMLElement & { pmView?: EditorView };\n    if (pmEl) pmEl.pmView = editorView;\n\n    setView(editorView);\n    updateActiveStates(editorView);\n    updateInvalidLinkState(editorView, props.linkedNodeTitles || {}, props.wsId);\n\n    const handleScroll = () => updateActiveStates(editorView);\n    const scrollContainer = editorEl.closest('[class*=\"prosemirrorEditor\"]') || editorEl;\n    scrollContainer.addEventListener('scroll', handleScroll, { passive: true });\n    window.addEventListener('scroll', handleScroll, { passive: true });\n\n    onCleanup(() => {\n      editorView.destroy();\n      scrollContainer.removeEventListener('scroll', handleScroll);\n      window.removeEventListener('scroll', handleScroll);\n    });\n  });\n\n  createEffect(\n    on(\n      () => [props.nodeId, props.content, props.linkedNodeTitles] as const,\n      ([nodeId, content, linkedNodeTitles]) => {\n        const nodeChanged = nodeId !== lastLoadedNodeId;\n        const contentChangedExternally = content !== lastEmittedContent;\n        const titlesChanged = linkedNodeTitles !== lastLinkedNodeTitles;\n\n        if (nodeChanged || contentChangedExternally || titlesChanged) {\n          lastLoadedNodeId = nodeId;\n          lastEmittedContent = content;\n          lastLinkedNodeTitles = linkedNodeTitles;\n\n          if (nodeChanged || contentChangedExternally) {\n            setMarkdownContent(content);\n            setEditorMode('wysiwyg');\n          }\n\n          const editorView = view();\n          if (editorView) {\n            const doc = localParseMarkdown(content);\n            if (doc) {\n              const state = createEditorState(doc, [slashPlugin, dropPlugin, invalidLinkPlugin]);\n              editorView.updateState(state);\n              updateInvalidLinkState(editorView, linkedNodeTitles || {}, props.wsId);\n            }\n          }\n        }\n      },\n      { defer: true }\n    )\n  );\n\n  const handleMarkdownChange = (value: string) => {\n    setMarkdownContent(value);\n    lastEmittedContent = value;\n    props.onChange(value);\n  };\n\n  const switchToWysiwyg = () => {\n    const editorView = view();\n    if (editorView) {\n      const doc = localParseMarkdown(markdownContent());\n      if (doc) {\n        const state = createEditorState(doc, [slashPlugin, dropPlugin, invalidLinkPlugin]);\n        editorView.updateState(state);\n        updateActiveStates(editorView);\n        updateInvalidLinkState(editorView, props.linkedNodeTitles || {}, props.wsId);\n      }\n    }\n    setEditorMode('wysiwyg');\n  };\n\n  const switchToMarkdown = () => {\n    const editorView = view();\n    if (editorView) {\n      const md = localSerializeMarkdown(editorView.state.doc);\n      setMarkdownContent(md);\n    }\n    setEditorMode('markdown');\n  };\n\n  const toggleMode = () => {\n    if (editorMode() === 'wysiwyg') {\n      switchToMarkdown();\n    } else {\n      switchToWysiwyg();\n    }\n  };\n\n  const handleKeyDown = (e: KeyboardEvent) => {\n    if (e.ctrlKey && e.shiftKey && e.key.toLowerCase() === 'm') {\n      e.preventDefault();\n      toggleMode();\n    }\n  };\n\n  onMount(() => {\n    document.addEventListener('keydown', handleKeyDown);\n  });\n  onCleanup(() => {\n    document.removeEventListener('keydown', handleKeyDown);\n  });\n\n  const wysiwygClass = createMemo(() =>\n    editorMode() === 'wysiwyg' ? styles.prosemirrorEditor : `${styles.prosemirrorEditor} ${styles.hidden}`\n  );\n\n  const markdownClass = createMemo(() =>\n    editorMode() === 'markdown' ? styles.markdownEditor : `${styles.markdownEditor} ${styles.hidden}`\n  );\n\n  return (\n    <div class={styles.editorContainer}>\n      <EditorToolbar\n        formatState={formatState()}\n        view={view()}\n        position={toolbarPosition()}\n        editorElement={editorRef()}\n      />\n\n      {/* Editor context menu */}\n      <BlockContextMenu view={view()} />\n\n      {/* Drop indicator during drag-and-drop */}\n      <EditorDropIndicator view={view()} />\n\n      <div ref={setEditorRef} class={wysiwygClass()} data-testid=\"wysiwyg-editor\" />\n\n      <textarea\n        class={markdownClass()}\n        value={markdownContent()}\n        onInput={(e) => handleMarkdownChange(e.target.value)}\n        placeholder={props.placeholder || t('editor.contentPlaceholder') || 'Write markdown...'}\n        readOnly={props.readOnly}\n        data-testid=\"markdown-editor\"\n      />\n\n      <div class={styles.modeIndicator}>\n        <button\n          class={editorMode() === 'wysiwyg' ? styles.modeIndicatorActive : undefined}\n          onClick={switchToWysiwyg}\n          title=\"Visual mode (Ctrl+Shift+M)\"\n          data-testid=\"editor-mode-visual\"\n        >\n          Visual\n        </button>\n        <button\n          class={editorMode() === 'markdown' ? styles.modeIndicatorActive : undefined}\n          onClick={switchToMarkdown}\n          title=\"Markdown mode (Ctrl+Shift+M)\"\n          data-testid=\"editor-mode-markdown\"\n        >\n          MD\n        </button>\n      </div>\n\n      <Show when={view()}>{(v) => <SlashCommandMenu view={v()} state={slashMenuState()} nodeId={props.nodeId} />}</Show>\n    </div>\n  );\n}\n"],"names":["isLocalFilename","src","includes","startsWith","ASSET_URL_PATTERN","extractFilenameFromAssetUrl","url","match","decodeURIComponent","reverseRewriteAssetUrls","markdown","assetUrls","reverseMap","filename","Object","entries","result","replace","alt","text","href","blockSpec","attrs","type","default","level","indent","checked","number","language","content","group","parseDOM","tag","getAttrs","dom","dataset","parseInt","classes","Array","from","classList","cls","slice","toDOM","node","baseAttrs","String","class","dividerSpec","schema","Schema","nodes","baseSchema","spec","remove","addToEnd","marks","style","getNodeType","name","nodeType","Error","getMarkType","markType","doc","block","divider","strong","em","code","link","underline","strikethrough","blockTypeRule","pattern","InputRule","state","start","end","$start","resolve","parentOffset","blockPos","before","tr","delete","setNodeMarkup","isListType","getCurrentBlock","$from","selection","nodeAt","pos","indentCommand","dispatch","outdentCommand","enterCommand","empty","size","newAttrs","splitPos","split","backspaceCommand","blockDragPluginKey","PluginKey","initialState","sourcePos","dropTarget","dropIndicatorY","selectedPositions","getSelectedBlockPositions","positions","$to","to","range","blockRange","parent","currentPos","i","startIndex","endIndex","child","push","nodeSize","sameParent","depth","nodesBetween","setDragState","updates","setMeta","getDragState","getState","clearDragState","moveBlocks","view","sourcePositions","targetPos","length","sortedPositions","sort","a","b","nodesToMove","adjustedTarget","reversedNodes","reverse","insertPos","insert","blockDragPlugin","Plugin","key","init","apply","meta","getMeta","props","handleDOMEvents","dragover","event","preventDefault","dataTransfer","dropEffect","target","clientX","clientY","coords","left","top","posInfo","posAtCoords","$pos","isBlock","nearestBlock","smallestDistance","Infinity","forEach","nodeStartCoords","coordsAtPos","nodeEndCoords","nodeMidY","bottom","distance","Math","abs","foundBlock","nearestMidY","dropAboveNearest","blockNode","y","above","blockStart","blockEnd","after","startCoords","endCoords","blockMidY","dropAbove","findDropTarget","drop","querySelectorAll","el","dragend","dragleave","relatedTarget","contains","decorations","dragState","this","DecorationSet","blockSelectionPluginKey","blockSelectionPlugin","Decoration","create","numberCounterPlugin","appendTransaction","transactions","_oldState","newState","some","transaction","docChanged","needsUpdate","counters","Map","currentCount","get","set","createEditorState","extraPlugins","EditorState","plugins","inputRules","rules","textContent","smartQuotes","ellipsis","emDash","keymap","Tab","Enter","Backspace","baseKeymap","history","dropCursor","color","width","gapCursor","addListNodes","listItemNode","update","nestedSchema","convertInlineContent","isText","map","m","filter","hardBreakType","hard_break","imageType","image","parseMarkdown","md","MarkdownIt","core","ruler","tokens","token","inlineToken","children","firstChild","attrSet","toLowerCase","inline","silent","max","posMax","closeTag","closePos","indexOf","markup","createMarkdownIt","nestedDoc","MarkdownParser","blockquote","paragraph","list_item","tok","attrGet","bullet_list","ordered_list","order","heading","code_block","noCloseToken","fence","params","info","hr","mark","s","title","code_inline","hardbreak","parse","flatBlocks","blocks","baseIndent","flattenList","flattenListItem","childCount","inner","listNode","listType","counter","item","itemNode","itemType","itemContent","isTask","blockType","blockAttrs","blockContent","BLOCK_CONTEXT_MENU_EVENT","BlockNodeView","constructor","getPos","document","createElement","className","updateDOMAttributes","handleContainer","contentEditable","appendChild","mountHandle","contentDOM","wrapperDOM","createContentElement","handleDispose","element","pre","trim","rowId","render","RowHandle","onDragStart","handleDragStart","bind","onContextMenu","handleContextMenu","onClick","handleClick","e","_rowId","isMultiSelection","setData","JSON","stringify","effectAllowed","blockRect","getBoundingClientRect","offsetX","offsetY","setDragImage","add","setTimeout","selectedCount","detail","x","dispatchEvent","CustomEvent","bubbles","taskContent","querySelector","selectNode","deselectNode","destroy","ignoreMutation","mutation","createBlockNodeView","slashMenuKey","active","query","triggerPos","position","closeSlashMenu","close","dropUploadKey","setDragging","isDragging","currentState","isValidFileType","mimeType","INTERNAL_LINK_URL_PATTERN","invalidLinkPluginKey","buildDecorations","linkedNodeTitles","wsId","descendants","linkMark","find","console","warn","linkWsId","nodeId","isInvalidInternalLink","updateInvalidLinkState","ALLOWED_MIME_TYPES","Set","isImageMimeType","convertBlock","toType","convertBlocks","modified","BlockContextMenu","t","useI18n","menuState","setMenuState","createSignal","handleBlockContextMenu","onMount","addEventListener","onCleanup","removeEventListener","handleAction","actionId","copy","duplicateBlock","currentIndent","indentBlock","outdentBlock","handleClose","_el$","_tmpl$","_$insert","_$createComponent","Show","when","ContextMenu","actions","getActions","isMulti","id","label","icon","ContentCopyIcon","shortcut","FormatIndentIncreaseIcon","separator","FormatIndentDecreaseIcon","SubjectIcon","TitleIcon","FormatListBulletedIcon","FormatListNumberedIcon","ChecklistIcon","FormatQuoteIcon","CodeIcon","bt","DeleteIcon","danger","onAction","onClose","_$effect","_$className","styles","EditorDropIndicator","indicatorY","setIndicatorY","containerRef","wrappedView","originalDispatch","createEffect","boundDispatch","updateIndicator","containerRect","relativeY","_tmpl$2","_$use","_el$2","_p$","_v$","_v$2","_$setStyleProperty","undefined","deleteSlashAndExecute","action","convertCurrentBlock","d","slashCommands","labelKey","keywords","execute","v","HorizontalRuleIcon","newPos","tr2","setSelection","Selection","near","DescriptionIcon","asyncAction","matchScore","lowerText","qi","ti","fuzzyMatch","filterCommands","translate","lowerQuery","scored","cmd","bestScore","kw","displayText","score","SlashCommandMenu","navigate","useNavigate","user","wsApi","useAuth","loadNode","fetchNodeChildren","useWorkspace","flushAutoSave","useEditor","selectedIndex","setSelectedIndex","adjustedPosition","setAdjustedPosition","menuRef","filteredCommands","requestAnimationFrame","menuRect","viewportHeight","window","innerHeight","viewportWidth","innerWidth","newTop","newLeft","height","index","selectedItem","scrollIntoView","useClickOutside","handleKeyDown","pluginState","commands","stopPropagation","executeCommand","async","command","cursorPos","ws","u","parentId","untitledTitle","newPage","page","createPage","workspace_id","wsName","workspace_name","nodeUrl","linkNode","insertTr","err","error","focus","menuPosition","fallback","For","each","_el$3","_tmpl$3","_el$4","_el$5","nextSibling","handleItemMouseEnter","$$click","handleItemClick","_v$5","_v$6","_v$7","_v$8","_$setAttribute","o","_v$3","_v$4","hasValidPosition","_$delegateEvents","EditorToolbar","toolbarRef","setAbove","clampedLeft","setClampedLeft","on","rect","wouldOverflow","halfWidth","editorRect","editorElement","minLeft","maxLeft","right","formatButtonClass","isActive","toggleBold","toggleMark","toggleItalic","toggleUnderline","toggleStrikethrough","toggleCode","setBlockType","setHeading","formatState","headingLevel","toggleBulletList","isBulletList","toggleOrderedList","isOrderedList","toggleTaskList","isTaskList","toggleBlockquote","isBlockquote","toggleCodeBlock","isCodeBlock","_el$6","_el$7","_el$8","_el$9","_el$0","_el$1","_el$10","_el$11","_el$12","_el$13","_el$14","_el$15","FormatBoldIcon","FormatItalicIcon","FormatUnderlinedIcon","FormatStrikethroughIcon","TerminalIcon","isBold","isItalic","isUnderline","isStrikethrough","_v$9","isCode","_v$0","_v$1","_v$10","_v$11","_v$12","_v$13","_v$14","_v$15","_v$16","_v$17","n","h","r","l","c","w","f","g","p","Editor","editorMode","setEditorMode","markdownContent","setMarkdownContent","untrack","setView","slashMenuState","setSlashMenuState","editorRef","setEditorRef","slashPlugin","onStateChange","newPluginState","selectionSet","textBlockStart","isTextblock","textToCursor","textBetween","slashMatch","_editorView","invalidLinkPlugin","newLinkedNodeTitles","newWsId","mapping","dropPlugin","options","onFileDrop","files","editorView","getToken","uploadFile","uploading","setUploading","setError","file","has","formData","FormData","append","response","fetch","method","headers","Authorization","body","ok","errText","status","json","mime_type","errMsg","message","useAssetUpload","isImage","imageNode","linkType","textNode","onAssetUploaded","onError","attributes","dragenter","types","_view","editorDom","validFiles","lastLoadedNodeId","lastEmittedContent","lastLinkedNodeTitles","setFormatState","toolbarPosition","setToolbarPosition","localParseMarkdown","processed","keys","signedUrl","rewriteAssetUrls","nodeTitles","currentWsId","_text","currentTitle","localSerializeMarkdown","lines","listContext","numberCounters","prevType","serializeInline","ctx","pop","prevWasList","currentIsParagraph","indentStr","repeat","prefix","join","serializeToMarkdown","updateActiveStates","isSameLine","currentMarks","storedMarks","isInSet","rangeHasMark","editorEl","EditorView","editable","readOnly","nodeViews","dispatchTransaction","updateState","onChange","click","anchor","closest","getAttribute","onNavigateToNode","open","pmEl","pmView","handleScroll","scrollContainer","passive","nodeChanged","contentChangedExternally","defer","switchToWysiwyg","switchToMarkdown","ctrlKey","shiftKey","wysiwygClass","createMemo","markdownClass","$$input","handleMarkdownChange","value","placeholder"],"mappings":"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"}